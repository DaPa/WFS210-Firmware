Disassembly Listing for WFS220
Generated From:
C:/Files/Ontwerp/WFS220_WiFi_scope/WFS220.X/dist/default/production/WFS220.X.production.elf
25-jun-2013 14:27:53

---  C:/Files/Ontwerp/WFS220_WiFi_scope/WFS220.X/Source Files/main.c  -----------------------------------
1:                 /********************************************************************
2:                  FileName:      main.c
3:                  Dependencies:  See INCLUDES section
4:                  Processor:     PIC18, PIC24, dsPIC, and PIC32 USB Microcontrollers
5:                  Hardware:      This demo is natively intended to be used on Microchip USB demo
6:                                 boards supported by the MCHPFSUSB stack.  See release notes for
7:                                 support matrix.  This demo can be modified for use on other 
8:                                 hardware platforms.
9:                  Complier:      Microchip C18 (for PIC18), XC16 (for PIC24/dsPIC), XC32 (for PIC32)
10:                 Company:       Microchip Technology, Inc.
11:                
12:                 Software License Agreement:
13:                
14:                 The software supplied herewith by Microchip Technology Incorporated
15:                 (the "Company") for its PIC(R) Microcontroller is intended and
16:                 supplied to you, the Company's customer, for use solely and
17:                 exclusively on Microchip PIC Microcontroller products. The
18:                 software is owned by the Company and/or its supplier, and is
19:                 protected under applicable copyright laws. All rights are reserved.
20:                 Any use in violation of the foregoing restrictions may subject the
21:                 user to criminal sanctions under applicable laws, as well as to
22:                 civil liability for the breach of the terms and conditions of this
23:                 license.
24:                
25:                 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
26:                 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:                 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:                 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:                 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:                 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:                
32:                ********************************************************************
33:                 File Description:
34:                
35:                 Change History:
36:                  Rev   Description
37:                  ----  -----------------------------------------
38:                  1.0   Initial release
39:                
40:                  2.1   Updated for simplicity and to use common
41:                        coding style
42:                
43:                  2.6a  Added button debouncing using Start-of-Frame packets
44:                
45:                  2.7   Updated demo to place the PIC24F devices into sleep when the
46:                        USB is in suspend.  
47:                
48:                  2.7b  Improvements to USBCBSendResume(), to make it easier to use.
49:                  2.9f  Adding new part support
50:                ********************************************************************/
51:                
52:                /** INCLUDES *******************************************************/
53:                #include <xc.h>
54:                
55:                #include "./USB/usb.h"
56:                #include "./USB/usb_function_cdc.h"
57:                
58:                #include "Config.h"
59:                #include "HardwareProfile.h"
60:                
61:                
62:                /** I N C L U D E S **********************************************************/
63:                
64:                #include "GenericTypeDefs.h"
65:                #include "Compiler.h"
66:                #include "usb_config.h"
67:                #include "USB/usb_device.h"
68:                #include "USB/usb.h"
69:                
70:                #include <libpic30.h>
71:                
72:                
73:                /** V A R I A B L E S ********************************************************/
74:                #if defined(__18CXX)
75:                    #pragma udata
76:                #endif
77:                
78:                char USB_In_Buffer[64];
79:                char USB_Out_Buffer[64];
80:                
81:                BOOL stringPrinted;
82:                volatile BOOL buttonPressed;
83:                volatile BYTE buttonCount;
84:                
85:                /** P R I V A T E  P R O T O T Y P E S ***************************************/
86:                static void InitializeSystem(void);
87:                void ProcessIO(void);
88:                void USBDeviceTasks(void);
89:                void YourHighPriorityISRCode();
90:                void YourLowPriorityISRCode();
91:                void USBCBSendResume(void);
92:                void BlinkUSBStatus(void);
93:                void UserInit(void);
94:                
95:                /** VECTOR REMAPPING ***********************************************/
96:                #if defined(__C30__) || defined __XC16__
97:                    #if defined(PROGRAMMABLE_WITH_USB_HID_BOOTLOADER)
98:                        /*
99:                         *	ISR JUMP TABLE
100:                        *
101:                        *	It is necessary to define jump table as a function because C30 will
102:                        *	not store 24-bit wide values in program memory as variables.
103:                        *
104:                        *	This function should be stored at an address where the goto instructions 
105:                        *	line up with the remapped vectors from the bootloader's linker script.
106:                        *  
107:                        *  For more information about how to remap the interrupt vectors,
108:                        *  please refer to AN1157.  An example is provided below for the T2
109:                        *  interrupt with a bootloader ending at address 0x1400
110:                        */
111:               //        void __attribute__ ((address(0x1404))) ISRTable(){
112:               //        
113:               //        	asm("reset"); //reset instruction to prevent runaway code
114:               //        	asm("goto %0"::"i"(&_T2Interrupt));  //T2Interrupt's address
115:               //        }
116:                   #endif
117:               #endif
118:               
119:               
120:               
121:               
122:               /** DECLARATIONS ***************************************************/
123:               #if defined(__18CXX)
124:                   #pragma code
125:               #endif
126:               
127:               /******************************************************************************
128:                * Function:        void main(void)
129:                *
130:                * PreCondition:    None
131:                *
132:                * Input:           None
133:                *
134:                * Output:          None
135:                *
136:                * Side Effects:    None
137:                *
138:                * Overview:        Main program entry point.
139:                *
140:                * Note:            None
141:                *****************************************************************************/
142:               int main(void)
143:               {   
00138E  FA0000     LNK #0x0
144:               	InitializeSystem();
001390  07FFB3     RCALL _InitializeSystem
145:               
146:               	while(1)
147:                   {
148:               /*
149:               		#if defined(USB_INTERRUPT)
150:                           if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
151:                           {
152:                               USBDeviceAttach();
153:                           }
154:                       #endif
155:               
156:                       #if defined(USB_POLLING)
157:               		// Check bus status and service USB interrupts.
158:                       USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
159:                       				  // this function periodically.  This function will take care
160:                       				  // of processing and responding to SETUP transactions 
161:                       				  // (such as during the enumeration process when you first
162:                       				  // plug in).  USB hosts require that USB devices should accept
163:                       				  // and process SETUP packets in a timely fashion.  Therefore,
164:                       				  // when using polling, this function should be called 
165:                       				  // regularly (such as once every 1.8ms or faster** [see 
166:                       				  // inline code comments in usb_device.c for explanation when
167:                       				  // "or faster" applies])  In most cases, the USBDeviceTasks() 
168:                       				  // function does not take very long to execute (ex: <100 
169:                       				  // instruction cycles) before it returns.
170:                       #endif
171:                   				  
172:               
173:               		// Application-specific tasks.
174:               		// Application related code may be added here, or in the ProcessIO() function.
175:                       ProcessIO();
176:               */
177:               
178:               		// test
179:               		//__delay_ms(500);
180:               //		BIT_TOGGLE(LATB, 9);
181:               		 mLED_1_Toggle();
001392  AA0E15     BTG 0xE15, #0
182:               		 mLED_1_Toggle();
001394  AA0E15     BTG 0xE15, #0
183:               		 mLED_1_Toggle();
001396  AA0E15     BTG 0xE15, #0
184:               		 mLED_1_Toggle();
001398  AA0E15     BTG 0xE15, #0
00139A  37FFFB     BRA 0x1392
185:               //		__builtin_btg((unsigned int *)&LATB, 8);
186:               
187:               
188:               
189:               		// end test
190:               
191:               	}//end while
192:               }//end main
193:               
194:               
195:               /********************************************************************
196:                * Function:        static void InitializeSystem(void)
197:                *
198:                * PreCondition:    None
199:                *
200:                * Input:           None
201:                *
202:                * Output:          None
203:                *
204:                * Side Effects:    None
205:                *
206:                * Overview:        InitializeSystem is a centralize initialization
207:                *                  routine. All required USB initialization routines
208:                *                  are called from here.
209:                *
210:                *                  User application initialization routine should
211:                *                  also be called from here.                  
212:                *
213:                * Note:            None
214:                *******************************************************************/
215:               static void InitializeSystem(void)
216:               {
0012F8  FA0000     LNK #0x0
217:               	// All i/o's as digital
218:               
219:               	ANSELB = 0x0000;
0012FA  EF2E1E     CLR ANSELB
220:               	ANSELC = 0x0000;
0012FC  EF2E2E     CLR ANSELC
221:               	ANSELD = 0x0000;
0012FE  EF2E3E     CLR ANSELD
222:               	ANSELE = 0x0000;
001300  EF2E4E     CLR ANSELE
223:               	ANSELG = 0x0000;
001302  EF2E6E     CLR ANSELG
224:               
225:               	// The dsPIC33EP256MU806 features Peripheral Pin select.
226:               	// The following statements map UART2 to device pins which would connect to the the RX232 transciever.
227:               
228:               	RPINR19 = 38;				// assign UART2 Receive to the RPI38 pin
001304  200261     MOV #0x26, W1
001306  883631     MOV W1, RPINR19
229:               	RPINR19 = 39;				// assign UART2 Clear-to-Send to the RPI39 pin
001308  200270     MOV #0x27, W0
00130A  883630     MOV W0, RPINR19
230:               	RPOR9bits.RP100R = 0x04;	// RP100 tied to UART2 Ready-to-Send
00130C  803492     MOV RPOR9, W2
00130E  2FFC00     MOV #0xFFC0, W0
001310  610000     AND W2, W0, W0
001312  A02000     BSET W0, #2
001314  883490     MOV W0, RPOR9
231:               	RPOR9bits.RP101R = 0x03;	// RP101 tied to UART2 transmit
001316  803492     MOV RPOR9, W2
001318  2C0FF0     MOV #0xC0FF, W0
00131A  610000     AND W2, W0, W0
00131C  B33000     IOR #0x300, W0
00131E  883490     MOV W0, RPOR9
232:               
233:               	// Configure the device PLL to obtain 40 MIPS operation. The crystal
234:               	// frequency is 12MHz. Divide 12MHz by 3, multiply by 40 and divide by 2.
235:               	// This results in Fosc of 80MHz. The CPU clock frequency is
236:               	// Fcy = Fosc/2 = 40MHz. Wait for the Primary PLL to lock and then
237:               	// configure the auxilliary PLL to provide 48MHz needed for USB Operation.
238:               
239:               	PLLFBD = 38;				// M  = 40
001320  883A31     MOV W1, PLLFBD
240:               	CLKDIVbits.PLLPOST = 0;		// N2 = 2
001322  2FF3F0     MOV #0xFF3F, W0
001324  B62744     AND CLKDIV
241:               	CLKDIVbits.PLLPRE = 1;		// N1 = 3
001326  803A21     MOV CLKDIV, W1
001328  2FFE00     MOV #0xFFE0, W0
00132A  608000     AND W1, W0, W0
00132C  A00000     BSET W0, #0
00132E  883A20     MOV W0, CLKDIV
242:               	OSCTUN = 0;
001330  EF2748     CLR OSCTUN
243:               	CLKDIVbits.DOZEN = 0;		// processor clock = peripheral clock
001332  A96745     BCLR 0x745, #3
244:               
245:               	// Initiate Clock Switch to Primary Oscillator with PLL (NOSC= 0x3)
246:               	
247:               	__builtin_write_OSCCONH(0x03);
001334  2009A1     MOV #0x9A, W1
001336  200032     MOV #0x3, W2
001338  200780     MOV #0x78, W0
00133A  207433     MOV #0x743, W3
00133C  784980     MOV.B W0, [W3]
00133E  784981     MOV.B W1, [W3]
001340  784982     MOV.B W2, [W3]
248:               	__builtin_write_OSCCONL(0x01);
001342  200571     MOV #0x57, W1
001344  200012     MOV #0x1, W2
001346  200460     MOV #0x46, W0
001348  207423     MOV #0x742, W3
00134A  784980     MOV.B W0, [W3]
00134C  784981     MOV.B W1, [W3]
00134E  784982     MOV.B W2, [W3]
249:               	
250:               	while (OSCCONbits.COSC != 0x3);       // Wait for the Primary PLL to lock
001350  270001     MOV #0x7000, W1
001352  230000     MOV #0x3000, W0
001354  803A12     MOV OSCCON, W2
001356  610101     AND W2, W1, W2
001358  510F80     SUB W2, W0, [W15]
00135A  3AFFFC     BRA NZ, 0x1354
251:               
252:               	// Configuring the auxiliary PLL, since the primary
253:               	// oscillator provides the source clock to the auxiliary
254:               	// PLL, the auxiliary oscillator is disabled. Note that
255:               	// the AUX PLL is enabled. The input 12MHz clock is divided
256:               	// by 3, multiplied by 24 and then divided by 2.
257:               	// Wait till the AUX PLL locks.
258:               
259:               	ACLKCON3bits.AOSCMD = 0;			// Auxillary oscillator is disabled
00135C  2E7FF0     MOV #0xE7FF, W0
00135E  B62758     AND ACLKCON3
260:               	ACLKCON3bits.FRCSEL = 0;			// FRC is not APLL clock source
001360  A92759     BCLR 0x759, #1
261:               	ACLKCON3bits.ASRCSEL = 1;			// Primary oscillator is APLL clock source
001362  A84759     BSET 0x759, #2
262:               	ACLKCON3bits.APLLPRE = 2;			// APLL input divider = 3
001364  803AC1     MOV ACLKCON3, W1
001366  2FFF80     MOV #0xFFF8, W0
001368  608000     AND W1, W0, W0
00136A  A01000     BSET W0, #1
00136C  883AC0     MOV W0, ACLKCON3
263:               	ACLKCON3bits.APLLPOST = 6;			// APLL output divider = 2
00136E  803AC1     MOV ACLKCON3, W1
001370  2FF1F0     MOV #0xFF1F, W0
001372  608000     AND W1, W0, W0
001374  B30C00     IOR #0xC0, W0
001376  883AC0     MOV W0, ACLKCON3
264:               	ACLKCON3bits.SELACLK = 1;			// Primary PLL not as source for auxillary clock divider
001378  A8A759     BSET 0x759, #5
265:               	ACLKDIV3 = 0x7;						// APLL multiplier = 24
00137A  200070     MOV #0x7, W0
00137C  883AD0     MOV W0, ACLKDIV3
266:               	ACLKCON3bits.ENAPLL = 1;			// Enable APLL
00137E  A8E759     BSET 0x759, #7
267:               
268:               	while(ACLKCON3bits.APLLCK != 1);	// Wait till the AUX PLL locks.
001380  240000     MOV #0x4000, W0
001382  803AC1     MOV ACLKCON3, W1
001384  608080     AND W1, W0, W1
001386  32FFFD     BRA Z, 0x1382
269:               
270:               
271:               //	The USB specifications require that USB peripheral devices must never source
272:               //	current onto the Vbus pin.  Additionally, USB peripherals should not source
273:               //	current on D+ or D- when the host/hub is not actively powering the Vbus line.
274:               //	When designing a self powered (as opposed to bus powered) USB peripheral
275:               //	device, the firmware should make sure not to turn on the USB module and D+
276:               //	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
277:               //	firmware needs some means to detect when Vbus is being powered by the host.
278:               //	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
279:               // 	can be used to detect when Vbus is high (host actively powering), or low
280:               //	(host is shut down or otherwise not supplying power).  The USB firmware
281:               // 	can then periodically poll this I/O pin to know when it is okay to turn on
282:               //	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
283:               //	peripheral device, it is not possible to source current on D+ or D- when the
284:               //	host is not actively providing power on Vbus. Therefore, implementing this
285:               //	bus sense feature is optional.  This firmware can be made to use this bus
286:               //	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
287:               //	HardwareProfile.h file.    
288:               
289:               /*	#if defined(USE_USB_BUS_SENSE_IO)
290:                   tris_usb_bus_sense = INPUT_PIN; // See HardwareProfile.h
291:                   #endif
292:               */
293:               
294:               //	If the host PC sends a GetStatus (device) request, the firmware must respond
295:               //	and let the host know if the USB peripheral device is currently bus powered
296:               //	or self powered.  See chapter 9 in the official USB specifications for details
297:               //	regarding this request.  If the peripheral device is capable of being both
298:               //	self and bus powered, it should not return a hard coded value for this request.
299:               //	Instead, firmware should check if it is currently self or bus powered, and
300:               //	respond accordingly.  If the hardware has been configured like demonstrated
301:               //	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
302:               //	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" 
303:               //	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
304:               //	has been defined in HardwareProfile - (platform).h, and that an appropriate I/O pin 
305:               //  has been mapped	to it.
306:               
307:               /*	#if defined(USE_SELF_POWER_SENSE_IO)
308:               		tris_self_power = INPUT_PIN;	// See HardwareProfile.h
309:               	#endif
310:               */
311:               
312:               	UserInit();
001388  07FFB0     RCALL UserInit
313:               
314:               /*	USBDeviceInit();	//usb_device.c.  Initializes USB module SFRs and firmware
315:                   					//variables to known states.
316:               */
317:               }//end InitializeSystem
00138A  FA8000     ULNK
00138C  060000     RETURN
318:               
319:               
320:               
321:               /******************************************************************************
322:                * Function:        void UserInit(void)
323:                *
324:                * PreCondition:    None
325:                *
326:                * Input:           None
327:                *
328:                * Output:          None
329:                *
330:                * Side Effects:    None
331:                *
332:                * Overview:        This routine should take care of all of the demo code
333:                *                  initialization that is required.
334:                *
335:                * Note:            
336:                *
337:                *****************************************************************************/
338:               void UserInit(void)
339:               {
0012EA  FA0000     LNK #0x0
340:               	// Initialize all of the debouncing variables
341:               //	buttonCount = 0;
342:               //	buttonPressed = FALSE;
343:               //	stringPrinted = TRUE;
344:               
345:               	// Initialize all of the LED pins
346:               	mInitAllLEDs();
0012EC  2F0FF0     MOV #0xF0FF, W0
0012EE  B62E10     AND TRISB
347:               
348:               	//Initialize the pushbuttons
349:               	mInitAllSwitches();
0012F0  A80E30     BSET TRISD, #0
0012F2  A86E31     BSET 0xE31, #3
350:               }//end UserInit
0012F4  FA8000     ULNK
0012F6  060000     RETURN
351:               
352:               /********************************************************************
353:                * Function:        void ProcessIO(void)
354:                *
355:                * PreCondition:    None
356:                *
357:                * Input:           None
358:                *
359:                * Output:          None
360:                *
361:                * Side Effects:    None
362:                *
363:                * Overview:        This function is a place holder for other user
364:                *                  routines. It is a mixture of both USB and
365:                *                  non-USB tasks.
366:                *
367:                * Note:            None
368:                *******************************************************************/
369:               void ProcessIO(void)
370:               {   
00140E  FA0000     LNK #0x0
001410  781F88     MOV W8, [W15++]
371:                   BYTE numBytesRead;
372:               
373:                   //Blink the LEDs according to the USB device status
374:                   BlinkUSBStatus();
001412  07FFC4     RCALL BlinkUSBStatus
375:                   // User Application USB tasks
376:                   if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) return;
001414  8084D0     MOV USBDeviceState, W0
001416  500FFF     SUB W0, #0x1F, [W15]
001418  36002E     BRA LEU, 0x1476
00141A  AB2490     BTST U1PWRC, #1
00141C  3A002C     BRA NZ, 0x1476
377:               
378:                   if(buttonPressed)
00141E  808410     MOV buttonPressed, W0
001420  500FE0     SUB W0, #0x0, [W15]
001422  320008     BRA Z, 0x1434
379:                   {
380:                       if(stringPrinted == FALSE)
001424  808400     MOV stringPrinted, W0
001426  500FE0     SUB W0, #0x0, [W15]
001428  3A0006     BRA NZ, 0x1436
381:                       {
382:                           if(mUSBUSARTIsTxTrfReady())
00142A  BFD0DD     MOV.B cdc_trf_state, WREG
00142C  3A0004     BRA NZ, 0x1436
383:                           {
384:                               putrsUSBUSART("Button Pressed -- \r\n");
00142E  283B40     MOV #0x83B4, W0
001430  07FEF8     RCALL putrsUSBUSART
385:                               stringPrinted = TRUE;
001432  200010     MOV #0x1, W0
386:                           }
387:                       }
388:                   }
389:                   else
390:                   {
391:                       stringPrinted = FALSE;
001434  888400     MOV W0, stringPrinted
392:                   }
393:               
394:                   if(USBUSARTIsTxTrfReady())
001436  210DD8     MOV #0x10DD, W8
001438  784418     MOV.B [W8], W8
00143A  544FE0     SUB.B W8, #0x0, [W15]
00143C  3A001B     BRA NZ, 0x1474
395:                   {
396:               		numBytesRead = getsUSBUSART(USB_Out_Buffer,64);
00143E  B3C401     MOV #0x40, W1
001440  210400     MOV #0x1040, W0
001442  07FE9F     RCALL getsUSBUSART
397:               		if(numBytesRead != 0)
001444  504FE0     SUB.B W0, #0x0, [W15]
001446  320016     BRA Z, 0x1474
001448  784108     MOV.B W8, W2
398:               		{
399:               			BYTE i;
400:               	        
401:               			for(i=0;i<numBytesRead;i++)
001468  E84102     INC.B W2, W2
00146A  514F80     SUB.B W2, W0, [W15]
00146C  39FFF1     BRA NC, 0x1450
402:               			{
403:               				switch(USB_Out_Buffer[i])
00144A  210405     MOV #0x1040, W5
001450  FB8082     ZE W2, W1
001452  428181     ADD W5, W1, W3
001454  784193     MOV.B [W3], W3
001456  51CFEA     SUB.B W3, #0xA, [W15]
001458  320002     BRA Z, 0x145E
00145A  51CFED     SUB.B W3, #0xD, [W15]
00145C  3A0003     BRA NZ, 0x1464
404:               				{
405:               					case 0x0A:
406:               					case 0x0D:
407:               						USB_In_Buffer[i] = USB_Out_Buffer[i];
00144C  210004     MOV #0x1000, W4
00144E  37000D     BRA 0x146A
00145E  420081     ADD W4, W1, W1
001460  784883     MOV.B W3, [W1]
408:               						break;
001462  370002     BRA 0x1468
409:               					default:
410:               						USB_In_Buffer[i] = USB_Out_Buffer[i] + 1;
001464  420081     ADD W4, W1, W1
001466  E84883     INC.B W3, [W1]
411:               						break;
412:               				}
413:               
414:               			}
415:               
416:               			putUSBUSART(USB_In_Buffer,numBytesRead);
00146E  784080     MOV.B W0, W1
001470  210000     MOV #0x1000, W0
001472  07FEB0     RCALL putUSBUSART
417:               		}
418:               	}
419:               
420:                   CDCTxService();
001474  07FEEE     RCALL CDCTxService
421:               }		//end ProcessIO
001476  78044F     MOV [--W15], W8
001478  FA8000     ULNK
00147A  060000     RETURN
422:               
423:               
424:               /********************************************************************
425:                * Function:        void BlinkUSBStatus(void)
426:                *
427:                * PreCondition:    None
428:                *
429:                * Input:           None
430:                *
431:                * Output:          None
432:                *
433:                * Side Effects:    None
434:                *
435:                * Overview:        BlinkUSBStatus turns on and off LEDs 
436:                *                  corresponding to the USB device state.
437:                *
438:                * Note:            mLED macros can be found in HardwareProfile.h
439:                *                  USBDeviceState is declared and updated in
440:                *                  usb_device.c.
441:                *******************************************************************/
442:               void BlinkUSBStatus(void)
443:               {
00139C  FA0000     LNK #0x0
444:                   static WORD led_count=0;
445:                   
446:                   if(led_count == 0)led_count = 10000U;
00139E  808440     MOV led_count, W0
0013A0  500FE0     SUB W0, #0x0, [W15]
0013A2  3A0002     BRA NZ, 0x13A8
0013A4  227100     MOV #0x2710, W0
0013A6  888440     MOV W0, led_count
447:                   led_count--;
0013A8  ED1088     DEC led_count, WREG
0013AA  888440     MOV W0, led_count
448:               
449:                   #define mLED_Both_Off()         {mLED_1_Off();mLED_2_Off();}
450:                   #define mLED_Both_On()          {mLED_1_On();mLED_2_On();}
451:                   #define mLED_Only_1_On()        {mLED_1_On();mLED_2_Off();}
452:                   #define mLED_Only_2_On()        {mLED_1_Off();mLED_2_On();}
453:               
454:                   if(USBSuspendControl == 1)
0013AC  AB2490     BTST U1PWRC, #1
0013AE  320006     BRA Z, 0x13BC
455:                   {
456:                       if(led_count==0)
0013B0  500FE0     SUB W0, #0x0, [W15]
0013B2  3A002B     BRA NZ, 0x140A
457:                       {
458:                           mLED_1_Toggle();
0013B4  AA0E15     BTG 0xE15, #0
459:                           if(mGetLED_1())
0013B6  AB0E15     BTST 0xE15, #0
0013B8  3A0025     BRA NZ, 0x1404
0013BA  370026     BRA 0x1408
460:                           {
461:                               mLED_2_On();
462:                           }
463:                           else
464:                           {
465:                               mLED_2_Off();
466:                           }
467:                       }//end if
468:                   }
469:                   else
470:                   {
471:                       if(USBDeviceState == DETACHED_STATE)
0013BC  8084D1     MOV USBDeviceState, W1
0013BE  508FE0     SUB W1, #0x0, [W15]
0013C0  3A0002     BRA NZ, 0x13C6
472:                       {
473:                           mLED_Both_Off();
0013C2  A80E15     BSET 0xE15, #0
0013C4  37001F     BRA 0x1404
474:                       }
475:                       else if(USBDeviceState == ATTACHED_STATE)
0013C6  8084D1     MOV USBDeviceState, W1
0013C8  508FE1     SUB W1, #0x1, [W15]
0013CA  3A0002     BRA NZ, 0x13D0
476:                       {
477:                           mLED_Both_On();
0013CC  A90E15     BCLR 0xE15, #0
0013CE  37001C     BRA 0x1408
478:                       }
479:                       else if(USBDeviceState == POWERED_STATE)
0013D0  8084D1     MOV USBDeviceState, W1
0013D2  508FE2     SUB W1, #0x2, [W15]
0013D4  3A0002     BRA NZ, 0x13DA
480:                       {
481:                           mLED_Only_1_On();
0013D6  A90E15     BCLR 0xE15, #0
0013D8  370015     BRA 0x1404
482:                       }
483:                       else if(USBDeviceState == DEFAULT_STATE)
0013DA  8084D1     MOV USBDeviceState, W1
0013DC  508FE4     SUB W1, #0x4, [W15]
0013DE  3A0002     BRA NZ, 0x13E4
484:                       {
485:                           mLED_Only_2_On();
0013E0  A80E15     BSET 0xE15, #0
0013E2  370012     BRA 0x1408
486:                       }
487:                       else if(USBDeviceState == ADDRESS_STATE)
0013E4  8084D1     MOV USBDeviceState, W1
0013E6  508FF0     SUB W1, #0x10, [W15]
0013E8  3A0004     BRA NZ, 0x13F2
488:                       {
489:                           if(led_count == 0)
0013EA  500FE0     SUB W0, #0x0, [W15]
0013EC  3A000E     BRA NZ, 0x140A
490:                           {
491:                               mLED_1_Toggle();
0013EE  AA0E15     BTG 0xE15, #0
0013F0  370009     BRA 0x1404
492:                               mLED_2_Off();
493:                           }//end if
494:                       }
495:                       else if(USBDeviceState == CONFIGURED_STATE)
0013F2  8084D2     MOV USBDeviceState, W2
0013F4  200201     MOV #0x20, W1
0013F6  510F81     SUB W2, W1, [W15]
0013F8  3A0008     BRA NZ, 0x140A
496:                       {
497:                           if(led_count==0)
0013FA  500FE0     SUB W0, #0x0, [W15]
0013FC  3A0006     BRA NZ, 0x140A
498:                           {
499:                               mLED_1_Toggle();
0013FE  AA0E15     BTG 0xE15, #0
500:                               if(mGetLED_1())
001400  AB0E15     BTST 0xE15, #0
001402  3A0002     BRA NZ, 0x1408
501:                               {
502:                                   mLED_2_Off();
001404  A82E15     BSET 0xE15, #1
001406  370001     BRA 0x140A
503:                               }
504:                               else
505:                               {
506:                                   mLED_2_On();
001408  A92E15     BCLR 0xE15, #1
507:                               }
508:                           }//end if
509:                       }//end if(...)
510:                   }//end if(UCONbits.SUSPND...)
511:               
512:               }//end BlinkUSBStatus
00140A  FA8000     ULNK
00140C  060000     RETURN
513:               
514:               
515:               
516:               
517:               // ******************************************************************************************************
518:               // ************** USB Callback Functions ****************************************************************
519:               // ******************************************************************************************************
520:               // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
521:               // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
522:               // packets to your device.  In response to this, all USB devices are supposed to decrease their power
523:               // consumption from the USB Vbus to <2.5mA* each.  The USB module detects this condition (which according
524:               // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
525:               // function.  You should modify these callback functions to take appropriate actions for each of these
526:               // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
527:               // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
528:               // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
529:               // add code that undoes the power saving things done in the USBCBSuspend() function.
530:               
531:               // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
532:               // function.  This function is meant to be called from the application firmware instead.  See the
533:               // additional comments near the function.
534:               
535:               // Note *: The "usb_20.pdf" specs indicate 500uA or 2.5mA, depending upon device classification. However,
536:               // the USB-IF has officially issued an ECN (engineering change notice) changing this to 2.5mA for all 
537:               // devices.  Make sure to re-download the latest specifications to get all of the newest ECNs.
538:               
539:               /******************************************************************************
540:                * Function:        void USBCBSuspend(void)
541:                *
542:                * PreCondition:    None
543:                *
544:                * Input:           None
545:                *
546:                * Output:          None
547:                *
548:                * Side Effects:    None
549:                *
550:                * Overview:        Call back that is invoked when a USB suspend is detected
551:                *
552:                * Note:            None
553:                *****************************************************************************/
554:               void USBCBSuspend(void)
555:               {
00147C  FA0000     LNK #0x0
556:               	//Example power saving code.  Insert appropriate code here for the desired
557:               	//application behavior.  If the microcontroller will be put to sleep, a
558:               	//process similar to that shown below may be used:
559:               	
560:               	//ConfigureIOPinsForLowPower();
561:               	//SaveStateOfAllInterruptEnableBits();
562:               	//DisableAllInterruptEnableBits();
563:               	//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();	//should enable at least USBActivityIF as a wake source
564:               	//Sleep();
565:               	//RestoreStateOfAllPreviouslySavedInterruptEnableBits();	//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
566:               	//RestoreIOPinsToNormal();									//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
567:               
568:               	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
569:               	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
570:               	//things to not work as intended.	
571:               	
572:               
573:                   #if defined(__C30__) || defined __XC16__
574:                       USBSleepOnSuspend();
00147E  070058     RCALL USBSleepOnSuspend
575:                   #endif
576:               }
001480  FA8000     ULNK
001482  060000     RETURN
577:               
578:               /******************************************************************************
579:                * Function:        void USBCBWakeFromSuspend(void)
580:                *
581:                * PreCondition:    None
582:                *
583:                * Input:           None
584:                *
585:                * Output:          None
586:                *
587:                * Side Effects:    None
588:                *
589:                * Overview:        The host may put USB peripheral devices in low power
590:                *					suspend mode (by "sending" 3+ms of idle).  Once in suspend
591:                *					mode, the host may wake the device back up by sending non-
592:                *					idle state signalling.
593:                *					
594:                *					This call back is invoked when a wakeup from USB suspend 
595:                *					is detected.
596:                *
597:                * Note:            None
598:                *****************************************************************************/
599:               void USBCBWakeFromSuspend(void)
600:               {
001484  FA0000     LNK #0x0
601:               	// If clock switching or other power savings measures were taken when
602:               	// executing the USBCBSuspend() function, now would be a good time to
603:               	// switch back to normal full power run mode conditions.  The host allows
604:               	// 10+ milliseconds of wakeup time, after which the device must be 
605:               	// fully back to normal, and capable of receiving and processing USB
606:               	// packets.  In order to do this, the USB module must receive proper
607:               	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
608:               	// operation).  
609:               	// Make sure the selected oscillator settings are consistent with USB 
610:                   // operation before returning from this function.
611:               }
001486  FA8000     ULNK
001488  060000     RETURN
612:               
613:               /********************************************************************
614:                * Function:        void USBCB_SOF_Handler(void)
615:                *
616:                * PreCondition:    None
617:                *
618:                * Input:           None
619:                *
620:                * Output:          None
621:                *
622:                * Side Effects:    None
623:                *
624:                * Overview:        The USB host sends out a SOF packet to full-speed
625:                *                  devices every 1 ms. This interrupt may be useful
626:                *                  for isochronous pipes. End designers should
627:                *                  implement callback routine as necessary.
628:                *
629:                * Note:            None
630:                *******************************************************************/
631:               void USBCB_SOF_Handler(void)
632:               {
00148A  FA0000     LNK #0x0
633:                   // No need to clear UIRbits.SOFIF to 0 here.
634:                   // Callback caller is already doing that.
635:               
636:                   //This is reverse logic since the pushbutton is active low
637:                   if(buttonPressed == sw2)
00148C  808411     MOV buttonPressed, W1
00148E  807190     MOV PORTD, W0
001490  600061     AND W0, #0x1, W0
001492  508F80     SUB W1, W0, [W15]
001494  3A0009     BRA NZ, 0x14A8
638:                   {
639:                       if(buttonCount != 0)
001496  BFD084     MOV.B buttonCount, WREG
001498  3A0009     BRA NZ, 0x14AC
640:                       {
641:                           buttonCount--;
642:                       }
643:                       else
644:                       {
645:                           //This is reverse logic since the pushbutton is active low
646:                           buttonPressed = !sw2;
00149A  807190     MOV PORTD, W0
00149C  600061     AND W0, #0x1, W0
00149E  A20000     BTG W0, #0
0014A0  888410     MOV W0, buttonPressed
647:               
648:                           //Wait 100ms before the next press can be generated
649:                           buttonCount = 100;
0014A2  B3C640     MOV #0x64, W0
0014A4  B7F084     MOV.B WREG, buttonCount
0014A6  370003     BRA 0x14AE
650:                       }
651:                   }
652:                   else
653:                   {
654:                       if(buttonCount != 0)
0014A8  BFD084     MOV.B buttonCount, WREG
0014AA  320001     BRA Z, 0x14AE
655:                       {
656:                           buttonCount--;
0014AC  ED7084     DEC.B buttonCount
657:                       }
658:                   }
659:               }
0014AE  FA8000     ULNK
0014B0  060000     RETURN
660:               
661:               /*******************************************************************
662:                * Function:        void USBCBErrorHandler(void)
663:                *
664:                * PreCondition:    None
665:                *
666:                * Input:           None
667:                *
668:                * Output:          None
669:                *
670:                * Side Effects:    None
671:                *
672:                * Overview:        The purpose of this callback is mainly for
673:                *                  debugging during development. Check UEIR to see
674:                *                  which error causes the interrupt.
675:                *
676:                * Note:            None
677:                *******************************************************************/
678:               void USBCBErrorHandler(void)
679:               {
0014B2  FA0000     LNK #0x0
680:                   // No need to clear UEIR to 0 here.
681:                   // Callback caller is already doing that.
682:               
683:               	// Typically, user firmware does not need to do anything special
684:               	// if a USB error occurs.  For example, if the host sends an OUT
685:               	// packet to your device, but the packet gets corrupted (ex:
686:               	// because of a bad connection, or the user unplugs the
687:               	// USB cable during the transmission) this will typically set
688:               	// one or more USB error interrupt flags.  Nothing specific
689:               	// needs to be done however, since the SIE will automatically
690:               	// send a "NAK" packet to the host.  In response to this, the
691:               	// host will normally retry to send the packet again, and no
692:               	// data loss occurs.  The system will typically recover
693:               	// automatically, without the need for application firmware
694:               	// intervention.
695:               	
696:               	// Nevertheless, this callback function is provided, such as
697:               	// for debugging purposes.
698:               }
0014B4  FA8000     ULNK
0014B6  060000     RETURN
699:               
700:               
701:               /*******************************************************************
702:                * Function:        void USBCBCheckOtherReq(void)
703:                *
704:                * PreCondition:    None
705:                *
706:                * Input:           None
707:                *
708:                * Output:          None
709:                *
710:                * Side Effects:    None
711:                *
712:                * Overview:        When SETUP packets arrive from the host, some
713:                * 					firmware must process the request and respond
714:                *					appropriately to fulfill the request.  Some of
715:                *					the SETUP packets will be for standard
716:                *					USB "chapter 9" (as in, fulfilling chapter 9 of
717:                *					the official USB specifications) requests, while
718:                *					others may be specific to the USB device class
719:                *					that is being implemented.  For example, a HID
720:                *					class device needs to be able to respond to
721:                *					"GET REPORT" type of requests.  This
722:                *					is not a standard USB chapter 9 request, and 
723:                *					therefore not handled by usb_device.c.  Instead
724:                *					this request should be handled by class specific 
725:                *					firmware, such as that contained in usb_function_hid.c.
726:                *
727:                * Note:            None
728:                *******************************************************************/
729:               void USBCBCheckOtherReq(void)
730:               {
0014B8  FA0000     LNK #0x0
731:                   USBCheckCDCRequest();
0014BA  07FDD9     RCALL USBCheckCDCRequest
732:               }//end
0014BC  FA8000     ULNK
0014BE  060000     RETURN
733:               
734:               
735:               /*******************************************************************
736:                * Function:        void USBCBStdSetDscHandler(void)
737:                *
738:                * PreCondition:    None
739:                *
740:                * Input:           None
741:                *
742:                * Output:          None
743:                *
744:                * Side Effects:    None
745:                *
746:                * Overview:        The USBCBStdSetDscHandler() callback function is
747:                *					called when a SETUP, bRequest: SET_DESCRIPTOR request
748:                *					arrives.  Typically SET_DESCRIPTOR requests are
749:                *					not used in most applications, and it is
750:                *					optional to support this type of request.
751:                *
752:                * Note:            None
753:                *******************************************************************/
754:               void USBCBStdSetDscHandler(void)
755:               {
0014C0  FA0000     LNK #0x0
756:                   // Must claim session ownership if supporting this request
757:               }//end
0014C2  FA8000     ULNK
0014C4  060000     RETURN
758:               
759:               
760:               /*******************************************************************
761:                * Function:        void USBCBInitEP(void)
762:                *
763:                * PreCondition:    None
764:                *
765:                * Input:           None
766:                *
767:                * Output:          None
768:                *
769:                * Side Effects:    None
770:                *
771:                * Overview:        This function is called when the device becomes
772:                *                  initialized, which occurs after the host sends a
773:                * 					SET_CONFIGURATION (wValue not = 0) request.  This 
774:                *					callback function should initialize the endpoints 
775:                *					for the device's usage according to the current 
776:                *					configuration.
777:                *
778:                * Note:            None
779:                *******************************************************************/
780:               void USBCBInitEP(void)
781:               {
0014C6  FA0000     LNK #0x0
782:                   //Enable the CDC data endpoints
783:                   CDCInitEP();
0014C8  07FE23     RCALL CDCInitEP
784:               }
0014CA  FA8000     ULNK
0014CC  060000     RETURN
785:               
786:               /********************************************************************
787:                * Function:        void USBCBSendResume(void)
788:                *
789:                * PreCondition:    None
790:                *
791:                * Input:           None
792:                *
793:                * Output:          None
794:                *
795:                * Side Effects:    None
796:                *
797:                * Overview:        The USB specifications allow some types of USB
798:                * 					peripheral devices to wake up a host PC (such
799:                *					as if it is in a low power suspend to RAM state).
800:                *					This can be a very useful feature in some
801:                *					USB applications, such as an Infrared remote
802:                *					control	receiver.  If a user presses the "power"
803:                *					button on a remote control, it is nice that the
804:                *					IR receiver can detect this signalling, and then
805:                *					send a USB "command" to the PC to wake up.
806:                *					
807:                *					The USBCBSendResume() "callback" function is used
808:                *					to send this special USB signalling which wakes 
809:                *					up the PC.  This function may be called by
810:                *					application firmware to wake up the PC.  This
811:                *					function will only be able to wake up the host if
812:                *                  all of the below are true:
813:                *					
814:                *					1.  The USB driver used on the host PC supports
815:                *						the remote wakeup capability.
816:                *					2.  The USB configuration descriptor indicates
817:                *						the device is remote wakeup capable in the
818:                *						bmAttributes field.
819:                *					3.  The USB host PC is currently sleeping,
820:                *						and has previously sent your device a SET 
821:                *						FEATURE setup packet which "armed" the
822:                *						remote wakeup capability.   
823:                *
824:                *                  If the host has not armed the device to perform remote wakeup,
825:                *                  then this function will return without actually performing a
826:                *                  remote wakeup sequence.  This is the required behavior, 
827:                *                  as a USB device that has not been armed to perform remote 
828:                *                  wakeup must not drive remote wakeup signalling onto the bus;
829:                *                  doing so will cause USB compliance testing failure.
830:                *                  
831:                *					This callback should send a RESUME signal that
832:                *                  has the period of 1-15ms.
833:                *
834:                * Note:            This function does nothing and returns quickly, if the USB
835:                *                  bus and host are not in a suspended condition, or are 
836:                *                  otherwise not in a remote wakeup ready state.  Therefore, it
837:                *                  is safe to optionally call this function regularly, ex: 
838:                *                  anytime application stimulus occurs, as the function will
839:                *                  have no effect, until the bus really is in a state ready
840:                *                  to accept remote wakeup. 
841:                *
842:                *                  When this function executes, it may perform clock switching,
843:                *                  depending upon the application specific code in 
844:                *                  USBCBWakeFromSuspend().  This is needed, since the USB
845:                *                  bus will no longer be suspended by the time this function
846:                *                  returns.  Therefore, the USB module will need to be ready
847:                *                  to receive traffic from the host.
848:                *
849:                *                  The modifiable section in this routine may be changed
850:                *                  to meet the application needs. Current implementation
851:                *                  temporary blocks other functions from executing for a
852:                *                  period of ~3-15 ms depending on the core frequency.
853:                *
854:                *                  According to USB 2.0 specification section 7.1.7.7,
855:                *                  "The remote wakeup device must hold the resume signaling
856:                *                  for at least 1 ms but for no more than 15 ms."
857:                *                  The idea here is to use a delay counter loop, using a
858:                *                  common value that would work over a wide range of core
859:                *                  frequencies.
860:                *                  That value selected is 1800. See table below:
861:                *                  ==========================================================
862:                *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
863:                *                  ==========================================================
864:                *                      48              12          1.05
865:                *                       4              1           12.6
866:                *                  ==========================================================
867:                *                  * These timing could be incorrect when using code
868:                *                    optimization or extended instruction mode,
869:                *                    or when having other interrupts enabled.
870:                *                    Make sure to verify using the MPLAB SIM's Stopwatch
871:                *                    and verify the actual signal on an oscilloscope.
872:                *******************************************************************/
873:               void USBCBSendResume(void)
874:               {
0014CE  FA0000     LNK #0x0
875:                   static WORD delay_count;
876:                   
877:                   //First verify that the host has armed us to perform remote wakeup.
878:                   //It does this by sending a SET_FEATURE request to enable remote wakeup,
879:                   //usually just before the host goes to standby mode (note: it will only
880:                   //send this SET_FEATURE request if the configuration descriptor declares
881:                   //the device as remote wakeup capable, AND, if the feature is enabled
882:                   //on the host (ex: on Windows based hosts, in the device manager 
883:                   //properties page for the USB device, power management tab, the 
884:                   //"Allow this device to bring the computer out of standby." checkbox 
885:                   //should be checked).
886:                   if(USBGetRemoteWakeupStatus() == TRUE) 
0014D0  8084B0     MOV RemoteWakeup, W0
0014D2  500FE1     SUB W0, #0x1, [W15]
0014D4  3A0013     BRA NZ, 0x14FC
887:                   {
888:                       //Verify that the USB bus is in fact suspended, before we send
889:                       //remote wakeup signalling.
890:                       if(USBIsBusSuspended() == TRUE)
0014D6  8084C0     MOV USBBusIsSuspended, W0
0014D8  500FE1     SUB W0, #0x1, [W15]
0014DA  3A0010     BRA NZ, 0x14FC
891:                       {
892:                           USBMaskInterrupts();
0014DC  A9C82A     BCLR IEC5, #6
893:                           
894:                           //Clock switch to settings consistent with normal USB operation.
895:                           USBCBWakeFromSuspend();
896:                           USBSuspendControl = 0; 
0014DE  A92490     BCLR U1PWRC, #1
897:                           USBBusIsSuspended = FALSE;  //So we don't execute this code again, 
0014E0  EF3098     CLR USBBusIsSuspended
898:                                                       //until a new suspend condition is detected.
899:               
900:                           //Section 7.1.7.7 of the USB 2.0 specifications indicates a USB
901:                           //device must continuously see 5ms+ of idle on the bus, before it sends
902:                           //remote wakeup signalling.  One way to be certain that this parameter
903:                           //gets met, is to add a 2ms+ blocking delay here (2ms plus at 
904:                           //least 3ms from bus idle to USBIsBusSuspended() == TRUE, yeilds
905:                           //5ms+ total delay since start of idle).
906:                           delay_count = 3600U;        
0014E2  20E100     MOV #0xE10, W0
0014E4  888430     MOV W0, delay_count
907:                           do
908:                           {
909:                               delay_count--;
0014E6  ED1086     DEC delay_count, WREG
0014E8  888430     MOV W0, delay_count
910:                           }while(delay_count);
0014EA  3AFFFD     BRA NZ, 0x14E6
911:                           
912:                           //Now drive the resume K-state signalling onto the USB bus.
913:                           USBResumeControl = 1;       // Start RESUME signaling
0014EC  A844CA     BSET U1CON, #2
914:                           delay_count = 1800U;        // Set RESUME line for 1-13 ms
0014EE  207080     MOV #0x708, W0
0014F0  888430     MOV W0, delay_count
915:                           do
916:                           {
917:                               delay_count--;
0014F2  ED1086     DEC delay_count, WREG
0014F4  888430     MOV W0, delay_count
918:                           }while(delay_count);
0014F6  3AFFFD     BRA NZ, 0x14F2
919:                           USBResumeControl = 0;       //Finished driving resume signalling
0014F8  A944CA     BCLR U1CON, #2
920:               
921:                           USBUnmaskInterrupts();
0014FA  A8C82A     BSET IEC5, #6
922:                       }
923:                   }
924:               }
0014FC  FA8000     ULNK
0014FE  060000     RETURN
925:               
926:               
927:               /*******************************************************************
928:                * Function:        void USBCBEP0DataReceived(void)
929:                *
930:                * PreCondition:    ENABLE_EP0_DATA_RECEIVED_CALLBACK must be
931:                *                  defined already (in usb_config.h)
932:                *
933:                * Input:           None
934:                *
935:                * Output:          None
936:                *
937:                * Side Effects:    None
938:                *
939:                * Overview:        This function is called whenever a EP0 data
940:                *                  packet is received.  This gives the user (and
941:                *                  thus the various class examples a way to get
942:                *                  data that is received via the control endpoint.
943:                *                  This function needs to be used in conjunction
944:                *                  with the USBCBCheckOtherReq() function since 
945:                *                  the USBCBCheckOtherReq() function is the apps
946:                *                  method for getting the initial control transfer
947:                *                  before the data arrives.
948:                *
949:                * Note:            None
950:                *******************************************************************/
951:               #if defined(ENABLE_EP0_DATA_RECEIVED_CALLBACK)
952:               void USBCBEP0DataReceived(void)
953:               {
954:               }
955:               #endif
956:               
957:               /*******************************************************************
958:                * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
959:                *                        int event, void *pdata, WORD size)
960:                *
961:                * PreCondition:    None
962:                *
963:                * Input:           int event - the type of event
964:                *                  void *pdata - pointer to the event data
965:                *                  WORD size - size of the event data
966:                *
967:                * Output:          None
968:                *
969:                * Side Effects:    None
970:                *
971:                * Overview:        This function is called from the USB stack to
972:                *                  notify a user application that a USB event
973:                *                  occured.  This callback is in interrupt context
974:                *                  when the USB_INTERRUPT option is selected.
975:                *
976:                * Note:            None
977:                *******************************************************************/
978:               BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size)
979:               {
001500  FA0000     LNK #0x0
980:                   switch( event )
001502  500FE3     SUB W0, #0x3, [W15]
001504  320011     BRA Z, 0x1528
001506  3C0003     BRA GT, 0x150E
001508  500FE1     SUB W0, #0x1, [W15]
00150A  3A000F     BRA NZ, 0x152A
00150C  37000B     BRA 0x1524
00150E  200731     MOV #0x73, W1
001510  500F81     SUB W0, W1, [W15]
001512  320004     BRA Z, 0x151C
001514  E88081     INC2 W1, W1
001516  500F81     SUB W0, W1, [W15]
001518  3A0008     BRA NZ, 0x152A
00151A  370002     BRA 0x1520
981:                   {
982:                       case EVENT_TRANSFER:
983:                           //Add application specific callback task or callback function here if desired.
984:                           break;
985:                       case EVENT_SOF:
986:                           USBCB_SOF_Handler();
00151C  07FFB6     RCALL USBCB_SOF_Handler
987:                           break;
00151E  370005     BRA 0x152A
988:                       case EVENT_SUSPEND:
989:                           USBCBSuspend();
001520  07FFAD     RCALL USBCBSuspend
990:                           break;
001522  370003     BRA 0x152A
991:                       case EVENT_RESUME:
992:                           USBCBWakeFromSuspend();
993:                           break;
994:                       case EVENT_CONFIGURED: 
995:                           USBCBInitEP();
001524  07FFD0     RCALL USBCBInitEP
996:                           break;
001526  370001     BRA 0x152A
997:                       case EVENT_SET_DESCRIPTOR:
998:                           USBCBStdSetDscHandler();
999:                           break;
1000:                      case EVENT_EP0_REQUEST:
1001:                          USBCBCheckOtherReq();
001528  07FFC7     RCALL USBCBCheckOtherReq
1002:                          break;
1003:                      case EVENT_BUS_ERROR:
1004:                          USBCBErrorHandler();
1005:                          break;
1006:                      case EVENT_TRANSFER_TERMINATED:
1007:                          //Add application specific callback task or callback function here if desired.
1008:                          //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
1009:                          //FEATURE (endpoint halt) request on an application endpoint which was 
1010:                          //previously armed (UOWN was = 1).  Here would be a good place to:
1011:                          //1.  Determine which endpoint the transaction that just got terminated was 
1012:                          //      on, by checking the handle value in the *pdata.
1013:                          //2.  Re-arm the endpoint if desired (typically would be the case for OUT 
1014:                          //      endpoints).
1015:                          break;
1016:                      default:
1017:                          break;
1018:                  }      
1019:                  return TRUE; 
1020:              }
00152A  200010     MOV #0x1, W0
00152C  FA8000     ULNK
00152E  060000     RETURN
1021:              
1022:              
1023:              /** EOF main.c *************************************************/
1024:              
---  C:/Files/Ontwerp/WFS220_WiFi_scope/WFS220.X/Source Files/USB/usb_hal_dspic33e.c  -------------------
1:                 /******************************************************************************
2:                 
3:                     USB Hardware Abstraction Layer (HAL)
4:                 
5:                 Summary:
6:                     This file abstracts the hardware interface.  The USB stack firmware can be
7:                     compiled to work on different USB microcontrollers, such as PIC18 and PIC24.
8:                     The USB related special function registers and bit names are generally very
9:                     similar between the device families, but small differences in naming exist.
10:                
11:                Description:
12:                    This file abstracts the hardware interface.  The USB stack firmware can be
13:                    compiled to work on different USB microcontrollers, such as PIC18 and PIC24.
14:                    The USB related special function registers and bit names are generally very
15:                    similar between the device families, but small differences in naming exist.
16:                    
17:                    In order to make the same set of firmware work accross the device families,
18:                    when modifying SFR contents, a slightly abstracted name is used, which is
19:                    then "mapped" to the appropriate real name in the usb_hal_picxx.h header.
20:                    
21:                    Make sure to include the correct version of the usb_hal_picxx.h file for 
22:                    the microcontroller family which will be used.
23:                
24:                    This file is located in the "\<Install Directory\>\\Microchip\\Include\\USB"
25:                    directory.
26:                    
27:                    When including this file in a new project, this file can either be
28:                    referenced from the directory in which it was installed or copied
29:                    directly into the user application folder. If the first method is
30:                    chosen to keep the file located in the folder in which it is installed
31:                    then include paths need to be added so that the library and the
32:                    application both know where to reference each others files. If the
33:                    application folder is located in the same folder as the Microchip
34:                    folder (like the current demo folders), then the following include
35:                    paths need to be added to the application's project:
36:                    
37:                    .
38:                
39:                    ..\\..\\Microchip\\Include
40:                        
41:                    If a different directory structure is used, modify the paths as
42:                    required. An example using absolute paths instead of relative paths
43:                    would be the following:
44:                    
45:                    C:\\Microchip Solutions\\Microchip\\Include
46:                    
47:                    C:\\Microchip Solutions\\My Demo Application 
48:                
49:                
50:                *******************************************************************************/
51:                //DOM-IGNORE-BEGIN
52:                /******************************************************************************
53:                
54:                 File Description:
55:                
56:                 This file defines the interface to the USB hardware abstraction layer.
57:                
58:                 Filename:        usb_hal_pic33E.c
59:                 Dependancies:    none
60:                 Processor:       dsPIC33E USB Microcontrollers
61:                 Hardware:        dsPIC33E USB Microcontrollers
62:                 Compiler:        Microchip C30 (for PIC24)
63:                 Company:         Microchip Technology, Inc.
64:                
65:                 Software License Agreement:
66:                
67:                 The software supplied herewith by Microchip Technology Incorporated
68:                 (the "Company") for its PICmicro(R) Microcontroller is intended and
69:                 supplied to you, the Company's customer, for use solely and
70:                 exclusively on Microchip PICmicro Microcontroller products. The
71:                 software is owned by the Company and/or its supplier, and is
72:                 protected under applicable copyright laws. All rights are reserved.
73:                 Any use in violation of the foregoing restrictions may subject the
74:                 user to criminal sanctions under applicable laws, as well as to
75:                 civil liability for the breach of the terms and conditions of this
76:                 license.
77:                
78:                 THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
79:                 WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
80:                 TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
81:                 PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
82:                 IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
83:                 CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
84:                
85:                 *************************************************************************/
86:                
87:                
88:                #ifndef USB_HAL_DSPIC33E_C
89:                #define USB_HAL_DSPIC33E_C
90:                
91:                #include "USB/usb.h"
92:                
93:                
94:                /********************************************************************
95:                Function:
96:                    BOOL USBSleepOnSuspend(void)
97:                    
98:                Summary:
99:                    Places the core into sleep and sets up the USB module
100:                   to wake up the device on USB activity.
101:                   
102:               PreCondition:
103:                   IPL (in the SR register) must be non-zero.
104:                   
105:               Parameters:
106:                   None
107:                   
108:               Return Values:
109:                   TRUE  - if entered sleep successfully
110:                   FALSE - if there was an error entering sleep
111:                   
112:               Remarks:
113:                   Please note that before calling this function that it is the
114:                   responsibility of the application to place all of the other
115:                   peripherals or board features into a lower power state if
116:                   required.
117:               
118:               *******************************************************************/
119:               BOOL USBSleepOnSuspend(void)
120:               {
001530  FA0000     LNK #0x0
121:                   unsigned int U1EIE_save, U1IE_save, U1OTGIE_save;
122:                   unsigned char USB1IE_save;
123:               
124:                   #if defined(USB_POLLING)
125:                       //If IPL is equal to 0 then there is no way for the USB module to
126:                       //  generate an interrupt to wake up the device.  
127:                       if(_IPL == 0)
128:                       {
129:                           return FALSE;
130:                       }
131:               
132:                       //Set the interrupt priority to a level that will wake up the part (>0)
133:                       //  but will not cause a interrupt vector jump (USB1IP<=IPL)
134:                       _USB1IP = 1;
135:                   #endif 
136:               
137:                   //Save the old interrupt and CPU settings
138:                   U1EIE_save = U1EIE;
001532  802634     MOV U1EIE, W4
139:                   U1IE_save = U1IE;
001534  802613     MOV U1IE, W3
140:                   U1OTGIE_save = U1OTGIE;
001536  802452     MOV U1OTGIE, W2
141:                   USB1IE_save = IEC5bits.USB1IE;
001538  804150     MOV IEC5, W0
00153A  DE0046     LSR W0, #6, W0
00153C  604061     AND.B W0, #0x1, W0
142:               
143:                   //Disable all USB interrupts
144:                   U1EIE = 0;
00153E  EB0080     CLR W1
001540  882631     MOV W1, U1EIE
145:                   U1IE = 0;
001542  882611     MOV W1, U1IE
146:                   U1OTGIE = 0; 
001544  882451     MOV W1, U1OTGIE
147:               
148:                   //Enable the interrupt
149:                   IFS5bits.USB1IF = 0;
001546  A9C80A     BCLR IFS5, #6
150:                   U1OTGIEbits.ACTVIE = 1;
001548  A8848A     BSET U1OTGIE, #4
151:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
00154A  200101     MOV #0x10, W1
00154C  882441     MOV W1, U1OTGIR
152:                   IEC5bits.USB1IE = 1;
00154E  A8C82A     BSET IEC5, #6
153:               
154:                   Sleep();
001550  FE4000     PWRSAV #0
155:               
156:                   #if defined(USB_POLLING)
157:                       //Disable the interrupt
158:                       _USB1IP = 0;
159:                   #endif  
160:               
161:                   //restore the previous interrupt settings
162:                   IEC5bits.USB1IE = USB1IE_save;
001552  6000E1     AND W0, #0x1, W1
001554  DD08C6     SL W1, #6, W1
001556  804150     MOV IEC5, W0
001558  A16000     BCLR W0, #6
00155A  700001     IOR W0, W1, W0
00155C  884150     MOV W0, IEC5
163:                   U1EIE = U1EIE_save;
00155E  882634     MOV W4, U1EIE
164:                   U1IE = U1IE_save;
001560  882613     MOV W3, U1IE
165:                   U1OTGIE = U1OTGIE_save;
001562  882452     MOV W2, U1OTGIE
166:               
167:                   return TRUE;
168:               }
001564  200010     MOV #0x1, W0
001566  FA8000     ULNK
001568  060000     RETURN
169:               
170:               #endif //USB_HAL_DSPIC33E_C
171:               
---  C:/Files/Ontwerp/WFS220_WiFi_scope/WFS220.X/Source Files/USB/usb_function_cdc.c  -------------------
1:                 /********************************************************************************
2:                   File Information:
3:                     FileName:       usb_function_cdc.c
4:                     Dependencies:   See INCLUDES section
5:                     Processor:      PIC18 or PIC24 USB Microcontrollers
6:                     Hardware:       The code is natively intended to be used on the following
7:                                     hardware platforms: PICDEM(TM) FS USB Demo Board,
8:                                     PIC18F87J50 FS USB Plug-In Module, or
9:                                     Explorer 16 + PIC24 USB PIM.  The firmware may be
10:                                    modified for use on other USB platforms by editing the
11:                                    HardwareProfile.h file.
12:                    Complier:   Microchip C18 (for PIC18) or C30 (for PIC24)
13:                    Company:        Microchip Technology, Inc.
14:                
15:                    Software License Agreement:
16:                
17:                    The software supplied herewith by Microchip Technology Incorporated
18:                    (the "Company") for its PIC(R) Microcontroller is intended and
19:                    supplied to you, the Company's customer, for use solely and
20:                    exclusively on Microchip PIC Microcontroller products. The
21:                    software is owned by the Company and/or its supplier, and is
22:                    protected under applicable copyright laws. All rights are reserved.
23:                    Any use in violation of the foregoing restrictions may subject the
24:                    user to criminal sanctions under applicable laws, as well as to
25:                    civil liability for the breach of the terms and conditions of this
26:                    license.
27:                
28:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                    
35:                  Summary:
36:                    This file contains all of functions, macros, definitions, variables,
37:                    datatypes, etc. that are required for usage with the CDC function
38:                    driver. This file should be included in projects that use the CDC
39:                    \function driver.
40:                    
41:                    
42:                    
43:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
44:                    Device Driver" directory.
45:                  Description:
46:                    USB CDC Function Driver File
47:                    
48:                    This file contains all of functions, macros, definitions, variables,
49:                    datatypes, etc. that are required for usage with the CDC function
50:                    driver. This file should be included in projects that use the CDC
51:                    \function driver.
52:                    
53:                    This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
54:                    Device Driver" directory.
55:                    
56:                    When including this file in a new project, this file can either be
57:                    referenced from the directory in which it was installed or copied
58:                    directly into the user application folder. If the first method is
59:                    chosen to keep the file located in the folder in which it is installed
60:                    then include paths need to be added so that the library and the
61:                    application both know where to reference each others files. If the
62:                    application folder is located in the same folder as the Microchip
63:                    folder (like the current demo folders), then the following include
64:                    paths need to be added to the application's project:
65:                    
66:                    ..\\Include
67:                    
68:                    .
69:                    
70:                    If a different directory structure is used, modify the paths as
71:                    required. An example using absolute paths instead of relative paths
72:                    would be the following:
73:                    
74:                    C:\\Microchip Solutions\\Microchip\\Include
75:                    
76:                    C:\\Microchip Solutions\\My Demo Application                                 
77:                  ********************************************************************************/
78:                
79:                /********************************************************************
80:                 Change History:
81:                  Rev    Description
82:                  ----   -----------
83:                  2.3    Decricated the mUSBUSARTIsTxTrfReady() macro.  It is 
84:                         replaced by the USBUSARTIsTxTrfReady() function.
85:                
86:                  2.6    Minor definition changes
87:                
88:                  2.6a   No Changes
89:                
90:                  2.7    Fixed error in the part support list of the variables section
91:                         where the address of the CDC variables are defined.  The 
92:                         PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
93:                         was incorrectly named PIC18F4458.
94:                
95:                         http://www.microchip.com/forums/fb.aspx?m=487397
96:                
97:                  2.8    Minor change to CDCInitEP() to enhance ruggedness in
98:                         multithreaded usage scenarios.
99:                  
100:                 2.9b   Updated to implement optional support for DTS reporting.
101:               
102:               ********************************************************************/
103:               
104:               /** I N C L U D E S **********************************************************/
105:               #include "USB/usb.h"
106:               #include "USB/usb_function_cdc.h"
107:               #include "HardwareProfile.h"
108:               
109:               #ifdef USB_USE_CDC
110:               
111:               /** V A R I A B L E S ********************************************************/
112:               #if defined(__18CXX)
113:                   //The cdc_data_rx[] and cdc_data_tx[] arrays and associated variables are used 
114:                   //as USB packet buffers in this firmware.  Therefore, they must be located in
115:                   //a USB module accessible portion of microcontroller RAM.
116:                   #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50) 
117:                       #pragma udata usbram2
118:                   #elif defined(__18F2455) || defined(__18F2550) || defined(__18F4455) || defined(__18F4550)\
119:                       || defined(__18F2458) || defined(__18F2553) || defined(__18F4458) || defined(__18F4553)\
120:                       || defined(__18LF24K50) || defined(__18F24K50) || defined(__18LF25K50)\
121:                       || defined(__18F25K50) || defined(__18LF45K50) || defined(__18F45K50)
122:                       #pragma udata USB_VARIABLES=0x500
123:                   #elif defined(__18F4450) || defined(__18F2450)
124:                       #pragma udata USB_VARIABLES=0x480
125:                   #else
126:                       #pragma udata
127:                   #endif
128:               #endif
129:               
130:               #if defined(__XC8)
131:                   #if defined(_18F14K50) || defined(_18F13K50) || defined(_18LF14K50) || defined(_18LF13K50)
132:                       #define IN_DATA_BUFFER_ADDRESS 0x260
133:                       #define OUT_DATA_BUFFER_ADDRESS (IN_DATA_BUFFER_ADDRESS + CDC_DATA_IN_EP_SIZE)
134:                       #define LINE_CODING_ADDRESS (OUT_DATA_BUFFER_ADDRESS + CDC_DATA_OUT_EP_SIZE)
135:                       #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
136:               
137:                       #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
138:                       #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
139:                       #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
140:                       #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
141:                   #elif  defined(_18F2455)   || defined(_18F2550)   || defined(_18F4455)  || defined(_18F4550)\
142:                       || defined(_18F2458)   || defined(_18F2453)   || defined(_18F4558)  || defined(_18F4553)\
143:                       || defined(_18LF24K50) || defined(_18F24K50)  || defined(_18LF25K50)\
144:                       || defined(_18F25K50)  || defined(_18LF45K50) || defined(_18F45K50)
145:                       #define IN_DATA_BUFFER_ADDRESS 0x500
146:                       #define OUT_DATA_BUFFER_ADDRESS (IN_DATA_BUFFER_ADDRESS + CDC_DATA_IN_EP_SIZE)
147:                       #define LINE_CODING_ADDRESS (OUT_DATA_BUFFER_ADDRESS + CDC_DATA_OUT_EP_SIZE)
148:                       #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
149:               
150:                       #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
151:                       #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
152:                       #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
153:                       #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
154:                   #elif defined(_18F4450) || defined(_18F2450)
155:                       #define IN_DATA_BUFFER_ADDRESS 0x480
156:                       #define OUT_DATA_BUFFER_ADDRESS (IN_DATA_BUFFER_ADDRESS + CDC_DATA_IN_EP_SIZE)
157:                       #define LINE_CODING_ADDRESS (OUT_DATA_BUFFER_ADDRESS + CDC_DATA_OUT_EP_SIZE)
158:                       #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
159:               
160:                       #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
161:                       #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
162:                       #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
163:                       #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
164:                   #elif defined(_16F1459) || defined(_16LF1459) || defined(_16F1454) || defined(_16LF1454) || defined(_16F1455) || defined(_16LF1455)
165:                       #define IN_DATA_BUFFER_ADDRESS 0x2140
166:                       #define OUT_DATA_BUFFER_ADDRESS 0x2190
167:                       #define LINE_CODING_ADDRESS 0x20A0
168:                       #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
169:               
170:                       #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
171:                       #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
172:                       #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
173:                       #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
174:                   #else
175:                       #define IN_DATA_BUFFER_ADDRESS_TAG
176:                       #define OUT_DATA_BUFFER_ADDRESS_TAG
177:                       #define LINE_CODING_ADDRESS_TAG
178:                       #define NOTICE_ADDRESS_TAG
179:                   #endif
180:               #else
181:                   #define IN_DATA_BUFFER_ADDRESS_TAG
182:                   #define OUT_DATA_BUFFER_ADDRESS_TAG
183:                   #define LINE_CODING_ADDRESS_TAG
184:                   #define NOTICE_ADDRESS_TAG
185:               #endif
186:               
187:               volatile FAR unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;
188:               volatile FAR unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;
189:               
190:               LINE_CODING line_coding LINE_CODING_ADDRESS_TAG;    // Buffer to store line coding information
191:               volatile FAR CDC_NOTICE cdc_notice NOTICE_ADDRESS_TAG;
192:               
193:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
194:                   SERIAL_STATE_NOTIFICATION SerialStatePacket;
195:               #endif
196:               
197:               #if defined(__18CXX)
198:                   #pragma udata
199:               #endif
200:               
201:               BYTE cdc_rx_len;            // total rx length
202:               
203:               BYTE cdc_trf_state;         // States are defined cdc.h
204:               POINTER pCDCSrc;            // Dedicated source pointer
205:               POINTER pCDCDst;            // Dedicated destination pointer
206:               BYTE cdc_tx_len;            // total tx length
207:               BYTE cdc_mem_type;          // _ROM, _RAM
208:               
209:               USB_HANDLE CDCDataOutHandle;
210:               USB_HANDLE CDCDataInHandle;
211:               
212:               
213:               CONTROL_SIGNAL_BITMAP control_signal_bitmap;
214:               DWORD BaudRateGen;			// BRG value calculated from baudrate
215:               
216:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
217:                   BM_SERIAL_STATE SerialStateBitmap;
218:                   BM_SERIAL_STATE OldSerialStateBitmap;
219:                   USB_HANDLE CDCNotificationInHandle;
220:               #endif
221:               
222:               /**************************************************************************
223:                 SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
224:                 requests according to the CDC specification.
225:                 However, it is not really being used here, therefore a dummy buffer is
226:                 used for conformance.
227:                **************************************************************************/
228:               #define dummy_length    0x08
229:               BYTE_VAL dummy_encapsulated_cmd_response[dummy_length];
230:               
231:               #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
232:               CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
233:               #endif
234:               
235:               /** P R I V A T E  P R O T O T Y P E S ***************************************/
236:               void USBCDCSetLineCoding(void);
237:               
238:               /** D E C L A R A T I O N S **************************************************/
239:               //#pragma code
240:               
241:               /** C L A S S  S P E C I F I C  R E Q ****************************************/
242:               /******************************************************************************
243:                	Function:
244:                		void USBCheckCDCRequest(void)
245:                
246:                	Description:
247:                		This routine checks the most recently received SETUP data packet to 
248:                		see if the request is specific to the CDC class.  If the request was
249:                		a CDC specific request, this function will take care of handling the
250:                		request and responding appropriately.
251:                		
252:                	PreCondition:
253:                		This function should only be called after a control transfer SETUP
254:                		packet has arrived from the host.
255:               
256:               	Parameters:
257:               		None
258:               		
259:               	Return Values:
260:               		None
261:               		
262:               	Remarks:
263:               		This function does not change status or do anything if the SETUP packet
264:               		did not contain a CDC class specific request.		 
265:                 *****************************************************************************/
266:               void USBCheckCDCRequest(void)
267:               {
00106E  FA0000     LNK #0x0
268:                   /*
269:                    * If request recipient is not an interface then return
270:                    */
271:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
001070  BFD0CC     MOV.B SetupPkt, WREG
001072  60407F     AND.B W0, #0x1F, W0
001074  504FE1     SUB.B W0, #0x1, [W15]
001076  3A004A     BRA NZ, 0x110C
272:               
273:                   /*
274:                    * If request type is not class-specific then return
275:                    */
276:                   if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
001078  210CC1     MOV #0x10CC, W1
00107A  784091     MOV.B [W1], W1
00107C  B24601     AND.B #0x60, W1
00107E  40407F     ADD.B W0, #0x1F, W0
001080  50CF80     SUB.B W1, W0, [W15]
001082  3A0044     BRA NZ, 0x110C
277:               
278:                   /*
279:                    * Interface ID must match interface numbers associated with
280:                    * CDC class, else return
281:                    */
282:                   if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
001084  BFD0D0     MOV.B 0x10D0, WREG
001086  320003     BRA Z, 0x108E
00108A  504FE1     SUB.B W0, #0x1, [W15]
00108C  3A003F     BRA NZ, 0x110C
283:                      (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
001088  BFD0D0     MOV.B 0x10D0, WREG
284:                   
285:                   switch(SetupPkt.bRequest)
00108E  BFD0CD     MOV.B 0x10CD, WREG
001090  B3C201     MOV #0x20, W1
001092  504F81     SUB.B W0, W1, [W15]
001094  320016     BRA Z, 0x10C2
001096  3E0005     BRA GTU, 0x10A2
001098  504FE0     SUB.B W0, #0x0, [W15]
00109A  32000A     BRA Z, 0x10B0
00109C  504FE1     SUB.B W0, #0x1, [W15]
00109E  3A0036     BRA NZ, 0x110C
0010A0  37000D     BRA 0x10BC
0010A2  B3C211     MOV #0x21, W1
0010A4  504F81     SUB.B W0, W1, [W15]
0010A6  320028     BRA Z, 0x10F8
0010A8  E84081     INC.B W1, W1
0010AA  504F81     SUB.B W0, W1, [W15]
0010AC  3A002F     BRA NZ, 0x110C
0010AE  37002B     BRA 0x1106
286:                   {
287:                       //****** These commands are required ******//
288:                       case SEND_ENCAPSULATED_COMMAND:
289:                        //send the packet
290:                           inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
0010B0  210F60     MOV #0x10F6, W0
0010B2  888480     MOV W0, inPipes
291:                           inPipes[0].wCount.Val = dummy_length;
0010B4  200080     MOV #0x8, W0
0010B6  8884A0     MOV W0, 0x1094
292:                           inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
0010B8  A81092     BSET 0x1092, #0
0010BA  370027     BRA 0x110A
293:                           inPipes[0].info.bits.busy = 1;
294:                           break;
295:                       case GET_ENCAPSULATED_RESPONSE:
296:                           // Populate dummy_encapsulated_cmd_response first.
297:                           inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
0010BC  210F60     MOV #0x10F6, W0
0010BE  888480     MOV W0, inPipes
0010C0  370024     BRA 0x110A
298:                           inPipes[0].info.bits.busy = 1;
299:                           break;
300:                       //****** End of required commands ******//
301:               
302:                       #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
303:                       case SET_LINE_CODING:
304:                           outPipes[0].wCount.Val = SetupPkt.wLength;
0010C2  BFD0D2     MOV.B 0x10D2, WREG
0010C4  FB8000     ZE W0, W0
0010C6  210D31     MOV #0x10D3, W1
0010C8  784091     MOV.B [W1], W1
0010CA  DD08C8     SL W1, #8, W1
0010CC  708000     IOR W1, W0, W0
0010CE  210A71     MOV #0x10A7, W1
0010D0  784091     MOV.B [W1], W1
0010D2  B7F0A7     MOV.B WREG, 0x10A7
0010D4  DE0048     LSR W0, #8, W0
0010D6  210A81     MOV #0x10A8, W1
0010D8  784091     MOV.B [W1], W1
0010DA  B7F0A8     MOV.B WREG, 0x10A8
305:                           outPipes[0].pDst.bRam = (BYTE*)LINE_CODING_TARGET;
0010DC  210E20     MOV #0x10E2, W0
0010DE  210A41     MOV #0x10A4, W1
0010E0  784091     MOV.B [W1], W1
0010E2  B7F0A4     MOV.B WREG, outPipes
0010E4  DE0048     LSR W0, #8, W0
0010E6  210A51     MOV #0x10A5, W1
0010E8  784091     MOV.B [W1], W1
0010EA  B7F0A5     MOV.B WREG, 0x10A5
306:                           outPipes[0].pFunc = LINE_CODING_PFUNC;
0010EC  BFD0A9     MOV.B 0x10A9, WREG
0010EE  EF70A9     CLR.B 0x10A9
0010F0  BFD0AA     MOV.B 0x10AA, WREG
0010F2  EF70AA     CLR.B 0x10AA
307:                           outPipes[0].info.bits.busy = 1;
0010F4  A8F0A6     BSET 0x10A6, #7
308:                           break;
0010F6  37000A     BRA 0x110C
309:                           
310:                       case GET_LINE_CODING:
311:                           USBEP0SendRAMPtr(
0010F8  210E20     MOV #0x10E2, W0
0010FA  888480     MOV W0, inPipes
0010FC  200070     MOV #0x7, W0
0010FE  8884A0     MOV W0, 0x1094
001100  B3CC10     MOV #0xC1, W0
001102  B7F092     MOV.B WREG, 0x1092
312:                               (BYTE*)&line_coding,
313:                               LINE_CODING_LENGTH,
314:                               USB_EP0_INCLUDE_ZERO);
315:                           break;
001104  370003     BRA 0x110C
316:               
317:                       case SET_CONTROL_LINE_STATE:
318:                           control_signal_bitmap._byte = (BYTE)SetupPkt.W_Value.v[0];
001106  BFD0CE     MOV.B 0x10CE, WREG
001108  B7F0F0     MOV.B WREG, control_signal_bitmap
319:                           //------------------------------------------------------------------            
320:                           //One way to control the RTS pin is to allow the USB host to decide the value
321:                           //that should be output on the RTS pin.  Although RTS and CTS pin functions
322:                           //are technically intended for UART hardware based flow control, some legacy
323:                           //UART devices use the RTS pin like a "general purpose" output pin 
324:                           //from the PC host.  In this usage model, the RTS pin is not related
325:                           //to flow control for RX/TX.
326:                           //In this scenario, the USB host would want to be able to control the RTS
327:                           //pin, and the below line of code should be uncommented.
328:                           //However, if the intention is to implement true RTS/CTS flow control
329:                           //for the RX/TX pair, then this application firmware should override
330:                           //the USB host's setting for RTS, and instead generate a real RTS signal,
331:                           //based on the amount of remaining buffer space available for the 
332:                           //actual hardware UART of this microcontroller.  In this case, the 
333:                           //below code should be left commented out, but instead RTS should be 
334:                           //controlled in the application firmware reponsible for operating the 
335:                           //hardware UART of this microcontroller.
336:                           //---------            
337:                           //CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);  
338:                           //------------------------------------------------------------------            
339:                           
340:                           #if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
341:                               if(control_signal_bitmap.DTE_PRESENT == 1)
342:                               {
343:                                   UART_DTR = USB_CDC_DTR_ACTIVE_LEVEL;
344:                               }
345:                               else
346:                               {
347:                                   UART_DTR = (USB_CDC_DTR_ACTIVE_LEVEL ^ 1);
348:                               }        
349:                           #endif
350:                           inPipes[0].info.bits.busy = 1;
00110A  A8F092     BSET 0x1092, #7
351:                           break;
352:                       #endif
353:               
354:                       #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
355:                       case SEND_BREAK:                        // Optional
356:                           inPipes[0].info.bits.busy = 1;
357:               			if (SetupPkt.wValue == 0xFFFF)  //0xFFFF means send break indefinitely until a new SEND_BREAK command is received
358:               			{
359:               				UART_Tx = 0;       // Prepare to drive TX low (for break signalling)
360:               				UART_TRISTx = 0;   // Make sure TX pin configured as an output
361:               				UART_ENABLE = 0;   // Turn off USART (to relinquish TX pin control)
362:               			}
363:               			else if (SetupPkt.wValue == 0x0000) //0x0000 means stop sending indefinite break 
364:               			{
365:                   			UART_ENABLE = 1;   // turn on USART
366:               				UART_TRISTx = 1;   // Make TX pin an input
367:               			}
368:               			else
369:               			{
370:                               //Send break signalling on the pin for (SetupPkt.wValue) milliseconds
371:                               UART_SEND_BREAK();
372:               			}
373:                           break;
374:                       #endif
375:                       default:
376:                           break;
377:                   }//end switch(SetupPkt.bRequest)
378:               
379:               }//end USBCheckCDCRequest
00110C  FA8000     ULNK
00110E  060000     RETURN
380:               
381:               /** U S E R  A P I ***********************************************************/
382:               
383:               /**************************************************************************
384:                 Function:
385:                       void CDCInitEP(void)
386:                   
387:                 Summary:
388:                   This function initializes the CDC function driver. This function should
389:                   be called after the SET_CONFIGURATION command (ex: within the context of
390:                   the USBCBInitEP() function).
391:                 Description:
392:                   This function initializes the CDC function driver. This function sets
393:                   the default line coding (baud rate, bit parity, number of data bits,
394:                   and format). This function also enables the endpoints and prepares for
395:                   the first transfer from the host.
396:                   
397:                   This function should be called after the SET_CONFIGURATION command.
398:                   This is most simply done by calling this function from the
399:                   USBCBInitEP() function.
400:                   
401:                   Typical Usage:
402:                   <code>
403:                       void USBCBInitEP(void)
404:                       {
405:                           CDCInitEP();
406:                       }
407:                   </code>
408:                 Conditions:
409:                   None
410:                 Remarks:
411:                   None                                                                   
412:                 **************************************************************************/
413:               void CDCInitEP(void)
414:               {
001110  FA0000     LNK #0x0
001112  781F88     MOV W8, [W15++]
415:                  	//Abstract line coding information
416:                  	line_coding.dwDTERate.Val = 19200;      // baud rate
001114  24B000     MOV #0x4B00, W0
001116  888710     MOV W0, line_coding
001118  EF30E4     CLR 0x10E4
417:                  	line_coding.bCharFormat = 0x00;             // 1 stop bit
00111A  EB4400     CLR.B W8
00111C  FD0400     EXCH W0, W8
00111E  B7F0E6     MOV.B WREG, 0x10E6
001120  B7F0E7     MOV.B WREG, 0x10E7
001122  FD0400     EXCH W0, W8
418:                  	line_coding.bParityType = 0x00;             // None
419:                  	line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
001124  B3C080     MOV #0x8, W0
001126  B7F0E8     MOV.B WREG, 0x10E8
420:               
421:                   cdc_rx_len = 0;
001128  780008     MOV W8, W0
00112A  B7F0DC     MOV.B WREG, cdc_rx_len
422:                   
423:                   /*
424:                    * Do not have to init Cnt of IN pipes here.
425:                    * Reason:  Number of BYTEs to send to the host
426:                    *          varies from one transaction to
427:                    *          another. Cnt should equal the exact
428:                    *          number of BYTEs to transmit for
429:                    *          a given IN transaction.
430:                    *          This number of BYTEs will only
431:                    *          be known right before the data is
432:                    *          sent.
433:                    */
434:                   USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
00112C  B3C151     MOV #0x15, W1
00112E  B3C010     MOV #0x1, W0
001130  07FBED     RCALL USBEnableEndpoint
435:                   USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
001132  B3C1D1     MOV #0x1D, W1
001134  B3C020     MOV #0x2, W0
001136  07FBEA     RCALL USBEnableEndpoint
436:               
437:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
001138  B3C403     MOV #0x40, W3
00113A  211482     MOV #0x1148, W2
00113C  784088     MOV.B W8, W1
00113E  B3C020     MOV #0x2, W0
001140  07FBFE     RCALL USBTransferOnePacket
001142  888760     MOV W0, CDCDataOutHandle
438:                   CDCDataInHandle = NULL;
001144  EB0000     CLR W0
001146  888770     MOV W0, CDCDataInHandle
439:               
440:                   #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
441:                     	CDCNotificationInHandle = NULL;
442:                       mInitDTSPin();  //Configure DTS as a digital input
443:                     	SerialStateBitmap.byte = 0x00;
444:                     	OldSerialStateBitmap.byte = !SerialStateBitmap.byte;    //To force firmware to send an initial serial state packet to the host.
445:                       //Prepare a SerialState notification element packet (contains info like DSR state)
446:                       SerialStatePacket.bmRequestType = 0xA1; //Always 0xA1 for this type of packet.
447:                       SerialStatePacket.bNotification = SERIAL_STATE;
448:                       SerialStatePacket.wValue = 0x0000;  //Always 0x0000 for this type of packet
449:                       SerialStatePacket.wIndex = CDC_COMM_INTF_ID;  //Interface number  
450:                       SerialStatePacket.SerialState.byte = 0x00;
451:                       SerialStatePacket.Reserved = 0x00;
452:                       SerialStatePacket.wLength = 0x02;   //Always 2 bytes for this type of packet    
453:                       CDCNotificationHandler();
454:                 	#endif
455:                 	
456:                 	#if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
457:                 	    mInitDTRPin();
458:                 	#endif
459:                 	
460:                 	#if defined(USB_CDC_SUPPORT_HARDWARE_FLOW_CONTROL)
461:                 	    mInitRTSPin();
462:                 	    mInitCTSPin();
463:                 	#endif
464:                   
465:                   cdc_trf_state = CDC_TX_READY;
001148  B7F0DD     MOV.B WREG, cdc_trf_state
466:               }//end CDCInitEP
00114A  78044F     MOV [--W15], W8
00114C  FA8000     ULNK
00114E  060000     RETURN
467:               
468:               
469:               /**************************************************************************
470:                 Function: void CDCNotificationHandler(void)
471:                 Summary: Checks for changes in DSR status and reports them to the USB host.
472:                 Description: Checks for changes in DSR pin state and reports any changes
473:                              to the USB host. 
474:                 Conditions: CDCInitEP() must have been called previously, prior to calling
475:                             CDCNotificationHandler() for the first time.
476:                 Remarks:
477:                   This function is only implemented and needed when the 
478:                   USB_CDC_SUPPORT_DSR_REPORTING option has been enabled.  If the function is
479:                   enabled, it should be called periodically to sample the DSR pin and feed
480:                   the information to the USB host.  This can be done by calling 
481:                   CDCNotificationHandler() by itself, or, by calling CDCTxService() which
482:                   also calls CDCNotificationHandler() internally, when appropriate.
483:                 **************************************************************************/
484:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
485:               void CDCNotificationHandler(void)
486:               {
487:                   //Check the DTS I/O pin and if a state change is detected, notify the 
488:                   //USB host by sending a serial state notification element packet.
489:                   if(UART_DTS == USB_CDC_DSR_ACTIVE_LEVEL) //UART_DTS must be defined to be an I/O pin in the hardware profile to use the DTS feature (ex: "PORTXbits.RXY")
490:                   {
491:                       SerialStateBitmap.bits.DSR = 1;
492:                   }  
493:                   else
494:                   {
495:                       SerialStateBitmap.bits.DSR = 0;
496:                   }        
497:                   
498:                   //If the state has changed, and the endpoint is available, send a packet to
499:                   //notify the hUSB host of the change.
500:                   if((SerialStateBitmap.byte != OldSerialStateBitmap.byte) && (!USBHandleBusy(CDCNotificationInHandle)))
501:                   {
502:                       //Copy the updated value into the USB packet buffer to send.
503:                       SerialStatePacket.SerialState.byte = SerialStateBitmap.byte;
504:                       //We don't need to write to the other bytes in the SerialStatePacket USB
505:                       //buffer, since they don't change and will always be the same as our
506:                       //initialized value.
507:               
508:                       //Send the packet over USB to the host.
509:                       CDCNotificationInHandle = USBTransferOnePacket(CDC_COMM_EP, IN_TO_HOST, (BYTE*)&SerialStatePacket, sizeof(SERIAL_STATE_NOTIFICATION));
510:                       
511:                       //Save the old value, so we can detect changes later.
512:                       OldSerialStateBitmap.byte = SerialStateBitmap.byte;
513:                   }    
514:               }//void CDCNotificationHandler(void)    
515:               #else
516:                   #define CDCNotificationHandler() {}
517:               #endif
518:               
519:               
520:               /**********************************************************************************
521:                 Function:
522:                   BOOL USBCDCEventHandler(USB_EVENT event, void *pdata, WORD size)
523:                   
524:                 Summary:
525:                   Handles events from the USB stack, which may have an effect on the CDC 
526:                   endpoint(s).
527:               
528:                 Description:
529:                   Handles events from the USB stack.  This function should be called when 
530:                   there is a USB event that needs to be processed by the CDC driver.
531:                   
532:                 Conditions:
533:                   Value of input argument 'len' should be smaller than the maximum
534:                   endpoint size responsible for receiving bulk data from USB host for CDC
535:                   class. Input argument 'buffer' should point to a buffer area that is
536:                   bigger or equal to the size specified by 'len'.
537:                 Input:
538:                   event - the type of event that occured
539:                   pdata - pointer to the data that caused the event
540:                   size - the size of the data that is pointed to by pdata
541:                                                                                                  
542:                 **********************************************************************************/
543:               BOOL USBCDCEventHandler(USB_EVENT event, void *pdata, WORD size)
544:               {
001150  FA0000     LNK #0x0
001152  781F88     MOV W8, [W15++]
001154  780401     MOV W1, W8
545:                   switch( (INT)event )
001156  500FE5     SUB W0, #0x5, [W15]
001158  3A0010     BRA NZ, 0x117A
546:                   {  
547:                       case EVENT_TRANSFER_TERMINATED:
548:                           if(pdata == CDCDataOutHandle)
00115A  808760     MOV CDCDataOutHandle, W0
00115C  540F80     SUB W8, W0, [W15]
00115E  3A0006     BRA NZ, 0x116C
549:                           {
550:                               CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));  
001160  B3C403     MOV #0x40, W3
001162  211482     MOV #0x1148, W2
001164  EB4080     CLR.B W1
001166  B3C020     MOV #0x2, W0
001168  07FBEA     RCALL USBTransferOnePacket
00116A  888760     MOV W0, CDCDataOutHandle
551:                           }
552:                           if(pdata == CDCDataInHandle)
00116E  808771     MOV CDCDataInHandle, W1
001170  540F81     SUB W8, W1, [W15]
001172  3A0004     BRA NZ, 0x117C
553:                           {
554:                               //flush all of the data in the CDC buffer
555:                               cdc_trf_state = CDC_TX_READY;
001174  EF70DD     CLR.B cdc_trf_state
556:                               cdc_tx_len = 0;
001176  EF70E0     CLR.B cdc_tx_len
001178  370001     BRA 0x117C
557:                           }
558:                           break;
559:                       default:
560:                           return FALSE;
00117A  EB0000     CLR W0
561:                   }      
562:                   return TRUE; 
00116C  200010     MOV #0x1, W0
563:               }
00117C  78044F     MOV [--W15], W8
00117E  FA8000     ULNK
001180  060000     RETURN
564:               
565:               /**********************************************************************************
566:                 Function:
567:                       BYTE getsUSBUSART(char *buffer, BYTE len)
568:                   
569:                 Summary:
570:                   getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
571:                   endpoint to a user's specified location. It is a non-blocking function.
572:                   It does not wait for data if there is no data available. Instead it
573:                   returns '0' to notify the caller that there is no data available.
574:               
575:                 Description:
576:                   getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
577:                   endpoint to a user's specified location. It is a non-blocking function.
578:                   It does not wait for data if there is no data available. Instead it
579:                   returns '0' to notify the caller that there is no data available.
580:                   
581:                   Typical Usage:
582:                   <code>
583:                       BYTE numBytes;
584:                       BYTE buffer[64]
585:                   
586:                       numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
587:                       if(numBytes \> 0)
588:                       {
589:                           //we received numBytes bytes of data and they are copied into
590:                           //  the "buffer" variable.  We can do something with the data
591:                           //  here.
592:                       }
593:                   </code>
594:                 Conditions:
595:                   Value of input argument 'len' should be smaller than the maximum
596:                   endpoint size responsible for receiving bulk data from USB host for CDC
597:                   class. Input argument 'buffer' should point to a buffer area that is
598:                   bigger or equal to the size specified by 'len'.
599:                 Input:
600:                   buffer -  Pointer to where received BYTEs are to be stored
601:                   len -     The number of BYTEs expected.
602:                                                                                                  
603:                 **********************************************************************************/
604:               BYTE getsUSBUSART(char *buffer, BYTE len)
605:               {
001182  FA0000     LNK #0x0
001184  780200     MOV W0, W4
606:                   cdc_rx_len = 0;
001186  EF70DC     CLR.B cdc_rx_len
607:                   
608:                   if(!USBHandleBusy(CDCDataOutHandle))
001188  808762     MOV CDCDataOutHandle, W2
00118A  510FE0     SUB W2, #0x0, [W15]
00118C  320003     BRA Z, 0x1194
00118E  EB4000     CLR.B W0
001190  104F92     SUBR.B W0, [W2], [W15]
001192  35001D     BRA LT, 0x11CE
609:                   {
610:                       /*
611:                        * Adjust the expected number of BYTEs to equal
612:                        * the actual number of BYTEs received.
613:                        */
614:                       if(len > USBHandleGetLength(CDCDataOutHandle))
001194  9041A2     MOV.B [W2+2], W3
001196  FB8183     ZE W3, W3
001198  904032     MOV.B [W2+3], W0
00119A  600063     AND W0, #0x3, W0
00119C  DD0048     SL W0, #8, W0
00119E  700183     IOR W0, W3, W3
0011A0  FB8001     ZE W1, W0
0011A2  500F83     SUB W0, W3, [W15]
0011A4  340009     BRA LE, 0x11B8
615:                           len = USBHandleGetLength(CDCDataOutHandle);
0011A6  9040A2     MOV.B [W2+2], W1
0011A8  904032     MOV.B [W2+3], W0
616:                       
617:                       /*
618:                        * Copy data from dual-ram buffer to user's buffer
619:                        */
620:                       for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
0011AA  370006     BRA 0x11B8
0011B4  EC70DC     INC.B cdc_rx_len
0011B6  370001     BRA 0x11BA
0011BA  210DC2     MOV #0x10DC, W2
0011BC  784112     MOV.B [W2], W2
0011BE  514F81     SUB.B W2, W1, [W15]
0011C0  39FFF5     BRA NC, 0x11AC
621:                           buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
0011AC  FB8102     ZE W2, W2
0011AE  418002     ADD W3, W2, W0
0011B0  420102     ADD W4, W2, W2
0011B2  784910     MOV.B [W0], [W2]
0011B8  211483     MOV #0x1148, W3
622:               
623:                       /*
624:                        * Prepare dual-ram buffer for next OUT transaction
625:                        */
626:               
627:                       CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
0011C2  B3C403     MOV #0x40, W3
0011C4  211482     MOV #0x1148, W2
0011C6  EB4080     CLR.B W1
0011C8  B3C020     MOV #0x2, W0
0011CA  07FBB9     RCALL USBTransferOnePacket
0011CC  888760     MOV W0, CDCDataOutHandle
628:               
629:                   }//end if
630:                   
631:                   return cdc_rx_len;
632:                   
633:               }//end getsUSBUSART
0011CE  BFD0DC     MOV.B cdc_rx_len, WREG
0011D0  FA8000     ULNK
0011D2  060000     RETURN
634:               
635:               /******************************************************************************
636:                 Function:
637:               	void putUSBUSART(char *data, BYTE length)
638:               		
639:                 Summary:
640:                   putUSBUSART writes an array of data to the USB. Use this version, is
641:                   capable of transfering 0x00 (what is typically a NULL character in any of
642:                   the string transfer functions).
643:               
644:                 Description:
645:                   putUSBUSART writes an array of data to the USB. Use this version, is
646:                   capable of transfering 0x00 (what is typically a NULL character in any of
647:                   the string transfer functions).
648:                   
649:                   Typical Usage:
650:                   <code>
651:                       if(USBUSARTIsTxTrfReady())
652:                       {
653:                           char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
654:                           putUSBUSART(data,5);
655:                       }
656:                   </code>
657:                   
658:                   The transfer mechanism for device-to-host(put) is more flexible than
659:                   host-to-device(get). It can handle a string of data larger than the
660:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
661:                   \long string of data over multiple USB transactions. CDCTxService()
662:                   must be called periodically to keep sending blocks of data to the host.
663:               
664:                 Conditions:
665:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
666:                   transfer is complete and is ready to receive a new block of data. The
667:                   string of characters pointed to by 'data' must equal to or smaller than
668:                   255 BYTEs.
669:               
670:                 Input:
671:                   char *data - pointer to a RAM array of data to be transfered to the host
672:                   BYTE length - the number of bytes to be transfered (must be less than 255).
673:               		
674:                *****************************************************************************/
675:               void putUSBUSART(char *data, BYTE  length)
676:               {
0011D4  FA0000     LNK #0x0
677:                   /*
678:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
679:                    * before calling this function.
680:                    * As a safety precaution, this fuction checks the state one more time
681:                    * to make sure it does not override any pending transactions.
682:                    *
683:                    * Currently it just quits the routine without reporting any errors back
684:                    * to the user.
685:                    *
686:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
687:                    *             before calling this function!
688:                    * Example:
689:                    * if(USBUSARTIsTxTrfReady())
690:                    *     putUSBUSART(pData, Length);
691:                    *
692:                    * IMPORTANT: Never use the following blocking while loop to wait:
693:                    * while(!USBUSARTIsTxTrfReady())
694:                    *     putUSBUSART(pData, Length);
695:                    *
696:                    * The whole firmware framework is written based on cooperative
697:                    * multi-tasking and a blocking code is not acceptable.
698:                    * Use a state machine instead.
699:                    */
700:                   USBMaskInterrupts();
0011D6  A9C82A     BCLR IEC5, #6
701:                   if(cdc_trf_state == CDC_TX_READY)
0011D8  210DD2     MOV #0x10DD, W2
0011DA  784112     MOV.B [W2], W2
0011DC  514FE0     SUB.B W2, #0x0, [W15]
0011DE  3A0006     BRA NZ, 0x11EC
702:                   {
703:                       mUSBUSARTTxRam((BYTE*)data, length);     // See cdc.h
0011E0  8886F0     MOV W0, pCDCSrc
0011E2  780001     MOV W1, W0
0011E4  B7F0E0     MOV.B WREG, cdc_tx_len
0011E6  B3C010     MOV #0x1, W0
0011E8  B7F0E1     MOV.B WREG, cdc_mem_type
0011EA  B7F0DD     MOV.B WREG, cdc_trf_state
704:                   }
705:                   USBUnmaskInterrupts();
0011EC  A8C82A     BSET IEC5, #6
706:               }//end putUSBUSART
0011EE  FA8000     ULNK
0011F0  060000     RETURN
707:               
708:               /******************************************************************************
709:               	Function:
710:               		void putsUSBUSART(char *data)
711:               		
712:                 Summary:
713:                   putsUSBUSART writes a string of data to the USB including the null
714:                   character. Use this version, 'puts', to transfer data from a RAM buffer.
715:               
716:                 Description:
717:                   putsUSBUSART writes a string of data to the USB including the null
718:                   character. Use this version, 'puts', to transfer data from a RAM buffer.
719:                   
720:                   Typical Usage:
721:                   <code>
722:                       if(USBUSARTIsTxTrfReady())
723:                       {
724:                           char data[] = "Hello World";
725:                           putsUSBUSART(data);
726:                       }
727:                   </code>
728:                   
729:                   The transfer mechanism for device-to-host(put) is more flexible than
730:                   host-to-device(get). It can handle a string of data larger than the
731:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
732:                   \long string of data over multiple USB transactions. CDCTxService()
733:                   must be called periodically to keep sending blocks of data to the host.
734:               
735:                 Conditions:
736:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
737:                   transfer is complete and is ready to receive a new block of data. The
738:                   string of characters pointed to by 'data' must equal to or smaller than
739:                   255 BYTEs.
740:               
741:                 Input:
742:                   char *data -  null\-terminated string of constant data. If a
743:                                           null character is not found, 255 BYTEs of data
744:                                           will be transferred to the host.
745:               		
746:                *****************************************************************************/
747:                
748:               void putsUSBUSART(char *data)
749:               {
0011F2  FA0000     LNK #0x0
750:                   BYTE len;
751:                   char *pData;
752:               
753:                   /*
754:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
755:                    * before calling this function.
756:                    * As a safety precaution, this fuction checks the state one more time
757:                    * to make sure it does not override any pending transactions.
758:                    *
759:                    * Currently it just quits the routine without reporting any errors back
760:                    * to the user.
761:                    *
762:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
763:                    *             before calling this function!
764:                    * Example:
765:                    * if(USBUSARTIsTxTrfReady())
766:                    *     putsUSBUSART(pData, Length);
767:                    *
768:                    * IMPORTANT: Never use the following blocking while loop to wait:
769:                    * while(!USBUSARTIsTxTrfReady())
770:                    *     putsUSBUSART(pData);
771:                    *
772:                    * The whole firmware framework is written based on cooperative
773:                    * multi-tasking and a blocking code is not acceptable.
774:                    * Use a state machine instead.
775:                    */
776:                   USBMaskInterrupts();
0011F4  A9C82A     BCLR IEC5, #6
777:                   if(cdc_trf_state != CDC_TX_READY)
0011F6  210DD1     MOV #0x10DD, W1
0011F8  784091     MOV.B [W1], W1
0011FA  50CFE0     SUB.B W1, #0x0, [W15]
0011FC  3A000F     BRA NZ, 0x121C
0011FE  780100     MOV W0, W2
778:                   {
779:                       USBUnmaskInterrupts();
780:                       return;
781:                   }
782:                   
783:                   /*
784:                    * While loop counts the number of BYTEs to send including the
785:                    * null character.
786:                    */
787:                   len = 0;
788:                   pData = data;
789:                   do
790:                   {
791:                       len++;
001200  E84081     INC.B W1, W1
792:                       if(len == 255) break;       // Break loop once max len is reached.
001202  40CFE1     ADD.B W1, #0x1, [W15]
001204  320005     BRA Z, 0x1210
793:                   }while(*pData++);
001206  EB4180     CLR.B W3
001208  11CF92     SUBR.B W3, [W2], [W15]
00120A  320002     BRA Z, 0x1210
00120C  E80102     INC W2, W2
00120E  37FFF8     BRA 0x1200
794:                   
795:                   /*
796:                    * Second piece of information (length of data to send) is ready.
797:                    * Call mUSBUSARTTxRam to setup the transfer.
798:                    * The actual transfer process will be handled by CDCTxService(),
799:                    * which should be called once per Main Program loop.
800:                    */
801:                   mUSBUSARTTxRam((BYTE*)data, len);     // See cdc.h
001210  8886F0     MOV W0, pCDCSrc
001212  780001     MOV W1, W0
001214  B7F0E0     MOV.B WREG, cdc_tx_len
001216  B3C010     MOV #0x1, W0
001218  B7F0E1     MOV.B WREG, cdc_mem_type
00121A  B7F0DD     MOV.B WREG, cdc_trf_state
802:                   USBUnmaskInterrupts();
00121C  A8C82A     BSET IEC5, #6
803:               }//end putsUSBUSART
00121E  FA8000     ULNK
001220  060000     RETURN
804:               
805:               /**************************************************************************
806:                 Function:
807:                       void putrsUSBUSART(const ROM char *data)
808:                   
809:                 Summary:
810:                   putrsUSBUSART writes a string of data to the USB including the null
811:                   character. Use this version, 'putrs', to transfer data literals and
812:                   data located in program memory.
813:               
814:                 Description:
815:                   putrsUSBUSART writes a string of data to the USB including the null
816:                   character. Use this version, 'putrs', to transfer data literals and
817:                   data located in program memory.
818:                   
819:                   Typical Usage:
820:                   <code>
821:                       if(USBUSARTIsTxTrfReady())
822:                       {
823:                           putrsUSBUSART("Hello World");
824:                       }
825:                   </code>
826:                   
827:                   The transfer mechanism for device-to-host(put) is more flexible than
828:                   host-to-device(get). It can handle a string of data larger than the
829:                   maximum size of bulk IN endpoint. A state machine is used to transfer a
830:                   \long string of data over multiple USB transactions. CDCTxService()
831:                   must be called periodically to keep sending blocks of data to the host.
832:               
833:                 Conditions:
834:                   USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
835:                   transfer is complete and is ready to receive a new block of data. The
836:                   string of characters pointed to by 'data' must equal to or smaller than
837:                   255 BYTEs.
838:               
839:                 Input:
840:                   const ROM char *data -  null\-terminated string of constant data. If a
841:                                           null character is not found, 255 BYTEs of data
842:                                           will be transferred to the host.
843:                                                                                          
844:                 **************************************************************************/
845:               void putrsUSBUSART(const ROM char *data)
846:               {
001222  FA0000     LNK #0x0
847:                   BYTE len;
848:                   const ROM char *pData;
849:               
850:                   /*
851:                    * User should have checked that cdc_trf_state is in CDC_TX_READY state
852:                    * before calling this function.
853:                    * As a safety precaution, this fuction checks the state one more time
854:                    * to make sure it does not override any pending transactions.
855:                    *
856:                    * Currently it just quits the routine without reporting any errors back
857:                    * to the user.
858:                    *
859:                    * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()
860:                    *             before calling this function!
861:                    * Example:
862:                    * if(USBUSARTIsTxTrfReady())
863:                    *     putsUSBUSART(pData);
864:                    *
865:                    * IMPORTANT: Never use the following blocking while loop to wait:
866:                    * while(cdc_trf_state != CDC_TX_READY)
867:                    *     putsUSBUSART(pData);
868:                    *
869:                    * The whole firmware framework is written based on cooperative
870:                    * multi-tasking and a blocking code is not acceptable.
871:                    * Use a state machine instead.
872:                    */
873:                   USBMaskInterrupts();
001224  A9C82A     BCLR IEC5, #6
874:                   if(cdc_trf_state != CDC_TX_READY)
001226  210DD1     MOV #0x10DD, W1
001228  784091     MOV.B [W1], W1
00122A  50CFE0     SUB.B W1, #0x0, [W15]
00122C  3A000F     BRA NZ, 0x124C
00122E  780100     MOV W0, W2
875:                   {
876:                       USBUnmaskInterrupts();
877:                       return;
878:                   }
879:                   
880:                   /*
881:                    * While loop counts the number of BYTEs to send including the
882:                    * null character.
883:                    */
884:                   len = 0;
885:                   pData = data;
886:                   do
887:                   {
888:                       len++;
001230  E84081     INC.B W1, W1
889:                       if(len == 255) break;       // Break loop once max len is reached.
001232  40CFE1     ADD.B W1, #0x1, [W15]
001234  320005     BRA Z, 0x1240
890:                   }while(*pData++);
001236  EB4180     CLR.B W3
001238  11CF92     SUBR.B W3, [W2], [W15]
00123A  320002     BRA Z, 0x1240
00123C  E80102     INC W2, W2
00123E  37FFF8     BRA 0x1230
891:                   
892:                   /*
893:                    * Second piece of information (length of data to send) is ready.
894:                    * Call mUSBUSARTTxRom to setup the transfer.
895:                    * The actual transfer process will be handled by CDCTxService(),
896:                    * which should be called once per Main Program loop.
897:                    */
898:               
899:                   mUSBUSARTTxRom((ROM BYTE*)data,len); // See cdc.h
001240  8886F0     MOV W0, pCDCSrc
001242  780001     MOV W1, W0
001244  B7F0E0     MOV.B WREG, cdc_tx_len
001246  EF70E1     CLR.B cdc_mem_type
001248  B3C010     MOV #0x1, W0
00124A  B7F0DD     MOV.B WREG, cdc_trf_state
900:                   USBUnmaskInterrupts();
00124C  A8C82A     BSET IEC5, #6
901:               
902:               }//end putrsUSBUSART
00124E  FA8000     ULNK
001250  060000     RETURN
903:               
904:               /************************************************************************
905:                 Function:
906:                       void CDCTxService(void)
907:                   
908:                 Summary:
909:                   CDCTxService handles device-to-host transaction(s). This function
910:                   should be called once per Main Program loop after the device reaches
911:                   the configured state.
912:                 Description:
913:                   CDCTxService handles device-to-host transaction(s). This function
914:                   should be called once per Main Program loop after the device reaches
915:                   the configured state (after the CDCIniEP() function has already executed).
916:                   This function is needed, in order to advance the internal software state 
917:                   machine that takes care of sending multiple transactions worth of IN USB
918:                   data to the host, associated with CDC serial data.  Failure to call 
919:                   CDCTxService() perioidcally will prevent data from being sent to the
920:                   USB host, over the CDC serial data interface.
921:                   
922:                   Typical Usage:
923:                   <code>
924:                   void main(void)
925:                   {
926:                       USBDeviceInit();
927:                       while(1)
928:                       {
929:                           USBDeviceTasks();
930:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
931:                              (USBIsDeviceSuspended() == TRUE))
932:                           {
933:                               //Either the device is not configured or we are suspended
934:                               //  so we don't want to do execute any application code
935:                               continue;   //go back to the top of the while loop
936:                           }
937:                           else
938:                           {
939:                               //Keep trying to send data to the PC as required
940:                               CDCTxService();
941:                   
942:                               //Run application code.
943:                               UserApplication();
944:                           }
945:                       }
946:                   }
947:                   </code>
948:                 Conditions:
949:                   CDCIniEP() function should have already executed/the device should be
950:                   in the CONFIGURED_STATE.
951:                 Remarks:
952:                   None                                                                 
953:                 ************************************************************************/
954:                
955:               void CDCTxService(void)
956:               {
001252  FA0000     LNK #0x0
957:                   BYTE byte_to_send;
958:                   BYTE i;
959:                   
960:                   USBMaskInterrupts();
001254  A9C82A     BCLR IEC5, #6
961:                   
962:                   CDCNotificationHandler();
963:                   
964:                   if(USBHandleBusy(CDCDataInHandle)) 
001256  808770     MOV CDCDataInHandle, W0
001258  500FE0     SUB W0, #0x0, [W15]
00125A  320003     BRA Z, 0x1262
00125C  EB4080     CLR.B W1
00125E  10CF90     SUBR.B W1, [W0], [W15]
001260  350041     BRA LT, 0x12E4
965:                   {
966:                       USBUnmaskInterrupts();
967:                       return;
968:                   }
969:               
970:                   /*
971:                    * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
972:                    * By having this stage, user can always check cdc_trf_state,
973:                    * and not having to call mCDCUsartTxIsBusy() directly.
974:                    */
975:                   if(cdc_trf_state == CDC_TX_COMPLETING)
001262  BFD0DD     MOV.B cdc_trf_state, WREG
001264  504FE3     SUB.B W0, #0x3, [W15]
001266  3A0001     BRA NZ, 0x126A
976:                       cdc_trf_state = CDC_TX_READY;
001268  EF70DD     CLR.B cdc_trf_state
977:                   
978:                   /*
979:                    * If CDC_TX_READY state, nothing to do, just return.
980:                    */
981:                   if(cdc_trf_state == CDC_TX_READY)
00126A  BFD0DD     MOV.B cdc_trf_state, WREG
00126C  32003B     BRA Z, 0x12E4
982:                   {
983:                       USBUnmaskInterrupts();
984:                       return;
985:                   }
986:                   
987:                   /*
988:                    * If CDC_TX_BUSY_ZLP state, send zero length packet
989:                    */
990:                   if(cdc_trf_state == CDC_TX_BUSY_ZLP)
00126E  504FE2     SUB.B W0, #0x2, [W15]
001270  3A0008     BRA NZ, 0x1282
991:                   {
992:                       CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
001272  EB4180     CLR.B W3
001274  EB0100     CLR W2
001276  B3C011     MOV #0x1, W1
001278  07FB62     RCALL USBTransferOnePacket
00127A  888770     MOV W0, CDCDataInHandle
993:                       //CDC_DATA_BD_IN.CNT = 0;
994:                       cdc_trf_state = CDC_TX_COMPLETING;
00127C  B3C030     MOV #0x3, W0
00127E  B7F0DD     MOV.B WREG, cdc_trf_state
001280  370031     BRA 0x12E4
995:                   }
996:                   else if(cdc_trf_state == CDC_TX_BUSY)
001282  504FE1     SUB.B W0, #0x1, [W15]
001284  3A002F     BRA NZ, 0x12E4
997:                   {
998:                       /*
999:                        * First, have to figure out how many byte of data to send.
1000:                       */
1001:                  	if(cdc_tx_len > sizeof(cdc_data_tx))
001286  BFD0E0     MOV.B cdc_tx_len, WREG
001288  784180     MOV.B W0, W3
00128A  B3C401     MOV #0x40, W1
00128C  504F81     SUB.B W0, W1, [W15]
00128E  360001     BRA LEU, 0x1292
001290  784181     MOV.B W1, W3
1002:                  	    byte_to_send = sizeof(cdc_data_tx);
1003:                  	else
1004:                  	    byte_to_send = cdc_tx_len;
1005:              
1006:                      /*
1007:                       * Subtract the number of bytes just about to be sent from the total.
1008:                       */
1009:                  	cdc_tx_len = cdc_tx_len - byte_to_send;
001292  504003     SUB.B W0, W3, W0
001294  B7F0E0     MOV.B WREG, cdc_tx_len
1010:                  	  
1011:                      pCDCDst.bRam = (BYTE*)&cdc_data_tx; // Set destination pointer
001296  211080     MOV #0x1108, W0
001298  888750     MOV W0, pCDCDst
1012:                      
1013:                      i = byte_to_send;
1014:                      if(cdc_mem_type == USB_EP0_ROM)            // Determine type of memory source
00129A  BFD0E1     MOV.B cdc_mem_type, WREG
00129C  320002     BRA Z, 0x12A2
00129E  784003     MOV.B W3, W0
0012A0  370011     BRA 0x12C4
0012A2  784003     MOV.B W3, W0
0012A4  370006     BRA 0x12B2
1015:                      {
1016:                          while(i)
0012B2  504FE0     SUB.B W0, #0x0, [W15]
0012B4  3AFFF8     BRA NZ, 0x12A6
0012B6  370008     BRA 0x12C8
1017:                          {
1018:                              *pCDCDst.bRam = *pCDCSrc.bRom;
0012A6  8086F2     MOV pCDCSrc, W2
0012A8  808751     MOV pCDCDst, W1
0012AA  784892     MOV.B [W2], [W1]
1019:                              pCDCDst.bRam++;
0012AC  EC30EA     INC pCDCDst
1020:                              pCDCSrc.bRom++;
0012AE  EC30DE     INC pCDCSrc
1021:                              i--;
0012B0  E94000     DEC.B W0, W0
1022:                          }//end while(byte_to_send)
1023:                      }
1024:                      else // _RAM
1025:                      {
1026:                          while(i)
0012C4  504FE0     SUB.B W0, #0x0, [W15]
0012C6  3AFFF8     BRA NZ, 0x12B8
1027:                          {
1028:                              *pCDCDst.bRam = *pCDCSrc.bRam;
0012B8  8086F2     MOV pCDCSrc, W2
0012BA  808751     MOV pCDCDst, W1
0012BC  784892     MOV.B [W2], [W1]
1029:                              pCDCDst.bRam++;
0012BE  EC30EA     INC pCDCDst
1030:                              pCDCSrc.bRam++;
0012C0  EC30DE     INC pCDCSrc
1031:                              i--;
0012C2  E94000     DEC.B W0, W0
1032:                          }//end while(byte_to_send._word)
1033:                      }//end if(cdc_mem_type...)
1034:                      
1035:                      /*
1036:                       * Lastly, determine if a zero length packet state is necessary.
1037:                       * See explanation in USB Specification 2.0: Section 5.8.3
1038:                       */
1039:                      if(cdc_tx_len == 0)
0012C8  BFD0E0     MOV.B cdc_tx_len, WREG
0012CA  3A0007     BRA NZ, 0x12DA
1040:                      {
1041:                          if(byte_to_send == CDC_DATA_IN_EP_SIZE)
0012CC  B3C400     MOV #0x40, W0
0012CE  51CF80     SUB.B W3, W0, [W15]
0012D0  3A0002     BRA NZ, 0x12D6
1042:                              cdc_trf_state = CDC_TX_BUSY_ZLP;
0012D2  B3C020     MOV #0x2, W0
0012D4  370001     BRA 0x12D8
1043:                          else
1044:                              cdc_trf_state = CDC_TX_COMPLETING;
0012D6  B3C030     MOV #0x3, W0
0012D8  B7F0DD     MOV.B WREG, cdc_trf_state
1045:                      }//end if(cdc_tx_len...)
1046:                      CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_tx,byte_to_send);
0012DA  211082     MOV #0x1108, W2
0012DC  B3C011     MOV #0x1, W1
0012DE  B3C020     MOV #0x2, W0
0012E0  07FB2E     RCALL USBTransferOnePacket
0012E2  888770     MOV W0, CDCDataInHandle
1047:              
1048:                  }//end if(cdc_tx_sate == CDC_TX_BUSY)
1049:                  
1050:                  USBUnmaskInterrupts();
0012E4  A8C82A     BSET IEC5, #6
1051:              }//end CDCTxService
0012E6  FA8000     ULNK
0012E8  060000     RETURN
1052:              
1053:              #endif //USB_USE_CDC
1054:              
1055:              /** EOF cdc.c ****************************************************************/
---  C:/Files/Ontwerp/WFS220_WiFi_scope/WFS220.X/Source Files/USB/usb_device.c  -------------------------
1:                 /********************************************************************
2:                   File Information:
3:                     FileName:     	usb_device.c
4:                     Dependencies:	See INCLUDES section
5:                     Processor:		PIC18,PIC24, PIC32 and dsPIC33E USB Microcontrollers
6:                     Hardware:		This code is natively intended to be used on Mirochip USB
7:                                     demo boards.  See www.microchip.com/usb (Software & Tools 
8:                                     section) for list of available platforms.  The firmware may 
9:                                     be modified for use on other USB platforms by editing the
10:                    				HardwareProfile.h and HardwareProfile - [platform].h files.
11:                    Complier:  	    Microchip C18 (for PIC18),C30 (for PIC24 and dsPIC33E)
12:                                    and C32 (for PIC32)
13:                    Company:		Microchip Technology, Inc.
14:                    
15:                    Software License Agreement:
16:                    
17:                    The software supplied herewith by Microchip Technology Incorporated
18:                    (the "Company") for its PIC(r) Microcontroller is intended and
19:                    supplied to you, the Company's customer, for use solely and
20:                    exclusively on Microchip PIC Microcontroller products. The
21:                    software is owned by the Company and/or its supplier, and is
22:                    protected under applicable copyright laws. All rights are reserved.
23:                    Any use in violation of the foregoing restrictions may subject the
24:                    user to criminal sanctions under applicable laws, as well as to
25:                    civil liability for the breach of the terms and conditions of this
26:                    license.
27:                    
28:                    THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                    WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                    TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                    PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                    IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                    CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                
35:                  Summary:
36:                    This file contains functions, macros, definitions, variables,
37:                    datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                    stack. This file should be included in projects that use the device stack. 
39:                    
40:                    This file is located in the "\<Install Directory\>\\Microchip\\USB"
41:                    directory.
42:                
43:                  Description:
44:                    USB Device Stack File
45:                    
46:                    This file contains functions, macros, definitions, variables,
47:                    datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                    stack. This file should be included in projects that use the device stack.
49:                    
50:                    This file is located in the "\<Install Directory\>\\Microchip\\USB"
51:                    directory.
52:                    
53:                    When including this file in a new project, this file can either be
54:                    referenced from the directory in which it was installed or copied
55:                    directly into the user application folder. If the first method is
56:                    chosen to keep the file located in the folder in which it is installed
57:                    then include paths need to be added so that the library and the
58:                    application both know where to reference each others files. If the
59:                    application folder is located in the same folder as the Microchip
60:                    folder (like the current demo folders), then the following include
61:                    paths need to be added to the application's project:
62:                    
63:                    .
64:                    ..\\..\\MicrochipInclude
65:                    
66:                    If a different directory structure is used, modify the paths as
67:                    required. An example using absolute paths instead of relative paths
68:                    would be the following:
69:                    
70:                    C:\\Microchip Solutions\\Microchip\\Include
71:                    
72:                    C:\\Microchip Solutions\\My Demo Application 
73:                
74:                ********************************************************************
75:                 File Description:
76:                
77:                 Change History:
78:                  Rev    Description
79:                  ----   -----------
80:                  2.6    Added USBCancelIO() function.  Moved and some stack
81:                         defintions to be more consistant with the host stack.
82:                
83:                  2.6a   Fixed issue where a SET_CONFIGURATION received could cause
84:                         inability to transmit on an endpoint if using ping-pong
85:                         and an odd number of packets had been sent on that endpoint 
86:                
87:                  2.7    Fixed error where the USB error interrupt flag was not getting
88:                         cleared properly for PIC32 resulting in lots of extra error interrupts.
89:                         http://www.microchip.com/forums/tm.aspx?m=479085
90:                
91:                         Fixed issue with dual role mode when device run in polling
92:                         mode.  Interrupts were remaining enabled after the host mode
93:                         operation was complete.  This was incompatible with polling
94:                         mode operation.
95:                
96:                         Changed how the bus sensing works.  In previous revisions it
97:                         was impossible to use the USBDeviceDetach to detach from the
98:                         bus if the bus voltage was still present.  This is now
99:                         possible.  It was also possible to move the device to the 
100:                        ATTACHED state in interrupt mode even if the bus voltage 
101:                        wasn't available.  This is now prohibited unless VBUS is
102:                        present.
103:                        
104:                        Improved error case handling when the host sends more OUT
105:                        bytes in a control transfer than the firmware was expecting
106:                        to receive (based on the size parameter when calling USBEP0Receive()).
107:                        
108:                        In the USBStdSetCfgHandler(), modified the code so the USBDeviceState
109:                        variable only gets updated to the CONFIGURED_STATE at the end of the 
110:                        function.  
111:               
112:                 2.7a   Update to support the PIC18F47J53 A1 and later revision
113:                        devices.
114:               
115:                        Fixed an error on 16-bit and 32-bit processors where a word access
116:                        could be performed on a byte pointer resulting in possible address
117:                        errors with odd aligned pointers.
118:                        
119:                 2.8    Several changes to the way control transfers get processed,
120:                        so as to support the ability to allow application/class specific
121:                        handler code to defer the status stage.  
122:                        Implemented USBCtrlEPAllowStatusStage() API function.
123:                        Implemented USBDeferStatusStage() API function (macro).
124:                        These changes also greatly relax the USBDeviceTasks() calling frequency 
125:                        requirement, while allowing USB class handlers more flexibility.
126:                        
127:                        Also implemented the following API functions and macros, for delaying 
128:                        the data stage of a control transfer (with data stage):
129:                        USBDeferINDataStage()
130:                        USBDeferOUTDataStage()
131:                        USBOUTDataStageDeferred()
132:                        USBINDataStageDeferred()
133:                        USBCtrlEPAllowDataStage()      
134:                        
135:                        Fixed USB reset event handler issue, where the USB stack would 
136:                        re-initialize global interrupt settings in the interrupt context, on 
137:                        PIC18 devices with the stack operated in USB_INTERRUPT mode.
138:                        
139:                        Fixed handling of SET/CLEAR FEATURE (endpoint halt) host requests.
140:                        Previous implementation would not always initialize endpoints correctly 
141:                        to DATA0 DTS state after a clear feature endpoint halt request, for 
142:                        all ping pong mode and usage scenarios.
143:                        
144:                  2.9   Fixed an issue with STALL handling behavior on non-EP0 endpoints, for 
145:                        PIC24 and PIC32 devices.  
146:                  		  
147:                  		 Fixed an issue where the ep_data_in[]/ep_data_out[] flags weren't 
148:                  		 getting re-initialized coincident with the hardware ping pong pointer 
149:                  		 reset during set configuration events.
150:                  		 
151:                  		 Implemented USBGetNextHandle() API function (actually a macro, defined
152:                  		 in usb_device.h).
153:               
154:                  2.9d  Added build option for disabling DTS checking
155:                  
156:                  2.9f  Adding pragma for PIC18F97J94 Family BDT location.
157:               
158:                  2.9h  Updated to be able to support optional Microsoft OS Descriptors
159:               
160:                  2.9i  Updated to set UCON<SUSPND> bit on PIC16F USB devices during 
161:                        suspend, so as to save power.
162:                  
163:               ********************************************************************/
164:               
165:               /*----------------------------------------------------------------------------------
166:               The USBDeviceTasks() function is responsible for detecting and processing various
167:               USB bus events and host requests, such as those required for USB enumeration, when
168:               the USB cable is first attached to the host.  This function is the main dispatcher
169:               routine for the USB stack.
170:               
171:               Additional API functions and macros are also provided by the USB stack, which can be 
172:               used to send/receive USB data to/from the host, among other things.  A full list 
173:               of the available implemented functions/macros are provided in the 
174:               "MCHPFSUSB Library Help".  For normal installations of the MCHPFSUSB Framework,
175:               the USB API documentation can be found from:
176:               
177:               Start menu --> (All Programs) --> Microchip --> MCHPFSUSB vX.x --> Documents --> MCHPFSUSB Library Help
178:               
179:               Once the help file is opened, the API functions/macros are described in the following section:
180:               Library Interface (API) --> Device/Peripheral --> Device Stack --> Interface Routines
181:               Additional API functions may also be provided depending upon the specific USB device class
182:               implemented, and these functions are also documented in the MCHPFSUSB Library Help.
183:               
184:               
185:               If the USB stack is operated in "USB_POLLING" mode (user selectable option in 
186:               usb_config.h), then the application firmware is reponsible for calling the 
187:               USBDeviceTasks() function periodically.  If the USB stack is operated in the 
188:               "USB_INTERRUPT" mode, then the application firmware does not have to directly 
189:               call USBDeviceTasks(), as it will execute only when necessary as an interrupt handler.
190:               
191:               In order to properly operate a USB connection, and to correctly process and respond
192:               to control transfers in the maximum time allowed by the USB specifications, the
193:               USBDeviceTasks() function/interrupt handler must be allowed to execute in a timely
194:               fashion.
195:               
196:               When the USB module is enabled, the USB cable is attached to the host, the USB bus
197:               is not in the suspend state, and the USB stack is operated in the USB_POLLING mode 
198:               with ping pong buffering enabled (at least) on EP0 OUT,  then the maximum allowed 
199:               time between calls to the USBDeviceTasks() function needs to be:
200:               
201:               The faster of:
202:               1.  Once per ~1.8ms, when USBDeviceState == ADR_PENDING_STATE
203:               2.  Once per ~9.8ms, when USBDeviceState == (any other value other than ADR_PENDING_STATE)
204:               3.  Fast enough to ensure the USTAT FIFO can never get full.  See additional explanation below.
205:               
206:               Additional details of the above timing limits are provided:
207:               
208:               Timing item #1: This parameter originates from the 2ms set address "recovery interval"
209:               specification dictated by section "9.2.6.3 Set Address Processing" of the official 
210:               USB 2.0 specifications.
211:               
212:               Timing item #2: This parameter originates from several "10 ms" criteria in the 
213:               USB 2.0 specifications.  For example, reset recovery intervals, resume recovery 
214:               intervals, suspend to actual current reduction, etc. have timing maximums of 10ms.
215:               
216:               Timing item #3: This is not a fixed X.X ms parameter, but depends on the  
217:               transaction rate implemented by the application.  The USBDeviceTasks() function is
218:               responsible for popping entries off the USTAT FIFO.  If the FIFO ever gets full,
219:               then no further USB transactions are allowed to occur, until the firmware pops entries
220:               off the FIFO.  In practice, this means the firmware should call USBDeviceTasks() at
221:               a rate at least as fast as once every three times the USBTransferOnePacket() function
222:               is called.  This ensures that the rate that USTAT FIFO entries are getting added to
223:               the FIFO is lower than the rate that the entries are getting popped off the FIFO (the
224:               USBDeviceTasks() function will pop up to 4 entries per call), which is a
225:               necessary criteria to ensure the USTAT FIFO entries don't "pile up."  Calling
226:               USBDeviceTasks() even more often, ex: >=1 to 1 ratio of USBDeviceTasks() to 
227:               USBTransferOnePacket(), adds further protection against the USTAT FIFO getting full,
228:               and is therefore recommended.
229:               
230:               When the USB stack is operated in USB_INTERRUPT mode, then the above timing 
231:               parameters should be interpreted to be the longest allowed time that the USB 
232:               interrupts may be masked/disabled for, before re-enabling the USB interrupts.
233:               
234:               Calling USBDeviceTasks() (or allowing USBDeviceTasks() to be called) more often 
235:               will still have potential USB data rate speed and processing latency benefits.
236:               It is also beneficial to call USBDeviceTasks() more often than theoretically 
237:               required, since it has been observed that not all host/drivers/bios/hubs are 
238:               100% consistently compliant with all timing parameters of the USB 2.0 specifications.
239:               Therefore, in a USB_POLLING based application, it is still suggested to call 
240:               USBDeviceTasks() as often as there are free CPU cycles.  This ensures best 
241:               performance, along with best possible compatibility with all existing USB 
242:               hosts/hubs (both those that are compliant and [partially] non-compliant).
243:               
244:               If ping pong buffering is not enabled on (at least) EP0 OUT, then it is required
245:               to call (or allow to execute) USBDeviceTasks() much more frequently (ex: once 
246:               per 100us, or preferrably faster).  Therefore, in all applications, it is 
247:               normally recommended to select either the USB_PING_PONG__FULL_PING_PONG or 
248:               USB_PING_PONG__EP0_OUT_ONLY mode (user option in usb_config.h), as these modes
249:               allow for much more relaxed timing requirements, and therefore greater application
250:               firmware design flexibility.
251:               //----------------------------------------------------------------------------------*/
252:               
253:               /** INCLUDES *******************************************************/
254:               #include "usb/usb.h"
255:               #include "HardwareProfile.h"
256:               
257:               #include "usb/usb_device_local.h"
258:               
259:               
260:               #if defined(USB_USE_MSD)
261:                   #include "./USB/usb_function_msd.h"
262:               #endif
263:               
264:               #if !defined(USE_USB_BUS_SENSE_IO)
265:                   #undef USB_BUS_SENSE
266:                   #define USB_BUS_SENSE 1
267:               #endif
268:               
269:               #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
270:                   #define _DTS_CHECKING_ENABLED 0
271:               #else
272:                   #define _DTS_CHECKING_ENABLED _DTSEN
273:               #endif
274:               
275:               /** DEFINITIONS ****************************************************/
276:               
277:               /** VARIABLES ******************************************************/
278:               #if defined(__18CXX)
279:                   #pragma udata
280:               #endif
281:               
282:               USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
283:               USB_VOLATILE BYTE USBActiveConfiguration;
284:               USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
285:               volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
286:               volatile BDT_ENTRY *pBDTEntryEP0OutNext;
287:               volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
288:               volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
289:               USB_VOLATILE BYTE shortPacketStatus;
290:               USB_VOLATILE BYTE controlTransferState;
291:               USB_VOLATILE IN_PIPE inPipes[1];
292:               USB_VOLATILE OUT_PIPE outPipes[1];
293:               USB_VOLATILE BYTE *pDst;
294:               USB_VOLATILE BOOL RemoteWakeup;
295:               USB_VOLATILE BOOL USBBusIsSuspended;
296:               USB_VOLATILE USTAT_FIELDS USTATcopy;
297:               USB_VOLATILE BYTE endpoint_number;
298:               USB_VOLATILE BOOL BothEP0OutUOWNsSet;
299:               USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
300:               USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
301:               USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
302:               volatile BOOL USBDeferStatusStagePacket;
303:               volatile BOOL USBStatusStageEnabledFlag1;
304:               volatile BOOL USBStatusStageEnabledFlag2;
305:               volatile BOOL USBDeferINDataStagePackets;
306:               volatile BOOL USBDeferOUTDataStagePackets;
307:               
308:               
309:               #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
310:                   #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 2)
311:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
312:                   #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 2)+1)
313:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
314:                   #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 4)
315:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
316:                   #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 4)-2)
317:               #else
318:                   #error "No ping pong mode defined."
319:               #endif
320:               
321:               /** USB FIXED LOCATION VARIABLES ***********************************/
322:               #if defined(__18CXX)
323:                   #pragma udata USB_BDT=USB_BDT_ADDRESS
324:               #endif
325:               
326:               volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
327:               
328:               /********************************************************************
329:                * Section B: EP0 Buffer Space
330:                *******************************************************************/
331:               volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
332:               volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
333:               
334:               /********************************************************************
335:                * Section C: non-EP0 Buffer Space
336:                *******************************************************************/
337:               #if defined(USB_USE_MSD)
338:               	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
339:               	volatile USB_MSD_CBW msd_cbw;
340:               	volatile USB_MSD_CSW msd_csw;
341:               	//#pragma udata
342:               
343:               	#if defined(__18CXX)
344:               		#pragma udata myMSD=MSD_BUFFER_ADDRESS
345:               	#endif
346:               	volatile char msd_buffer[512];
347:               #endif
348:               
349:               
350:               
351:               ////Depricated in v2.2 - will be removed in a future revision
352:               #if !defined(USB_USER_DEVICE_DESCRIPTOR)
353:                   //Device descriptor
354:                   extern ROM USB_DEVICE_DESCRIPTOR device_dsc;
355:               #else
356:                   USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
357:               #endif
358:               
359:               #if !defined(USB_USER_CONFIG_DESCRIPTOR)
360:                   //Array of configuration descriptors
361:                   extern ROM BYTE *ROM USB_CD_Ptr[];
362:               #else
363:                   USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
364:               #endif
365:               
366:               extern ROM BYTE *ROM USB_SD_Ptr[];
367:               
368:               /** DECLARATIONS ***************************************************/
369:               #if defined(__18CXX)
370:                   #pragma code
371:               #endif
372:               
373:               /** Macros *********************************************************/
374:               
375:               /** Function Prototypes ********************************************/
376:               //External
377:               //This is the prototype for the required user event handler
378:               BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size);
379:               
380:               //Internal Functions
381:               static void USBCtrlEPService(void);
382:               static void USBCtrlTrfSetupHandler(void);
383:               static void USBCtrlTrfInHandler(void);
384:               static void USBCheckStdRequest(void);
385:               static void USBStdGetDscHandler(void);
386:               static void USBCtrlEPServiceComplete(void);
387:               static void USBCtrlTrfTxService(void);
388:               static void USBCtrlTrfRxService(void);
389:               static void USBStdSetCfgHandler(void);
390:               static void USBStdGetStatusHandler(void);
391:               static void USBStdFeatureReqHandler(void);
392:               static void USBCtrlTrfOutHandler(void);
393:               static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
394:               static void USBWakeFromSuspend(void);
395:               static void USBSuspend(void);
396:               static void USBStallHandler(void);
397:               
398:               //static BOOL USBIsTxBusy(BYTE EPNumber);
399:               //static void USBPut(BYTE EPNum, BYTE Data);
400:               //static void USBEPService(void);
401:               //static void USBProtocolResetHandler(void);
402:               
403:               /******************************************************************************/
404:               /** Function Implementations *************************************************/
405:               /******************************************************************************/
406:               
407:               /******************************************************************************/
408:               /** Internal Macros *********************************************************/
409:               /******************************************************************************/
410:               
411:               /****************************************************************************
412:                 Function:
413:                   void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
414:               
415:                 Description:
416:                   This function will advance the passed pointer to the next buffer based on
417:                   the ping pong option setting.  This function should be used for EP1-EP15
418:                   only.  This function is not valid for EP0.
419:               
420:                 Precondition:
421:                   None
422:               
423:                 Parameters:
424:                   BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
425:                   to the next buffer state
426:               
427:                 Return Values:
428:                   None
429:               
430:                 Remarks:
431:                   None
432:               
433:                 ***************************************************************************/
434:               #define USBAdvancePingPongBuffer(buffer) ((BYTE_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;
435:               #define USBHALPingPongSetToOdd(buffer)   {((BYTE_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
436:               #define USBHALPingPongSetToEven(buffer)  {((BYTE_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
437:               
438:               
439:               /******************************************************************************/
440:               /** External API Functions ****************************************************/
441:               /******************************************************************************/
442:               
443:               /**************************************************************************
444:                   Function:
445:                       void USBDeviceInit(void)
446:                   
447:                   Description:
448:                       This function initializes the device stack it in the default state. The
449:                       USB module will be completely reset including all of the internal
450:                       variables, registers, and interrupt flags.
451:                               
452:                   Precondition:
453:                       This function must be called before any of the other USB Device
454:                       functions can be called, including USBDeviceTasks().
455:                       
456:                   Parameters:
457:                       None
458:                    
459:                   Return Values:
460:                       None
461:                       
462:                   Remarks:
463:                       None
464:                                                                         
465:                 ***************************************************************************/
466:               void USBDeviceInit(void)
467:               {
000864  FA0000     LNK #0x0
468:                   BYTE i;
469:               
470:                   USBDisableInterrupts();
000866  A9C82A     BCLR IEC5, #6
471:               
472:                   // Clear all USB error flags
473:                   USBClearInterruptRegister(U1EIR);  
000868  200FF0     MOV #0xFF, W0
00086A  882620     MOV W0, U1EIR
474:                      
475:                   // Clears all USB interrupts          
476:                   USBClearInterruptRegister(U1IR); 
00086C  882600     MOV W0, U1IR
477:               
478:                   //Clear all of the endpoint control registers
479:                   U1EP0 = 0;
00086E  EF24E0     CLR U1EP0
480:                   
481:                   DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
000870  EF24E2     CLR U1EP1
000872  EF24E4     CLR U1EP2
482:               
483:                   SetConfigurationOptions();
000874  EF24DC     CLR U1CNFG1
000876  2009F0     MOV #0x9F, W0
000878  882630     MOV W0, U1EIE
00087A  882610     MOV W0, U1IE
484:               
485:                   //power up the module (if not already powered)
486:                   USBPowerModule();
00087C  A80490     BSET U1PWRC, #0
487:               
488:                   //set the address of the BDT (if applicable)
489:                   USBSetBDTAddress(BDT);
00087E  212000     MOV #0x1200, W0
000880  DE00C8     LSR W0, #8, W1
000882  882671     MOV W1, U1BDTP1
490:               
491:                   //Clear all of the BDT entries
492:                   for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
000884  EB4200     CLR.B W4
000896  E84204     INC.B W4, W4
000898  524FEB     SUB.B W4, #0xB, [W15]
00089A  36FFF8     BRA LEU, 0x88C
493:                   {
494:                       BDT[i].Val = 0x00;
000886  780280     MOV W0, W5
000888  B80060     MUL.UU W0, #0, W0
00088A  B81160     MUL.UU W2, #0, W2
00088C  FB8304     ZE W4, W6
00088E  DD3343     SL W6, #3, W6
000890  428306     ADD W5, W6, W6
000892  BE9B00     MOV.D W0, [W6++]
000894  BE9302     MOV.D W2, [W6--]
495:                   }
496:               
497:                   // Assert reset request to all of the Ping Pong buffer pointers
498:                   USBPingPongBufferReset = 1;                    
00089C  A824CA     BSET U1CON, #1
499:               
500:                   // Reset to default address
501:                   U1ADDR = 0x00;                   
00089E  EF24CC     CLR U1ADDR
502:               
503:                   // Make sure packet processing is enabled
504:                   USBPacketDisable = 0;           
0008A0  A9A4CA     BCLR U1CON, #5
505:               
506:                   //Stop trying to reset ping pong buffer pointers
507:                   USBPingPongBufferReset = 0;
0008A2  A924CA     BCLR U1CON, #1
508:               
509:                   // Flush any pending transactions
510:                   while(USBTransactionCompleteIF == 1)      
0008A6  370007     BRA 0x8B6
0008B6  802600     MOV U1IR, W0
0008B8  600068     AND W0, #0x8, W0
0008BA  3AFFF6     BRA NZ, 0x8A8
511:                   {
512:                       USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0008A4  200081     MOV #0x8, W1
0008A8  882601     MOV W1, U1IR
513:                       //Initialize USB stack software state variables
514:                       inPipes[0].info.Val = 0;
0008AA  EF7092     CLR.B 0x1092
515:                       outPipes[0].info.Val = 0;
0008AC  EF70A6     CLR.B 0x10A6
516:                       outPipes[0].wCount.Val = 0;
0008AE  BFD0A7     MOV.B 0x10A7, WREG
0008B0  EF70A7     CLR.B 0x10A7
0008B2  BFD0A8     MOV.B 0x10A8, WREG
0008B4  EF70A8     CLR.B 0x10A8
517:                   }
518:               
519:                   //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
520:                   //try and arm a status stage, even before the first control transfer starts.
521:                   USBStatusStageEnabledFlag1 = TRUE;  
0008BC  200011     MOV #0x1, W1
0008BE  888641     MOV W1, USBStatusStageEnabledFlag1
522:                   USBStatusStageEnabledFlag2 = TRUE;
0008C0  888651     MOV W1, USBStatusStageEnabledFlag2
523:                   //Initialize other flags
524:                   USBDeferINDataStagePackets = FALSE;
0008C2  888470     MOV W0, USBDeferINDataStagePackets
525:                   USBDeferOUTDataStagePackets = FALSE;
0008C4  888450     MOV W0, USBDeferOUTDataStagePackets
526:                   USBBusIsSuspended = FALSE;
0008C6  8884C0     MOV W0, USBBusIsSuspended
527:               
528:               	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
529:               	//pointers to NULL, so they don't get used inadvertently.  
530:               	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
0008E4  E84000     INC.B W0, W0
0008E6  504FE2     SUB.B W0, #0x2, [W15]
0008E8  36FFF3     BRA LEU, 0x8D0
531:               	{
532:               		pBDTEntryIn[i] = 0u;
0008C8  210AC6     MOV #0x10AC, W6
0008D0  FB8080     ZE W0, W1
0008D2  408101     ADD W1, W1, W2
0008D4  430382     ADD W6, W2, W7
0008D6  EB0B80     CLR [W7]
533:               		pBDTEntryOut[i] = 0u;		
0008CA  2109E5     MOV #0x109E, W5
0008D8  428102     ADD W5, W2, W2
0008DA  EB0900     CLR [W2]
534:               		ep_data_in[i].Val = 0u;
0008CC  210C04     MOV #0x10C0, W4
0008DC  420101     ADD W4, W1, W2
0008DE  EB4900     CLR.B [W2]
535:                       ep_data_out[i].Val = 0u;
0008CE  210C33     MOV #0x10C3, W3
0008E0  418081     ADD W3, W1, W1
0008E2  EB4880     CLR.B [W1]
536:               	}
537:               
538:                   //Get ready for the first packet
539:                   pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0008EA  212100     MOV #0x1210, W0
0008EC  888560     MOV W0, pBDTEntryIn
540:                   // Initialize EP0 as a Ctrl EP
541:                   U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
0008EE  2000D0     MOV #0xD, W0
0008F0  882700     MOV W0, U1EP0
542:               	//Prepare for the first SETUP on EP0 OUT
543:                   BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0008F2  210CC0     MOV #0x10CC, W0
0008F4  889020     MOV W0, 0x1204
544:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0008F6  809011     MOV 0x1202, W1
0008F8  2FC000     MOV #0xFC00, W0
0008FA  608000     AND W1, W0, W0
0008FC  A03000     BSET W0, #3
0008FE  889010     MOV W0, 0x1202
545:                   BDT[EP0_OUT_EVEN].STAT.Val = _USIE|_DAT0|_BSTALL;
000900  200840     MOV #0x84, W0
000902  889000     MOV W0, BDT
546:               
547:                   // Clear active configuration
548:                   USBActiveConfiguration = 0;     
000904  EF709C     CLR.B USBActiveConfiguration
549:               
550:                   //Indicate that we are now in the detached state        
551:                   USBDeviceState = DETACHED_STATE;
000906  EF309A     CLR USBDeviceState
552:               }
000908  FA8000     ULNK
00090A  060000     RETURN
553:               
554:               /**************************************************************************
555:                 Function:
556:                       void USBDeviceTasks(void)
557:                   
558:                 Summary:
559:                   This function is the main state machine/transaction handler of the USB 
560:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
561:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
562:                   periodically to receive and transmit packets through the stack. This 
563:                   function also takes care of control transfers associated with the USB 
564:                   enumeration process, and detecting various USB events (such as suspend).  
565:                   This function should be called at least once every 1.8ms during the USB 
566:                   enumeration process. After the enumeration process is complete (which can 
567:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
568:                   USBDeviceTasks() handler may be called the faster of: either once 
569:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
570:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
571:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
572:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
573:                   near the top of usb_device.c for more details about minimum timing 
574:                   requirements when calling USBDeviceTasks().
575:                   
576:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
577:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
578:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
579:                   interrupt occurs, and therefore only needs to be called from the interrupt 
580:                   context.
581:               
582:                 Description:
583:                   This function is the main state machine/transaction handler of the USB 
584:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
585:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
586:                   periodically to receive and transmit packets through the stack. This 
587:                   function also takes care of control transfers associated with the USB 
588:                   enumeration process, and detecting various USB events (such as suspend).  
589:                   This function should be called at least once every 1.8ms during the USB 
590:                   enumeration process. After the enumeration process is complete (which can 
591:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
592:                   USBDeviceTasks() handler may be called the faster of: either once 
593:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
594:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
595:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
596:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
597:                   near the top of usb_device.c for more details about minimum timing 
598:                   requirements when calling USBDeviceTasks().
599:                   
600:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
601:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
602:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
603:                   interrupt occurs, and therefore only needs to be called from the interrupt 
604:                   context.
605:               
606:                   Typical usage:
607:                   <code>
608:                   void main(void)
609:                   {
610:                       USBDeviceInit();
611:                       while(1)
612:                       {
613:                           USBDeviceTasks(); //Takes care of enumeration and other USB events
614:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
615:                              (USBIsDeviceSuspended() == TRUE))
616:                           {
617:                               //Either the device is not configured or we are suspended,
618:                               // so we don't want to execute any USB related application code
619:                               continue;   //go back to the top of the while loop
620:                           }
621:                           else
622:                           {
623:                               //Otherwise we are free to run USB and non-USB related user 
624:                               //application code.
625:                               UserApplication();
626:                           }
627:                       }
628:                   }
629:                   </code>
630:               
631:                 Precondition:
632:                   Make sure the USBDeviceInit() function has been called prior to calling
633:                   USBDeviceTasks() for the first time.
634:                 Remarks:
635:                   USBDeviceTasks() does not need to be called while in the USB suspend mode, 
636:                   if the user application firmware in the USBCBSuspend() callback function
637:                   enables the ACTVIF USB interrupt source and put the microcontroller into 
638:                   sleep mode.  If the application firmware decides not to sleep the 
639:                   microcontroller core during USB suspend (ex: continues running at full 
640:                   frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
641:                   function must still be called periodically, at a rate frequent enough to 
642:                   ensure the 10ms resume recovery interval USB specification is met.  Assuming
643:                   a worst case primary oscillator and PLL start up time of <5ms, then 
644:                   USBDeviceTasks() should be called once every 5ms in this scenario.
645:                  
646:                   When the USB cable is detached, or the USB host is not actively powering 
647:                   the VBUS line to +5V nominal, the application firmware does not always have 
648:                   to call USBDeviceTasks() frequently, as no USB activity will be taking 
649:                   place.  However, if USBDeviceTasks() is not called regularly, some 
650:                   alternative means of promptly detecting when VBUS is powered (indicating 
651:                   host attachment), or not powered (host powered down or USB cable unplugged)
652:                   is still needed.  For self or dual self/bus powered USB applications, see 
653:                   the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
654:                   considerations.
655:                                    
656:                 **************************************************************************/
657:               
658:               #if defined(USB_INTERRUPT) 
659:               #if defined(__18CXX) || defined (_PIC14E)
660:                   void USBDeviceTasks(void)
661:                 #elif defined(__C30__) || defined __XC16__
662:                   void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
663:                 #elif defined(__PIC32MX__)
664:                   void __attribute__((interrupt(),vector(_USB_1_VECTOR))) _USB1Interrupt( void ) 
665:                 #endif
666:               #else
667:               void USBDeviceTasks(void)
668:               #endif
669:               {
000F5A  F80036     PUSH RCOUNT
000F5C  BE9F80     MOV.D W0, [W15++]
000F5E  BE9F82     MOV.D W2, [W15++]
000F60  BE9F84     MOV.D W4, [W15++]
000F62  BE9F86     MOV.D W6, [W15++]
000F64  BE9F88     MOV.D W8, [W15++]
000F66  781F8A     MOV W10, [W15++]
000F68  F80032     PUSH DSRPAG
000F6A  202000     MOV #0x200, W0
000F6C  880190     MOV W0, DSRPAG
000F6E  000000     NOP
000F70  FA0000     LNK #0x0
670:                   BYTE i;
671:               
672:               #ifdef USB_SUPPORT_OTG
673:                   //SRP Time Out Check
674:                   if (USBOTGSRPIsReady())
675:                   {
676:                       if (USBT1MSECIF && USBT1MSECIE)
677:                       {
678:                           if (USBOTGGetSRPTimeOutFlag())
679:                           {
680:                               if (USBOTGIsSRPTimeOutExpired())
681:                               {
682:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
683:                               }       
684:                           }
685:               
686:                           //Clear Interrupt Flag
687:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
688:                       }
689:                   }
690:               #endif
691:               
692:                   #if defined(USB_POLLING)
693:                   //If the interrupt option is selected then the customer is required
694:                   //  to notify the stack when the device is attached or removed from the
695:                   //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
696:                   if (USB_BUS_SENSE != 1)
697:                   {
698:                        // Disable module & detach from bus
699:                        U1CON = 0;             
700:               
701:                        // Mask all USB interrupts              
702:                        U1IE = 0;          
703:               
704:                        //Move to the detached state                  
705:                        USBDeviceState = DETACHED_STATE;
706:               
707:                        #ifdef  USB_SUPPORT_OTG    
708:                            //Disable D+ Pullup
709:                            U1OTGCONbits.DPPULUP = 0;
710:               
711:                            //Disable HNP
712:                            USBOTGDisableHnp();
713:               
714:                            //Deactivate HNP
715:                            USBOTGDeactivateHnp();
716:                            
717:                            //If ID Pin Changed State
718:                            if (USBIDIF && USBIDIE)
719:                            {  
720:                                //Re-detect & Initialize
721:                                 USBOTGInitialize();
722:               
723:                                 //Clear ID Interrupt Flag
724:                                 USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
725:                            }
726:                        #endif
727:               
728:                        #if defined __C30__ || defined __XC16__
729:                            //USBClearInterruptFlag(U1OTGIR, 3); 
730:                        #endif
731:                           //return so that we don't go through the rest of 
732:                           //the state machine
733:                        USBClearUSBInterrupt();
734:                        return;
735:                   }
736:               
737:               	#ifdef USB_SUPPORT_OTG
738:                   //If Session Is Started Then
739:                   else
740:               	{
741:                       //If SRP Is Ready
742:                       if (USBOTGSRPIsReady())
743:                       {   
744:                           //Clear SRPReady
745:                           USBOTGClearSRPReady();
746:               
747:                           //Clear SRP Timeout Flag
748:                           USBOTGClearSRPTimeOutFlag();
749:               
750:                           //Indicate Session Started
751:                           UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
752:                       }
753:                   }
754:               	#endif	//#ifdef USB_SUPPORT_OTG
755:               
756:                   //if we are in the detached state
757:                   if(USBDeviceState == DETACHED_STATE)
758:                   {
759:               	    //Initialize register to known value
760:                       U1CON = 0;                          
761:               
762:                       // Mask all USB interrupts
763:                       U1IE = 0;                                
764:               
765:                       //Enable/set things like: pull ups, full/low-speed mode, 
766:                       //set the ping pong mode, and set internal transceiver
767:                       SetConfigurationOptions();
768:               
769:                       // Enable module & attach to bus
770:                       while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
771:               
772:                       //moved to the attached state
773:                       USBDeviceState = ATTACHED_STATE;
774:               
775:                       #ifdef  USB_SUPPORT_OTG
776:                           U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
777:                       #endif
778:                   }
779:               	#endif  //#if defined(USB_POLLING)
780:               
781:                   if(USBDeviceState == ATTACHED_STATE)
000F72  8084D0     MOV USBDeviceState, W0
000F74  500FE1     SUB W0, #0x1, [W15]
000F76  3A0006     BRA NZ, 0xF84
782:                   {
783:                       /*
784:                        * After enabling the USB module, it takes some time for the
785:                        * voltage on the D+ or D- line to rise high enough to get out
786:                        * of the SE0 condition. The USB Reset interrupt should not be
787:                        * unmasked until the SE0 condition is cleared. This helps
788:                        * prevent the firmware from misinterpreting this unique event
789:                        * as a USB bus reset from the USB host.
790:                        */
791:               
792:                       if(!USBSE0Event)
793:                       {
794:                           USBClearInterruptRegister(U1IR);// Clear all USB interrupts
000F78  200FF0     MOV #0xFF, W0
000F7A  882600     MOV W0, U1IR
795:                           #if defined(USB_POLLING)
796:                               U1IE=0;                        // Mask all USB interrupts
797:                           #endif
798:                           USBResetIE = 1;             // Unmask RESET interrupt
000F7C  A804C2     BSET U1IE, #0
799:                           USBIdleIE = 1;             // Unmask IDLE interrupt
000F7E  A884C2     BSET U1IE, #4
800:                           USBDeviceState = POWERED_STATE;
000F80  200020     MOV #0x2, W0
000F82  8884D0     MOV W0, USBDeviceState
801:                       }
802:                   }
803:               
804:                   #ifdef  USB_SUPPORT_OTG
805:                       //If ID Pin Changed State
806:                       if (USBIDIF && USBIDIE)
807:                       {  
808:                           //Re-detect & Initialize
809:                           USBOTGInitialize();
810:               
811:                           USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
812:                       }
813:                   #endif
814:               
815:                   /*
816:                    * Task A: Service USB Activity Interrupt
817:                    */
818:                   if(USBActivityIF && USBActivityIE)
000F84  AB8488     BTST U1OTGIR, #4
000F86  320005     BRA Z, 0xF92
000F88  AB848A     BTST U1OTGIE, #4
000F8A  320003     BRA Z, 0xF92
819:                   {
820:                       USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
000F8C  200100     MOV #0x10, W0
000F8E  882440     MOV W0, U1OTGIR
821:                       #if defined(USB_SUPPORT_OTG)
822:                           U1OTGIR = 0x10;        
823:                       #else
824:                           USBWakeFromSuspend();
000F90  07FB35     RCALL _USBWakeFromSuspend
825:                       #endif
826:                   }
827:               
828:                   /*
829:                    * Pointless to continue servicing if the device is in suspend mode.
830:                    */
831:                   if(USBSuspendControl==1)
000F92  AB2490     BTST U1PWRC, #1
000F94  3A0061     BRA NZ, 0x1058
832:                   {
833:                       USBClearUSBInterrupt();
834:                       return;
835:                   }
836:               
837:                   /*
838:                    * Task B: Service USB Bus Reset Interrupt.
839:                    * When bus reset is received during suspend, ACTVIF will be set first,
840:                    * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
841:                    * This is why URSTIF is checked after ACTVIF.
842:                    *
843:                    * The USB reset flag is masked when the USB state is in
844:                    * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
845:                    * cause a USB reset event during these two states.
846:                    */
847:                   if(USBResetIF && USBResetIE)
000F96  AB04C0     BTST U1IR, #0
000F98  320008     BRA Z, 0xFAA
000F9A  AB04C2     BTST U1IE, #0
000F9C  320006     BRA Z, 0xFAA
848:                   {
849:                       USBDeviceInit();
000F9E  07FC62     RCALL USBDeviceInit
850:               
851:                       //Re-enable the interrupts since the USBDeviceInit() function will
852:                       //  disable them.  This will do nothing in a polling setup
853:                       USBUnmaskInterrupts();
000FA0  A8C82A     BSET IEC5, #6
854:               
855:                       USBDeviceState = DEFAULT_STATE;
000FA2  200040     MOV #0x4, W0
000FA4  8884D0     MOV W0, USBDeviceState
856:               
857:                       #ifdef USB_SUPPORT_OTG
858:                            //Disable HNP
859:                            USBOTGDisableHnp();
860:               
861:                            //Deactivate HNP
862:                            USBOTGDeactivateHnp();
863:                       #endif
864:               
865:                       USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
000FA6  200010     MOV #0x1, W0
000FA8  882600     MOV W0, U1IR
866:                   }
867:               
868:                   /*
869:                    * Task C: Service other USB interrupts
870:                    */
871:                   if(USBIdleIF && USBIdleIE)
000FAA  AB84C0     BTST U1IR, #4
000FAC  320005     BRA Z, 0xFB8
000FAE  AB84C2     BTST U1IE, #4
000FB0  320003     BRA Z, 0xFB8
872:                   { 
873:                       #ifdef  USB_SUPPORT_OTG 
874:                           //If Suspended, Try to switch to Host
875:                           USBOTGSelectRole(ROLE_HOST);
876:                       #else
877:                           USBSuspend();
000FB2  07FB2F     RCALL _USBSuspend
878:                       #endif
879:                       
880:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
000FB4  200100     MOV #0x10, W0
000FB6  882600     MOV W0, U1IR
881:                   }
882:               
883:                   if(USBSOFIF)
000FB8  AB44C0     BTST U1IR, #2
000FBA  32000E     BRA Z, 0xFD8
884:                   {
885:                       if(USBSOFIE)
000FBC  AB44C2     BTST U1IE, #2
000FBE  320004     BRA Z, 0xFC8
886:                       {
887:                           USB_SOF_HANDLER(EVENT_SOF,0,1);
000FC0  200012     MOV #0x1, W2
000FC2  EB0080     CLR W1
000FC4  200730     MOV #0x73, W0
000FC6  07029C     RCALL USER_USB_CALLBACK_EVENT_HANDLER
888:                       }    
889:                       USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
000FC8  200040     MOV #0x4, W0
000FCA  882600     MOV W0, U1IR
890:                       
891:                       #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
892:                           //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
893:                           #if(USB_SPEED_OPTION == USB_LOW_SPEED)
894:                               #warning "Double click this message.  See inline code comments."
895:                               //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
896:                               //not strictly needed in all applications (ex: those that never call 
897:                               //USBDeferStatusStage() and don't use host to device (OUT) control
898:                               //transfers with data stage).  
899:                               //However, if this feature is enabled and used, it requires a timer 
900:                               //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
901:                               //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
902:                               //packets at a 1ms rate, which generates SOFIF interrupts.
903:                               //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
904:                               //below.  However, the host does not send SOF packets to Low Speed devices.  
905:                               //Therefore, some other method  (ex: using a general purpose microcontroller 
906:                               //timer, such as Timer0) needs to be implemented to call and execute the below code
907:                               //at a once/1ms rate, in a low speed USB application.
908:                               //Note: Pre-condition to executing the below code: USBDeviceInit() should have
909:                               //been called at least once (since the last microcontroller reset/power up), 
910:                               //prior to executing the below code.
911:                           #endif
912:                           
913:                           //Decrement our status stage counter.
914:                           if(USBStatusStageTimeoutCounter != 0u)
000FCC  BFD0C6     MOV.B USBStatusStageTimeoutCounter, WREG
000FCE  320001     BRA Z, 0xFD2
915:                           {
916:                               USBStatusStageTimeoutCounter--;
000FD0  ED70C6     DEC.B USBStatusStageTimeoutCounter
917:                           }
918:                           //Check if too much time has elapsed since progress was made in 
919:                           //processing the control transfer, without arming the status stage.  
920:                           //If so, auto-arm the status stage to ensure that the control 
921:                           //transfer can [eventually] complete, within the timing limits
922:                           //dictated by section 9.2.6 of the official USB 2.0 specifications.
923:                           if(USBStatusStageTimeoutCounter == 0)
000FD2  BFD0C6     MOV.B USBStatusStageTimeoutCounter, WREG
000FD4  3A0001     BRA NZ, 0xFD8
924:                           {
925:                               USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
000FD6  07FDC7     RCALL USBCtrlEPAllowStatusStage
926:                           } 
927:                       #endif
928:                   }
929:               
930:                   if(USBStallIF && USBStallIE)
000FD8  ABE4C0     BTST U1IR, #7
000FDA  320003     BRA Z, 0xFE2
000FDC  ABE4C2     BTST U1IE, #7
000FDE  320001     BRA Z, 0xFE2
931:                   {
932:                       USBStallHandler();
000FE0  07FAA1     RCALL _USBStallHandler
933:                   }
934:               
935:                   if(USBErrorIF && USBErrorIE)
000FE2  AB24C0     BTST U1IR, #1
000FE4  32000A     BRA Z, 0xFFA
000FE6  AB24C2     BTST U1IE, #1
000FE8  320008     BRA Z, 0xFFA
936:                   {
937:                       USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
000FEA  200012     MOV #0x1, W2
000FEC  EB0080     CLR W1
000FEE  27FFF0     MOV #0x7FFF, W0
000FF0  070287     RCALL USER_USB_CALLBACK_EVENT_HANDLER
938:                       USBClearInterruptRegister(U1EIR);               // This clears UERRIF
000FF2  200FF0     MOV #0xFF, W0
000FF4  882620     MOV W0, U1EIR
939:               
940:                       //On PIC18, clearing the source of the error will automatically clear
941:                       //  the interrupt flag.  On other devices the interrupt flag must be 
942:                       //  manually cleared. 
943:                       #if defined(__C32__) || defined(__C30__) || defined __XC16__
944:                           USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
000FF6  200020     MOV #0x2, W0
000FF8  882600     MOV W0, U1IR
945:                       #endif
946:                   }
947:               
948:                   /*
949:                    * Pointless to continue servicing if the host has not sent a bus reset.
950:                    * Once bus reset is received, the device transitions into the DEFAULT
951:                    * state and is ready for communication.
952:                    */
953:                   if(USBDeviceState < DEFAULT_STATE)
000FFA  8084D0     MOV USBDeviceState, W0
000FFC  500FE3     SUB W0, #0x3, [W15]
000FFE  36002C     BRA LEU, 0x1058
954:                   {
955:               	    USBClearUSBInterrupt();
956:               	    return; 
957:               	}  
958:               
959:                   /*
960:                    * Task D: Servicing USB Transaction Complete Interrupt
961:                    */
962:                   if(USBTransactionCompleteIE)
001000  AB64C2     BTST U1IE, #3
001002  32002A     BRA Z, 0x1058
001004  EB4400     CLR.B W8
963:                   {
964:               	    for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
001052  E84408     INC.B W8, W8
001054  544FE3     SUB.B W8, #0x3, [W15]
001056  36FFD9     BRA LEU, 0x100A
965:               		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
966:               		    if(USBTransactionCompleteIF)
00100A  AB64C0     BTST U1IR, #3
00100C  320025     BRA Z, 0x1058
967:               		    {
968:                   		    //Save and extract USTAT register info.  Will use this info later.
969:                               USTATcopy.Val = U1STAT;
00100E  802640     MOV U1STAT, W0
001010  B7F0BC     MOV.B WREG, USTATcopy
970:                               endpoint_number = USBHALGetLastEndpoint(USTATcopy);
001012  BFD0BC     MOV.B USTATcopy, WREG
001014  FB8000     ZE W0, W0
001016  DE0044     LSR W0, #4, W0
001018  B7F0BD     MOV.B WREG, endpoint_number
971:                               
972:                               USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
001006  20008A     MOV #0x8, W10
00101A  88260A     MOV W10, U1IR
973:                               
974:                               //Keep track of the hardware ping pong state for endpoints other
975:                               //than EP0, if ping pong buffering is enabled.
976:                               #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
977:                                   if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
00101C  BFD0BC     MOV.B USTATcopy, WREG
00101E  604068     AND.B W0, #0x8, W0
001020  3A0006     BRA NZ, 0x102E
978:                                   {
979:                                       ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
001022  210BD1     MOV #0x10BD, W1
001024  784091     MOV.B [W1], W1
001026  FB8081     ZE W1, W1
001028  210C30     MOV #0x10C3, W0
00102A  400081     ADD W0, W1, W1
00102C  370004     BRA 0x1036
980:                                   }   
981:                                   else
982:                                   {
983:                                       ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
001008  210C09     MOV #0x10C0, W9
00102E  210BD1     MOV #0x10BD, W1
001030  784091     MOV.B [W1], W1
001032  FB8081     ZE W1, W1
001034  448081     ADD W9, W1, W1
001036  784111     MOV.B [W1], W2
001038  614061     AND.B W2, #0x1, W0
00103A  A20400     BTG.B W0, #0
00103C  784111     MOV.B [W1], W2
00103E  A10402     BCLR.B W2, #0
001040  714880     IOR.B W2, W0, [W1]
984:                                   }         
985:                               #endif    
986:                               
987:                               //USBCtrlEPService only services transactions over EP0.
988:                               //It ignores all other EP transactions.
989:                               if(endpoint_number == 0)
001042  BFD0BD     MOV.B endpoint_number, WREG
001044  3A0002     BRA NZ, 0x104A
990:                               {
991:                                   USBCtrlEPService();
001046  07FF4D     RCALL _USBCtrlEPService
001048  370004     BRA 0x1052
992:                               }
993:                               else
994:                               {
995:                                   USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (BYTE*)&USTATcopy.Val, 0);
00104A  EB0100     CLR W2
00104C  210BC1     MOV #0x10BC, W1
00104E  200720     MOV #0x72, W0
001050  070257     RCALL USER_USB_CALLBACK_EVENT_HANDLER
996:                               }
997:               		    }//end if(USBTransactionCompleteIF)
998:               		    else
999:               		    	break;	//USTAT FIFO must be empty.
1000:              		}//end for()
1001:              	}//end if(USBTransactionCompleteIE)   
1002:              
1003:                  USBClearUSBInterrupt();
001058  A9C80A     BCLR IFS5, #6
1004:              }//end of USBDeviceTasks()
00105A  FA8000     ULNK
00105C  F90032     POP DSRPAG
00105E  78054F     MOV [--W15], W10
001060  BE044F     MOV.D [--W15], W8
001062  BE034F     MOV.D [--W15], W6
001064  BE024F     MOV.D [--W15], W4
001066  BE014F     MOV.D [--W15], W2
001068  BE004F     MOV.D [--W15], W0
00106A  F90036     POP RCOUNT
00106C  064000     RETFIE
1005:              
1006:              /*******************************************************************************
1007:                Function:
1008:                      void USBEnableEndpoint(BYTE ep, BYTE options)
1009:                  
1010:                Summary:
1011:                  This function will enable the specified endpoint with the specified
1012:                  options
1013:                Description:
1014:                  This function will enable the specified endpoint with the specified
1015:                  options.
1016:                  
1017:                  Typical Usage:
1018:                  <code>
1019:                  void USBCBInitEP(void)
1020:                  {
1021:                      USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1022:                      USBMSDInit();
1023:                  }
1024:                  </code>
1025:                  
1026:                  In the above example endpoint number MSD_DATA_IN_EP is being configured
1027:                  for both IN and OUT traffic with handshaking enabled. Also since
1028:                  MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
1029:                  explicitly disable SETUP packets on this endpoint.
1030:                Conditions:
1031:                  None
1032:                Input:
1033:                  BYTE ep -       the endpoint to be configured
1034:                  BYTE options -  optional settings for the endpoint. The options should
1035:                                  be ORed together to form a single options string. The
1036:                                  available optional settings for the endpoint. The
1037:                                  options should be ORed together to form a single options
1038:                                  string. The available options are the following\:
1039:                                  * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
1040:                                    NAK)
1041:                                  * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
1042:                                    NAK)
1043:                                  * USB_OUT_ENABLED enables the out direction
1044:                                  * USB_OUT_DISABLED disables the out direction
1045:                                  * USB_IN_ENABLED enables the in direction
1046:                                  * USB_IN_DISABLED disables the in direction
1047:                                  * USB_ALLOW_SETUP enables control transfers
1048:                                  * USB_DISALLOW_SETUP disables control transfers
1049:                                  * USB_STALL_ENDPOINT STALLs this endpoint
1050:                Return:
1051:                  None
1052:                Remarks:
1053:                  None                                                                                                          
1054:                *****************************************************************************/
1055:              void USBEnableEndpoint(BYTE ep, BYTE options)
1056:              {
00090C  FA0000     LNK #0x0
00090E  BE9F88     MOV.D W8, [W15++]
000910  781F8A     MOV W10, [W15++]
000912  784400     MOV.B W0, W8
000914  784481     MOV.B W1, W9
1057:                  unsigned char* p;
1058:                      
1059:                  //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
1060:                  //starting DTS state in the BDT entry.
1061:                  if(options & USB_OUT_ENABLED)
000916  FB8509     ZE W9, W10
000918  650068     AND W10, #0x8, W0
00091A  320003     BRA Z, 0x922
1062:                  {
1063:                      USBConfigureEndpoint(ep, OUT_FROM_HOST);
00091C  EB4080     CLR.B W1
00091E  784008     MOV.B W8, W0
000920  07FD54     RCALL _USBConfigureEndpoint
1064:                  }
1065:                  if(options & USB_IN_ENABLED)
000922  650564     AND W10, #0x4, W10
000924  320003     BRA Z, 0x92C
1066:                  {
1067:                      USBConfigureEndpoint(ep, IN_TO_HOST);
000926  B3C011     MOV #0x1, W1
000928  784008     MOV.B W8, W0
00092A  07FD4F     RCALL _USBConfigureEndpoint
1068:                  }
1069:              
1070:                  //Update the relevant UEPx register to actually enable the endpoint with
1071:                  //the specified options (ex: handshaking enabled, control transfers allowed,
1072:                  //etc.)
1073:                  #if defined(__C32__)
1074:                      p = (unsigned char*)(&U1EP0+(4*ep));
1075:                  #else
1076:                      p = (unsigned char*)(&U1EP0+ep);
00092C  FB8408     ZE W8, W8
1077:                  #endif
1078:                  *p = options;
00092E  440408     ADD W8, W8, W8
000930  204E00     MOV #0x4E0, W0
000932  400408     ADD W0, W8, W8
000934  784C09     MOV.B W9, [W8]
1079:              }
000936  78054F     MOV [--W15], W10
000938  BE044F     MOV.D [--W15], W8
00093A  FA8000     ULNK
00093C  060000     RETURN
1080:              
1081:              
1082:              /*************************************************************************
1083:                Function:
1084:                  USB_HANDLE USBTransferOnePacket(BYTE ep, BYTE dir, BYTE* data, BYTE len)
1085:                  
1086:                Summary:
1087:                  Transfers a single packet (one transaction) of data on the USB bus.
1088:              
1089:                Description:
1090:                  The USBTransferOnePacket() function prepares a USB endpoint
1091:                  so that it may send data to the host (an IN transaction), or 
1092:                  receive data from the host (an OUT transaction).  The 
1093:                  USBTransferOnePacket() function can be used both to receive	and 
1094:                  send data to the host.  This function is the primary API function 
1095:                  provided by the USB stack firmware for sending or receiving application 
1096:                  data over the USB port.  
1097:              
1098:                  The USBTransferOnePacket() is intended for use with all application 
1099:                  endpoints.  It is not used for sending or receiving applicaiton data 
1100:                  through endpoint 0 by using control transfers.  Separate API 
1101:                  functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
1102:                  USBEP0SendROMPtr() are provided for this purpose.
1103:              
1104:                  The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
1105:                  entry associated with an endpoint buffer, and sets the UOWN bit, which 
1106:                  prepares the USB hardware to allow the transaction to complete.  The 
1107:                  application firmware can use the USBHandleBusy() macro to check the 
1108:                  status of the transaction, to see if the data has been successfully 
1109:                  transmitted yet.
1110:              
1111:              
1112:                  Typical Usage
1113:                  <code>
1114:                  //make sure that the we are in the configured state
1115:                  if(USBGetDeviceState() == CONFIGURED_STATE)
1116:                  {
1117:                      //make sure that the last transaction isn't busy by checking the handle
1118:                      if(!USBHandleBusy(USBInHandle))
1119:                      {
1120:              	        //Write the new data that we wish to send to the host to the INPacket[] array
1121:              	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
1122:              	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
1123:              	        //INPacket[2] = ... (fill in the rest of the packet data)
1124:              	      
1125:                          //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
1126:                          USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(BYTE*)&INPacket[0],sizeof(INPacket));
1127:                      }
1128:                  }
1129:                  </code>
1130:              
1131:                Conditions:
1132:                  Before calling USBTransferOnePacket(), the following should be true.
1133:                  1.  The USB stack has already been initialized (USBDeviceInit() was called).
1134:                  2.  A transaction is not already pending on the specified endpoint.  This
1135:                      is done by checking the previous request using the USBHandleBusy() 
1136:                      macro (see the typical usage example).
1137:                  3.  The host has already sent a set configuration request and the 
1138:                      enumeration process is complete.
1139:                      This can be checked by verifying that the USBGetDeviceState() 
1140:                      macro returns "CONFIGURED_STATE", prior to calling 
1141:                      USBTransferOnePacket().
1142:               					
1143:                Input:
1144:                  BYTE ep - The endpoint number that the data will be transmitted or 
1145:              	          received on
1146:                  BYTE dir - The direction of the transfer
1147:                             This value is either OUT_FROM_HOST or IN_TO_HOST
1148:                  BYTE* data - For IN transactions: pointer to the RAM buffer containing 
1149:                               the data to be sent to the host.  For OUT transactions: pointer
1150:                               to the RAM buffer that the received data should get written to.
1151:                 BYTE len - Length of the data needing to be sent (for IN transactions).
1152:                            For OUT transactions, the len parameter should normally be set
1153:                            to the endpoint size specified in the endpoint descriptor.    
1154:              
1155:                Return Values:
1156:                  USB_HANDLE - handle to the transfer.  The handle is a pointer to 
1157:                               the BDT entry associated with this transaction.  The
1158:                               status of the transaction (ex: if it is complete or still
1159:                               pending) can be checked using the USBHandleBusy() macro
1160:                               and supplying the USB_HANDLE provided by
1161:                               USBTransferOnePacket().
1162:              
1163:                Remarks:
1164:                  If calling the USBTransferOnePacket() function from within the USBCBInitEP()
1165:                  callback function, the set configuration is still being processed and the
1166:                  USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
1167:                  the USBTransferOnePacket() may still be called, but make sure that the 
1168:                  endpoint has been enabled and initialized by the USBEnableEndpoint() 
1169:                  function first.  
1170:                  
1171:                *************************************************************************/
1172:              USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
1173:              {
00093E  FA0000     LNK #0x0
000940  784280     MOV.B W0, W5
000942  FB8205     ZE W5, W4
1174:                  volatile BDT_ENTRY* handle;
1175:              
1176:                  //If the direction is IN
1177:                  if(dir != 0)
000944  50CFE0     SUB.B W1, #0x0, [W15]
000946  320003     BRA Z, 0x94E
1178:                  {
1179:                      //point to the IN BDT of the specified endpoint
1180:                      handle = pBDTEntryIn[ep];
000948  420204     ADD W4, W4, W4
00094A  210AC0     MOV #0x10AC, W0
00094C  370002     BRA 0x952
1181:                  }
1182:                  else
1183:                  {
1184:                      //else point to the OUT BDT of the specified endpoint
1185:                      handle = pBDTEntryOut[ep];
00094E  420204     ADD W4, W4, W4
000950  2109E0     MOV #0x109E, W0
000952  400204     ADD W0, W4, W4
000954  780014     MOV [W4], W0
1186:                  }
1187:                  
1188:                  //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1189:                  //pBDTEntryOut[ep]) is initialized before using it.
1190:                  if(handle == 0)
000956  500FE0     SUB W0, #0x0, [W15]
000958  32002A     BRA Z, 0x9AE
1191:                  {
1192:              	    return 0;
1193:              	}
1194:              
1195:                  //Toggle the DTS bit if required
1196:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1197:                      handle->STAT.Val ^= _DTSMASK;
1198:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1199:                      if(ep != 0)
1200:                      {
1201:                          handle->STAT.Val ^= _DTSMASK;
1202:                      }
1203:                  #endif
1204:              
1205:                  //Set the data pointer, data length, and enable the endpoint
1206:                  handle->ADR = ConvertToPhysicalAddress(data);
00095A  904240     MOV.B [W0+4], W4
00095C  984042     MOV.B W2, [W0+4]
00095E  DE1148     LSR W2, #8, W2
000960  904250     MOV.B [W0+5], W4
000962  984052     MOV.B W2, [W0+5]
1207:                  handle->CNT = len;
000964  FB8183     ZE W3, W3
000966  904120     MOV.B [W0+2], W2
000968  984023     MOV.B W3, [W0+2]
00096A  9041B0     MOV.B [W0+3], W3
00096C  B3CFC2     MOV #0xFC, W2
00096E  61C102     AND.B W3, W2, W2
000970  984032     MOV.B W2, [W0+3]
1208:                  handle->STAT.Val &= _DTSMASK;
000972  784190     MOV.B [W0], W3
000974  FB8103     ZE W3, W2
000976  904190     MOV.B [W0+1], W3
000978  B20402     AND #0x40, W2
00097A  784190     MOV.B [W0], W3
00097C  784802     MOV.B W2, [W0]
00097E  DE1148     LSR W2, #8, W2
000980  904190     MOV.B [W0+1], W3
000982  984012     MOV.B W2, [W0+1]
1209:                  handle->STAT.Val |= _USIE | (_DTSEN & _DTS_CHECKING_ENABLED);
000984  784110     MOV.B [W0], W2
000986  FB8202     ZE W2, W4
000988  904190     MOV.B [W0+1], W3
00098A  DD1948     SL W3, #8, W2
00098C  710104     IOR W2, W4, W2
00098E  B30882     IOR #0x88, W2
000990  784190     MOV.B [W0], W3
000992  784802     MOV.B W2, [W0]
000994  DE1148     LSR W2, #8, W2
000996  904190     MOV.B [W0+1], W3
000998  984012     MOV.B W2, [W0+1]
00099A  FB8105     ZE W5, W2
1210:              
1211:                  //Point to the next buffer for ping pong purposes.
1212:                  if(dir != OUT_FROM_HOST)
00099C  50CFE0     SUB.B W1, #0x0, [W15]
00099E  320003     BRA Z, 0x9A6
1213:                  {
1214:                      //toggle over the to the next buffer for an IN endpoint
1215:                      USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
0009A0  410102     ADD W2, W2, W2
0009A2  210AC1     MOV #0x10AC, W1
0009A4  370002     BRA 0x9AA
1216:                  }
1217:                  else
1218:                  {
1219:                      //toggle over the to the next buffer for an OUT endpoint
1220:                      USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
0009A6  410102     ADD W2, W2, W2
0009A8  2109E1     MOV #0x109E, W1
0009AA  410101     ADD W2, W1, W2
0009AC  A23412     BTG.B [W2], #3
1221:                  }
1222:                  return (USB_HANDLE)handle;
1223:              }
0009AE  FA8000     ULNK
0009B0  060000     RETURN
1224:              
1225:              
1226:              /********************************************************************
1227:                  Function:
1228:                      void USBStallEndpoint(BYTE ep, BYTE dir)
1229:                      
1230:                  Summary:
1231:                       Configures the specified endpoint to send STALL to the host, the next
1232:                       time the host tries to access the endpoint.
1233:                  
1234:                  PreCondition:
1235:                      None
1236:                      
1237:                  Parameters:
1238:                      BYTE ep - The endpoint number that should be configured to send STALL.
1239:                      BYTE dir - The direction of the endpoint to STALL, either 
1240:                                 IN_TO_HOST or OUT_FROM_HOST.
1241:                      
1242:                  Return Values:
1243:                      None
1244:                      
1245:                  Remarks:
1246:                      None
1247:              
1248:               *******************************************************************/
1249:              void USBStallEndpoint(BYTE ep, BYTE dir)
1250:              {
0009B2  FA0000     LNK #0x0
1251:                  BDT_ENTRY *p;
1252:              
1253:                  if(ep == 0)
0009B4  504FE0     SUB.B W0, #0x0, [W15]
0009B6  3A001A     BRA NZ, 0x9EC
1254:                  {
1255:                      //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1256:                      //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1257:                      //packet that will arrrive.
1258:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0009B8  8085B1     MOV pBDTEntryEP0OutNext, W1
0009BA  904121     MOV.B [W1+2], W2
0009BC  B3C082     MOV #0x8, W2
0009BE  9840A2     MOV.B W2, [W1+2]
0009C0  9041B1     MOV.B [W1+3], W3
0009C2  B3CFC2     MOV #0xFC, W2
0009C4  61C102     AND.B W3, W2, W2
0009C6  9840B2     MOV.B W2, [W1+3]
1259:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0009C8  210CC2     MOV #0x10CC, W2
0009CA  9041C1     MOV.B [W1+4], W3
0009CC  9840C2     MOV.B W2, [W1+4]
0009CE  DE1148     LSR W2, #8, W2
0009D0  9041D1     MOV.B [W1+5], W3
0009D2  9840D2     MOV.B W2, [W1+5]
1260:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0009D4  784111     MOV.B [W1], W2
0009D6  B3C8C2     MOV #0x8C, W2
0009D8  784882     MOV.B W2, [W1]
0009DA  904111     MOV.B [W1+1], W2
0009DC  984090     MOV.B W0, [W1+1]
1261:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
0009DE  808561     MOV pBDTEntryIn, W1
0009E0  784111     MOV.B [W1], W2
0009E2  B3C842     MOV #0x84, W2
0009E4  784882     MOV.B W2, [W1]
0009E6  904111     MOV.B [W1+1], W2
0009E8  984090     MOV.B W0, [W1+1]
0009EA  37001B     BRA 0xA22
1262:                             
1263:                  }
1264:                  else
1265:                  {
1266:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
0009EC  FB8081     ZE W1, W1
0009EE  FB8000     ZE W0, W0
0009F0  400000     ADD W0, W0, W0
0009F2  408000     ADD W1, W0, W0
0009F4  DD0044     SL W0, #4, W0
0009F6  212003     MOV #0x1200, W3
0009F8  400083     ADD W0, W3, W1
1267:                      p->STAT.Val |= _BSTALL | _USIE;
0009FA  784111     MOV.B [W1], W2
0009FC  FB8202     ZE W2, W4
0009FE  904111     MOV.B [W1+1], W2
000A00  DD1148     SL W2, #8, W2
000A02  710104     IOR W2, W4, W2
000A04  B30842     IOR #0x84, W2
000A06  784882     MOV.B W2, [W1]
000A08  DE1148     LSR W2, #8, W2
000A0A  984092     MOV.B W2, [W1+1]
1268:                  
1269:                      //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1270:                      //then stall that entry as well
1271:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1272:                  
1273:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
000A0C  400068     ADD W0, #0x8, W0
000A0E  400003     ADD W0, W3, W0
1274:                      p->STAT.Val |= _BSTALL | _USIE;
000A10  784090     MOV.B [W0], W1
000A12  FB8101     ZE W1, W2
000A14  904090     MOV.B [W0+1], W1
000A16  DD08C8     SL W1, #8, W1
000A18  708082     IOR W1, W2, W1
000A1A  B30841     IOR #0x84, W1
000A1C  784801     MOV.B W1, [W0]
000A1E  DE08C8     LSR W1, #8, W1
000A20  984011     MOV.B W1, [W0+1]
1275:                      #endif
1276:                  }
1277:              }
000A22  FA8000     ULNK
000A24  060000     RETURN
1278:              
1279:              /**************************************************************************
1280:                  Function:
1281:                      void USBCancelIO(BYTE endpoint)
1282:                  
1283:                  Description:
1284:                      This function cancels the transfers pending on the specified endpoint.
1285:                      This function can only be used after a SETUP packet is received and 
1286:                      before that setup packet is handled.  This is the time period in which
1287:                      the EVENT_EP0_REQUEST is thrown, before the event handler function
1288:                      returns to the stack.
1289:              
1290:                  Precondition:
1291:                
1292:                  Parameters:
1293:                      BYTE endpoint - the endpoint number you wish to cancel the transfers for
1294:                   
1295:                  Return Values:
1296:                      None
1297:                      
1298:                  Remarks:
1299:                      None
1300:                                                                        
1301:                **************************************************************************/
1302:              void USBCancelIO(BYTE endpoint)
1303:              {
000A26  FA0000     LNK #0x0
000A28  BE9F88     MOV.D W8, [W15++]
000A2A  BE9F8A     MOV.D W10, [W15++]
1304:                  if(USBPacketDisable == 1)
000A2C  ABA4CA     BTST U1CON, #5
000A2E  320078     BRA Z, 0xB20
1305:                  {
1306:                  	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1307:                  	//to mess with the BDT right now.
1308:                  	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
000A30  FB8000     ZE W0, W0
000A32  400000     ADD W0, W0, W0
000A34  210AC1     MOV #0x10AC, W1
000A36  408080     ADD W1, W0, W1
000A38  780011     MOV [W1], W0
000A3A  784110     MOV.B [W0], W2
000A3C  FB8182     ZE W2, W3
000A3E  904110     MOV.B [W0+1], W2
000A40  DD1148     SL W2, #8, W2
000A42  710403     IOR W2, W3, W8
000A44  904120     MOV.B [W0+2], W2
000A46  FB8102     ZE W2, W2
000A48  9041B0     MOV.B [W0+3], W3
000A4A  DD19C8     SL W3, #8, W3
000A4C  718482     IOR W3, W2, W9
000A4E  904140     MOV.B [W0+4], W2
000A50  FB8102     ZE W2, W2
000A52  9041D0     MOV.B [W0+5], W3
000A54  DD19C8     SL W3, #8, W3
000A56  718502     IOR W3, W2, W10
000A58  904160     MOV.B [W0+6], W2
000A5A  FB8102     ZE W2, W2
000A5C  9041F0     MOV.B [W0+7], W3
000A5E  DD19C8     SL W3, #8, W3
000A60  718582     IOR W3, W2, W11
000A62  200404     MOV #0x40, W4
000A64  200005     MOV #0x0, W5
000A66  B83360     MUL.UU W6, #0, W6
000A68  620408     AND W4, W8, W8
000A6A  628489     AND W5, W9, W9
000A6C  63050A     AND W6, W10, W10
000A6E  63858B     AND W7, W11, W11
000A70  784110     MOV.B [W0], W2
000A72  784808     MOV.B W8, [W0]
000A74  DE4148     LSR W8, #8, W2
000A76  904190     MOV.B [W0+1], W3
000A78  984012     MOV.B W2, [W0+1]
000A7A  904120     MOV.B [W0+2], W2
000A7C  984029     MOV.B W9, [W0+2]
000A7E  DE4948     LSR W9, #8, W2
000A80  9041B0     MOV.B [W0+3], W3
000A82  984032     MOV.B W2, [W0+3]
000A84  904140     MOV.B [W0+4], W2
000A86  98404A     MOV.B W10, [W0+4]
000A88  DE5148     LSR W10, #8, W2
000A8A  9041D0     MOV.B [W0+5], W3
000A8C  984052     MOV.B W2, [W0+5]
000A8E  904160     MOV.B [W0+6], W2
000A90  98406B     MOV.B W11, [W0+6]
000A92  DE5948     LSR W11, #8, W2
000A94  9041F0     MOV.B [W0+7], W3
000A96  984072     MOV.B W2, [W0+7]
1309:                  	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
000A98  784290     MOV.B [W0], W5
000A9A  FB8185     ZE W5, W3
000A9C  904110     MOV.B [W0+1], W2
000A9E  DD1148     SL W2, #8, W2
000AA0  710203     IOR W2, W3, W4
000AA2  904120     MOV.B [W0+2], W2
000AA4  FB8102     ZE W2, W2
000AA6  9041B0     MOV.B [W0+3], W3
000AA8  DD19C8     SL W3, #8, W3
000AAA  718282     IOR W3, W2, W5
000AAC  904140     MOV.B [W0+4], W2
000AAE  FB8102     ZE W2, W2
000AB0  9041D0     MOV.B [W0+5], W3
000AB2  DD19C8     SL W3, #8, W3
000AB4  718302     IOR W3, W2, W6
000AB6  904160     MOV.B [W0+6], W2
000AB8  FB8102     ZE W2, W2
000ABA  9041F0     MOV.B [W0+7], W3
000ABC  DD19C8     SL W3, #8, W3
000ABE  718382     IOR W3, W2, W7
000AC0  200408     MOV #0x40, W8
000AC2  200009     MOV #0x0, W9
000AC4  B85560     MUL.UU W10, #0, W10
000AC6  6C0204     XOR W8, W4, W4
000AC8  6C8285     XOR W9, W5, W5
000ACA  6D0306     XOR W10, W6, W6
000ACC  6D8387     XOR W11, W7, W7
000ACE  784110     MOV.B [W0], W2
000AD0  784804     MOV.B W4, [W0]
000AD2  DE2148     LSR W4, #8, W2
000AD4  904190     MOV.B [W0+1], W3
000AD6  984012     MOV.B W2, [W0+1]
000AD8  904120     MOV.B [W0+2], W2
000ADA  984025     MOV.B W5, [W0+2]
000ADC  DE2948     LSR W5, #8, W2
000ADE  9041B0     MOV.B [W0+3], W3
000AE0  984032     MOV.B W2, [W0+3]
000AE2  904140     MOV.B [W0+4], W2
000AE4  984046     MOV.B W6, [W0+4]
000AE6  DE3148     LSR W6, #8, W2
000AE8  9041D0     MOV.B [W0+5], W3
000AEA  984052     MOV.B W2, [W0+5]
000AEC  904160     MOV.B [W0+6], W2
000AEE  984067     MOV.B W7, [W0+6]
000AF0  DE3948     LSR W7, #8, W2
000AF2  9041F0     MOV.B [W0+7], W3
000AF4  984072     MOV.B W2, [W0+7]
1310:                  	
1311:                  	//Need to do additional handling if ping-pong buffering is being used
1312:                      #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1313:                      //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1314:                      //(either due to SIE clearing it after a transaction, or the firmware
1315:                      //clearing it) makes hardware ping pong pointer advance.
1316:                      USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
000AF6  A23411     BTG.B [W1], #3
1317:                  
1318:                  	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
000AF8  784490     MOV.B [W0], W9
000AFA  FB8089     ZE W9, W1
000AFC  904110     MOV.B [W0+1], W2
000AFE  B20401     AND #0x40, W1
000B00  784110     MOV.B [W0], W2
000B02  784801     MOV.B W1, [W0]
000B04  DE08C8     LSR W1, #8, W1
000B06  904110     MOV.B [W0+1], W2
000B08  984011     MOV.B W1, [W0+1]
1319:                  	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
000B0A  784510     MOV.B [W0], W10
000B0C  FB818A     ZE W10, W3
000B0E  904110     MOV.B [W0+1], W2
000B10  DD10C8     SL W2, #8, W1
000B12  708083     IOR W1, W3, W1
000B14  A26001     BTG W1, #6
000B16  784110     MOV.B [W0], W2
000B18  784801     MOV.B W1, [W0]
000B1A  DE08C8     LSR W1, #8, W1
000B1C  904110     MOV.B [W0+1], W2
000B1E  984011     MOV.B W1, [W0+1]
1320:                      #endif
1321:                  }
1322:              }
000B20  BE054F     MOV.D [--W15], W10
000B22  BE044F     MOV.D [--W15], W8
000B24  FA8000     ULNK
000B26  060000     RETURN
1323:              
1324:              /**************************************************************************
1325:                  Function:
1326:                      void USBDeviceDetach(void)
1327:                 
1328:                  Summary:
1329:                      This function configures the USB module to "soft detach" itself from
1330:                      the USB host.
1331:                      
1332:                  Description:
1333:                      This function configures the USB module to perform a "soft detach"
1334:                      operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1335:                      lets the host know the device is present and attached.  This will make
1336:                      the host think that the device has been unplugged.  This is potentially
1337:                      useful, as it allows the USB device to force the host to re-enumerate
1338:                      the device (on the firmware has re-enabled the USB module/pull up, by
1339:                      calling USBDeviceAttach(), to "soft re-attach" to the host).
1340:                      
1341:                  Precondition:
1342:                      Should only be called when USB_INTERRUPT is defined.  See remarks
1343:                      section if USB_POLLING mode option is being used (usb_config.h option).
1344:              
1345:                      Additionally, this function should only be called from the main() loop 
1346:                      context.  Do not call this function from within an interrupt handler, as 
1347:                      this function may modify global interrupt enable bits and settings.
1348:                      
1349:                  Parameters:
1350:                      None
1351:                   
1352:                  Return Values:
1353:                      None
1354:                      
1355:                  Remarks:
1356:                      If the application firmware calls USBDeviceDetach(), it is strongly
1357:                      recommended that the firmware wait at least >= 80ms before calling
1358:                      USBDeviceAttach().  If the firmeware performs a soft detach, and then
1359:                      re-attaches too soon (ex: after a few micro seconds for instance), some
1360:                      hosts may interpret this as an unexpected "glitch" rather than as a
1361:                      physical removal/re-attachment of the USB device.  In this case the host
1362:                      may simply ignore the event without re-enumerating the device.  To 
1363:                      ensure that the host properly detects and processes the device soft
1364:                      detach/re-attach, it is recommended to make sure the device remains 
1365:                      detached long enough to mimic a real human controlled USB 
1366:                      unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1367:                      call USBDeviceAttach() for at least 80+ms, preferrably longer.
1368:                      
1369:                      Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1370:                      or take long to execute.  It is the application firmware's 
1371:                      responsibility for adding the 80+ms delay, when using these API 
1372:                      functions.
1373:                      
1374:                      Note: The Windows plug and play event handler processing is fairly 
1375:                      slow, especially in certain versions of Windows, and for certain USB
1376:                      device classes.  It has been observed that some device classes need to
1377:                      provide even more USB detach dwell interval (before calling 
1378:                      USBDeviceAttach()), in order to work correctly after re-enumeration.
1379:                      If the USB device is a CDC class device, it is recommended to wait
1380:                      at least 1.5 seconds or longer, before soft re-attaching to the host,
1381:                      to provide the plug and play event handler enough time to finish 
1382:                      processing the removal event, before the re-attach occurs.
1383:                      
1384:                      If the application is using the USB_POLLING mode option, then the 
1385:                      USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1386:                      In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1387:                      and "#define USB_BUS_SENSE" options in the 
1388:                      HardwareProfile – [platform name].h file. 
1389:              
1390:                      When using the USB_POLLING mode option, and the 
1391:                      "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1392:                      the USB stack assumes that it should always enable the USB module at 
1393:                      pretty much all times.  Basically, anytime the application firmware 
1394:                      calls USBDeviceTasks(), the firmware will automatically enable the USB 
1395:                      module.  This mode would typically be selected if the application was 
1396:                      designed to be a purely bus powered device.  In this case, the 
1397:                      application is powered from the +5V VBUS supply from the USB port, so 
1398:                      it is correct and sensible in this type of application to power up and 
1399:                      turn on the USB module, at anytime that the microcontroller is 
1400:                      powered (which implies the USB cable is attached and the host is also 
1401:                      powered).
1402:              
1403:                      In a self powered application, the USB stack is designed with the 
1404:                      intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1405:                      option in the HardwareProfile – [platform name].h file.  When this 
1406:                      option is defined, then the USBDeviceTasks() function will automatically 
1407:                      check the I/O pin port value of the designated pin (based on the 
1408:                      #define USB_BUS_SENSE option in the HardwareProfile – [platform name].h 
1409:                      file), every time the application calls USBDeviceTasks().  If the 
1410:                      USBDeviceTasks() function is executed and finds that the pin defined by 
1411:                      the #define USB_BUS_SENSE is in a logic low state, then it will 
1412:                      automatically disable the USB module and tri-state the D+ and D- pins.  
1413:                      If however the USBDeviceTasks() function is executed and finds the pin 
1414:                      defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1415:                      will automatically enable the USB module, if it has not already been 
1416:                      enabled.        
1417:                                                                        
1418:                **************************************************************************/
1419:              #if defined(USB_INTERRUPT)
1420:              void USBDeviceDetach(void)
1421:              {
000B28  FA0000     LNK #0x0
1422:                  //If the interrupt option is selected then the customer is required
1423:                  //  to notify the stack when the device is attached or removed from the
1424:                  //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1425:              #ifdef USB_SUPPORT_OTG
1426:                  if (USB_BUS_SENSE != 1)
1427:              #endif
1428:                  {
1429:                       // Disable module & detach from bus
1430:                       U1CON = 0;             
000B2A  EB0000     CLR W0
000B2C  882650     MOV W0, U1CON
1431:              
1432:                       // Mask all USB interrupts              
1433:                       U1IE = 0;          
000B2E  882610     MOV W0, U1IE
1434:              
1435:                       //Move to the detached state                  
1436:                       USBDeviceState = DETACHED_STATE;
000B30  8884D0     MOV W0, USBDeviceState
1437:              
1438:                       #ifdef  USB_SUPPORT_OTG    
1439:                           //Disable D+ Pullup
1440:                           U1OTGCONbits.DPPULUP = 0;
1441:              
1442:                           //Disable HNP
1443:                           USBOTGDisableHnp();
1444:              
1445:                           //Deactivate HNP
1446:                           USBOTGDeactivateHnp();
1447:                           
1448:                           //If ID Pin Changed State
1449:                           if (USBIDIF && USBIDIE)
1450:                           {  
1451:                               //Re-detect & Initialize
1452:                                USBOTGInitialize();
1453:              
1454:                                //Clear ID Interrupt Flag
1455:                                USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1456:                           }
1457:                       #endif
1458:              
1459:                       #if defined __C30__ || defined __XC16__
1460:                           //USBClearInterruptFlag(U1OTGIR, 3); 
1461:                       #endif
1462:                          //return so that we don't go through the rest of 
1463:                          //the state machine
1464:                        return;
1465:                  }
1466:              
1467:              #ifdef USB_SUPPORT_OTG
1468:                  //If Session Is Started Then
1469:                 else
1470:                 {
1471:                      //If SRP Is Ready
1472:                      if (USBOTGSRPIsReady())
1473:                      {   
1474:                          //Clear SRPReady
1475:                          USBOTGClearSRPReady();
1476:              
1477:                          //Clear SRP Timeout Flag
1478:                          USBOTGClearSRPTimeOutFlag();
1479:              
1480:                          //Indicate Session Started
1481:                          UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1482:                      }
1483:                  }
1484:              #endif
1485:              }
000B32  FA8000     ULNK
000B34  060000     RETURN
1486:              #endif  //#if defined(USB_INTERRUPT)
1487:              /**************************************************************************
1488:                  Function:
1489:                      void USBDeviceAttach(void)
1490:                  
1491:                  Summary:
1492:                      Checks if VBUS is present, and that the USB module is not already 
1493:                      initalized, and if so, enables the USB module so as to signal device 
1494:                      attachment to the USB host.   
1495:              
1496:                  Description:
1497:                      This function indicates to the USB host that the USB device has been
1498:                      attached to the bus.  This function needs to be called in order for the
1499:                      device to start to enumerate on the bus.
1500:                              
1501:                  Precondition:
1502:                      Should only be called when USB_INTERRUPT is defined.  Also, should only 
1503:                      be called from the main() loop context.  Do not call USBDeviceAttach()
1504:                      from within an interrupt handler, as the USBDeviceAttach() function
1505:                      may modify global interrupt enable bits and settings.
1506:              
1507:                      For normal USB devices:
1508:                      Make sure that if the module was previously on, that it has been turned off 
1509:                      for a long time (ex: 100ms+) before calling this function to re-enable the module.
1510:                      If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1511:                      pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1512:                      reject this event, since no human could ever unplug and reattach a USB device in a 
1513:                      microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1514:                      of glitch and ignore the event altogether.  
1515:                  Parameters:
1516:                      None
1517:                   
1518:                  Return Values:
1519:                      None       
1520:                  
1521:                  Remarks: 
1522:              		See also the USBDeviceDetach() API function documentation.                                                 
1523:              ****************************************************************************/
1524:              #if defined(USB_INTERRUPT)
1525:              void USBDeviceAttach(void)
1526:              {
000B36  FA0000     LNK #0x0
1527:                  //if we are in the detached state
1528:                  if(USBDeviceState == DETACHED_STATE)
000B38  8084D0     MOV USBDeviceState, W0
000B3A  500FE0     SUB W0, #0x0, [W15]
000B3C  3A0012     BRA NZ, 0xB62
1529:                  {
1530:                      if(USB_BUS_SENSE == 1)
1531:                      {
1532:                  	    //Initialize registers to known states.
1533:                          U1CON = 0;          
000B3E  882650     MOV W0, U1CON
1534:                  
1535:                          // Mask all USB interrupts
1536:                          U1IE = 0;                                
000B40  882610     MOV W0, U1IE
1537:                  
1538:                          //Configure things like: pull ups, full/low-speed mode, 
1539:                          //set the ping pong mode, and set internal transceiver
1540:                          SetConfigurationOptions();
000B42  8826E0     MOV W0, U1CNFG1
000B44  2009F0     MOV #0x9F, W0
000B46  882630     MOV W0, U1EIE
000B48  882610     MOV W0, U1IE
1541:                  
1542:                          USBEnableInterrupts();  //Modifies global interrupt settings
000B4A  A8C82A     BSET IEC5, #6
000B4C  804351     MOV IPC21, W1
000B4E  2F8FF0     MOV #0xF8FF, W0
000B50  608000     AND W1, W0, W0
000B52  A0A000     BSET W0, #10
000B54  884350     MOV W0, IPC21
1543:                  
1544:                          // Enable module & attach to bus
1545:                          while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
000B56  370001     BRA 0xB5A
000B58  A804CA     BSET U1CON, #0
000B5A  AB04CA     BTST U1CON, #0
000B5C  32FFFD     BRA Z, 0xB58
1546:                  
1547:                          //moved to the attached state
1548:                          USBDeviceState = ATTACHED_STATE;
000B5E  200010     MOV #0x1, W0
000B60  8884D0     MOV W0, USBDeviceState
1549:                  
1550:                          #ifdef  USB_SUPPORT_OTG
1551:                              U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1552:                          #endif
1553:                      }
1554:                  }
1555:              }
000B62  FA8000     ULNK
000B64  060000     RETURN
1556:              #endif  //#if defined(USB_INTERRUPT)
1557:              
1558:              
1559:              /*******************************************************************************
1560:                Function: void USBCtrlEPAllowStatusStage(void);
1561:                  
1562:                Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT 
1563:                          (based on the controlTransferState) to allow the status stage packet
1564:                          of a control transfer to complete.  This function gets used 
1565:                          internally by the USB stack itself, but it may also be called from
1566:                          the application firmware, IF the application firmware called
1567:                          the USBDeferStatusStage() function during the initial processing
1568:                          of the control transfer request.  In this case, the application
1569:                          must call the USBCtrlEPAllowStatusStage() once, after it has fully
1570:                          completed processing and handling the data stage portion of the
1571:                          request.  
1572:                          
1573:                          If the application firmware has no need for delaying control 
1574:                          transfers, and therefore never calls USBDeferStatusStage(), then the
1575:                          application firmware should not call USBCtrlEPAllowStatusStage().
1576:                          
1577:                Description:
1578:                  
1579:                Conditions:
1580:                  None
1581:              
1582:                Input:
1583:              
1584:                Return:
1585:              
1586:                Remarks:
1587:                  None                                                                                                          
1588:                *****************************************************************************/
1589:              void USBCtrlEPAllowStatusStage(void)
1590:              {
000B66  FA0000     LNK #0x0
1591:                  //Check and set two flags, prior to actually modifying any BDT entries.
1592:                  //This double checking is necessary to make certain that 
1593:                  //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1594:                  //in main loop context, while simultaneously getting an interrupt which 
1595:                  //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1596:                  if(USBStatusStageEnabledFlag1 == FALSE)
000B68  808640     MOV USBStatusStageEnabledFlag1, W0
000B6A  500FE0     SUB W0, #0x0, [W15]
000B6C  3A003C     BRA NZ, 0xBE6
1597:                  {
1598:                      USBStatusStageEnabledFlag1 = TRUE;  
000B6E  200014     MOV #0x1, W4
000B70  888644     MOV W4, USBStatusStageEnabledFlag1
1599:                      if(USBStatusStageEnabledFlag2 == FALSE)
000B72  808651     MOV USBStatusStageEnabledFlag2, W1
000B74  508FE0     SUB W1, #0x0, [W15]
000B76  3A0037     BRA NZ, 0xBE6
1600:                      {
1601:                          USBStatusStageEnabledFlag2 = TRUE;
000B78  888654     MOV W4, USBStatusStageEnabledFlag2
1602:                      
1603:                          //Determine which endpoints (EP0 IN or OUT needs arming for the status
1604:                          //stage), based on the type of control transfer currently pending.
1605:                          if(controlTransferState == CTRL_TRF_RX)
000B7A  BFD0B9     MOV.B controlTransferState, WREG
000B7C  504FE2     SUB.B W0, #0x2, [W15]
000B7E  3A000A     BRA NZ, 0xB94
1606:                          {
1607:                              pBDTEntryIn[0]->CNT = 0;
000B80  808560     MOV pBDTEntryIn, W0
000B82  904120     MOV.B [W0+2], W2
000B84  984021     MOV.B W1, [W0+2]
000B86  9041B0     MOV.B [W0+3], W3
000B88  B3CFC2     MOV #0xFC, W2
000B8A  61C102     AND.B W3, W2, W2
000B8C  984032     MOV.B W2, [W0+3]
1608:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
000B8E  784110     MOV.B [W0], W2
000B90  B3CC82     MOV #0xC8, W2
000B92  370026     BRA 0xBE0
1609:                          }
1610:                          else if(controlTransferState == CTRL_TRF_TX)
000B94  BFD0B9     MOV.B controlTransferState, WREG
000B96  504FE1     SUB.B W0, #0x1, [W15]
000B98  3A0026     BRA NZ, 0xBE6
1611:                          {
1612:                      		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
000B9A  8885F1     MOV W1, BothEP0OutUOWNsSet
1613:                      
1614:                              //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1615:                              //next SETUP packet.
1616:                      		#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1617:                      		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
000B9C  8085A0     MOV pBDTEntryEP0OutCurrent, W0
000B9E  904120     MOV.B [W0+2], W2
000BA0  B3C083     MOV #0x8, W3
000BA2  984023     MOV.B W3, [W0+2]
000BA4  9042B0     MOV.B [W0+3], W5
000BA6  B3CFC2     MOV #0xFC, W2
000BA8  62C282     AND.B W5, W2, W5
000BAA  984035     MOV.B W5, [W0+3]
1618:                      		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
000BAC  210CC5     MOV #0x10CC, W5
000BAE  780305     MOV W5, W6
000BB0  B20FF6     AND #0xFF, W6
000BB2  9043C0     MOV.B [W0+4], W7
000BB4  984046     MOV.B W6, [W0+4]
000BB6  DE2AC8     LSR W5, #8, W5
000BB8  9043D0     MOV.B [W0+5], W7
000BBA  984055     MOV.B W5, [W0+5]
1619:                      		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; //Prepare endpoint to accept a SETUP transaction
000BBC  784390     MOV.B [W0], W7
000BBE  B3C847     MOV #0x84, W7
000BC0  784807     MOV.B W7, [W0]
000BC2  904390     MOV.B [W0+1], W7
000BC4  984011     MOV.B W1, [W0+1]
1620:                      		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
000BC6  8885F4     MOV W4, BothEP0OutUOWNsSet
1621:                      		#endif
1622:                      
1623:                              //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1624:                      		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000BC8  8085B0     MOV pBDTEntryEP0OutNext, W0
000BCA  904220     MOV.B [W0+2], W4
000BCC  984023     MOV.B W3, [W0+2]
000BCE  9041B0     MOV.B [W0+3], W3
000BD0  61C102     AND.B W3, W2, W2
000BD2  984032     MOV.B W2, [W0+3]
1625:                      		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000BD4  904140     MOV.B [W0+4], W2
000BD6  984046     MOV.B W6, [W0+4]
000BD8  904150     MOV.B [W0+5], W2
000BDA  984055     MOV.B W5, [W0+5]
1626:                      		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
000BDC  784110     MOV.B [W0], W2
000BDE  B3C802     MOV #0x80, W2
000BE0  784802     MOV.B W2, [W0]
000BE2  904110     MOV.B [W0+1], W2
000BE4  984011     MOV.B W1, [W0+1]
1627:                          }
1628:                      }    
1629:                  }
1630:              }   
000BE6  FA8000     ULNK
000BE8  060000     RETURN
1631:              
1632:              
1633:              /*******************************************************************************
1634:                Function: void USBCtrlEPAllowDataStage(void);
1635:                  
1636:                Summary: This function allows the data stage of either a host-to-device or
1637:                          device-to-host control transfer (with data stage) to complete.
1638:                          This function is meant to be used in conjunction with either the
1639:                          USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1640:                          does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1641:                          then the firmware does not need to manually call 
1642:                          USBCtrlEPAllowDataStage(), as the USB stack will call this function
1643:                          instead.
1644:                   
1645:                Description:
1646:                  
1647:                Conditions: A control transfer (with data stage) should already be pending, 
1648:                              if the firmware calls this function.  Additionally, the firmware
1649:                              should have called either USBDeferOUTDataStage() or 
1650:                              USBDeferINDataStage() at the start of the control transfer, if
1651:                              the firmware will be calling this function manually.
1652:              
1653:                Input:
1654:              
1655:                Return:
1656:              
1657:                Remarks: 
1658:                *****************************************************************************/
1659:              void USBCtrlEPAllowDataStage(void)
1660:              {
000D38  FA0000     LNK #0x0
1661:                  USBDeferINDataStagePackets = FALSE;
000D3A  EB0080     CLR W1
000D3C  888471     MOV W1, USBDeferINDataStagePackets
1662:                  USBDeferOUTDataStagePackets = FALSE;
000D3E  888451     MOV W1, USBDeferOUTDataStagePackets
1663:              
1664:                  if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
000D40  BFD0B9     MOV.B controlTransferState, WREG
000D42  504FE2     SUB.B W0, #0x2, [W15]
000D44  3A0013     BRA NZ, 0xD6C
1665:                  {
1666:                      //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1667:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000D46  8085B0     MOV pBDTEntryEP0OutNext, W0
000D48  904120     MOV.B [W0+2], W2
000D4A  B3C082     MOV #0x8, W2
000D4C  984022     MOV.B W2, [W0+2]
000D4E  9041B0     MOV.B [W0+3], W3
000D50  B3CFC2     MOV #0xFC, W2
000D52  61C102     AND.B W3, W2, W2
000D54  984032     MOV.B W2, [W0+3]
1668:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000D56  210D42     MOV #0x10D4, W2
000D58  9041C0     MOV.B [W0+4], W3
000D5A  984042     MOV.B W2, [W0+4]
000D5C  DE1148     LSR W2, #8, W2
000D5E  9041D0     MOV.B [W0+5], W3
000D60  984052     MOV.B W2, [W0+5]
1669:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000D62  784110     MOV.B [W0], W2
000D64  B3CC82     MOV #0xC8, W2
000D66  784802     MOV.B W2, [W0]
000D68  904110     MOV.B [W0+1], W2
000D6A  37001D     BRA 0xDA6
1670:                  }   
1671:                  else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1672:                  {
1673:                      //Error check the data stage byte count.  Make sure the user specified
1674:                      //value was no greater than the number of bytes the host requested.
1675:              		if(SetupPkt.wLength < inPipes[0].wCount.Val)
000D6C  BFD0D2     MOV.B 0x10D2, WREG
000D6E  FB8000     ZE W0, W0
000D70  210D31     MOV #0x10D3, W1
000D72  784091     MOV.B [W1], W1
000D74  DD08C8     SL W1, #8, W1
000D76  708000     IOR W1, W0, W0
000D78  8084A2     MOV 0x1094, W2
000D7A  500F82     SUB W0, W2, [W15]
000D7C  310007     BRA C, 0xD8C
1676:              		{
1677:              			inPipes[0].wCount.Val = SetupPkt.wLength;
000D7E  BFD0D2     MOV.B 0x10D2, WREG
000D80  FB8000     ZE W0, W0
000D82  210D31     MOV #0x10D3, W1
000D84  784091     MOV.B [W1], W1
000D86  DD08C8     SL W1, #8, W1
000D88  708000     IOR W1, W0, W0
000D8A  8884A0     MOV W0, 0x1094
1678:              		}
1679:              		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
000D8C  07FB33     RCALL _USBCtrlTrfTxService
1680:              		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1681:              
1682:              	    //Cnt should have been initialized by responsible request owner (ex: by
1683:              	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1684:              		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000D8E  808560     MOV pBDTEntryIn, W0
000D90  210D41     MOV #0x10D4, W1
000D92  904140     MOV.B [W0+4], W2
000D94  984041     MOV.B W1, [W0+4]
000D96  DE08C8     LSR W1, #8, W1
000D98  904150     MOV.B [W0+5], W2
000D9A  984051     MOV.B W1, [W0+5]
1685:              		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000D9C  784090     MOV.B [W0], W1
000D9E  B3CC81     MOV #0xC8, W1
000DA0  784801     MOV.B W1, [W0]
000DA2  904090     MOV.B [W0+1], W1
000DA4  EB4080     CLR.B W1
000DA6  984011     MOV.B W1, [W0+1]
1686:                  }     
1687:              }    
000DA8  FA8000     ULNK
000DAA  060000     RETURN
1688:              
1689:              
1690:              /******************************************************************************/
1691:              /** Internal Functions *********************************************************/
1692:              /******************************************************************************/
1693:              
1694:              /********************************************************************
1695:               * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1696:               *
1697:               * PreCondition:    None
1698:               *
1699:               * Input:           BYTE EPNum - the endpoint to be configured
1700:               *                  BYTE direction - the direction to be configured
1701:               *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1702:               *
1703:               * Output:          None
1704:               *
1705:               * Side Effects:    None
1706:               *
1707:               * Overview:        This function will configure the specified 
1708:               *                  endpoint
1709:               *
1710:               * Note:            None
1711:               *******************************************************************/
1712:              static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1713:              {
0003CA  FA0000     LNK #0x0
1714:                  volatile BDT_ENTRY* handle;
1715:              
1716:                  //Compute a pointer to the even BDT entry corresponding to the
1717:                  //EPNum and direction values passed to this function.
1718:                  handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
1719:                  handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
0003CC  FB8000     ZE W0, W0
0003CE  FB8101     ZE W1, W2
0003D0  400000     ADD W0, W0, W0
0003D2  410100     ADD W2, W0, W2
0003D4  DD1144     SL W2, #4, W2
0003D6  212003     MOV #0x1200, W3
0003D8  410103     ADD W2, W3, W2
1720:                  
1721:                  handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
0003DA  A17412     BCLR.B [W2], #7
1722:                  //already cleared the entire BDT table
1723:              
1724:                  //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1725:                  //for USBTransferOnePacket() API calls.
1726:                  if(direction == OUT_FROM_HOST)
0003DC  50CFE0     SUB.B W1, #0x0, [W15]
0003DE  3A0002     BRA NZ, 0x3E4
1727:                  {
1728:                      pBDTEntryOut[EPNum] = handle;
0003E0  2109E1     MOV #0x109E, W1
0003E2  370001     BRA 0x3E6
1729:                  }
1730:                  else
1731:                  {
1732:                      pBDTEntryIn[EPNum] = handle;
0003E4  210AC1     MOV #0x10AC, W1
0003E6  408000     ADD W1, W0, W0
0003E8  780802     MOV W2, [W0]
1733:                  }
1734:              
1735:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1736:                      handle->STAT.DTS = 0;
0003EA  A16412     BCLR.B [W2], #6
1737:                      (handle+1)->STAT.DTS = 1;
0003EC  410168     ADD W2, #0x8, W2
0003EE  A06412     BSET.B [W2], #6
1738:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1739:                      //Set DTS to one because the first thing we will do
1740:                      //when transmitting is toggle the bit
1741:                      handle->STAT.DTS = 1;
1742:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1743:                      if(EPNum != 0)
1744:                      {
1745:                          handle->STAT.DTS = 1;
1746:                      }
1747:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1748:                      if(EPNum != 0)
1749:                      {
1750:                          handle->STAT.DTS = 0;
1751:                          (handle+1)->STAT.DTS = 1;
1752:                      }
1753:                  #endif
1754:              }
0003F0  FA8000     ULNK
0003F2  060000     RETURN
1755:              
1756:              
1757:              /******************************************************************************
1758:               * Function:        void USBCtrlEPServiceComplete(void)
1759:               *
1760:               * PreCondition:    None
1761:               *
1762:               * Input:           None
1763:               *
1764:               * Output:          None
1765:               *
1766:               * Side Effects:    None
1767:               *
1768:               * Overview:        This routine wrap up the remaining tasks in servicing
1769:               *                  a Setup Request. Its main task is to set the endpoint
1770:               *                  controls appropriately for a given situation. See code
1771:               *                  below.
1772:               *                  There are three main scenarios:
1773:               *                  a) There was no handler for the Request, in this case
1774:               *                     a STALL should be sent out.
1775:               *                  b) The host has requested a read control transfer,
1776:               *                     endpoints are required to be setup in a specific way.
1777:               *                  c) The host has requested a write control transfer, or
1778:               *                     a control data stage is not required, endpoints are
1779:               *                     required to be setup in a specific way.
1780:               *
1781:               *                  Packet processing is resumed by clearing PKTDIS bit.
1782:               *
1783:               * Note:            None
1784:               *****************************************************************************/
1785:              static void USBCtrlEPServiceComplete(void)
1786:              {
000DAC  FA0000     LNK #0x0
1787:                  /*
1788:                   * PKTDIS bit is set when a Setup Transaction is received.
1789:                   * Clear to resume packet processing.
1790:                   */
1791:                  USBPacketDisable = 0;
000DAE  A9A4CA     BCLR U1CON, #5
1792:              
1793:              	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1794:              	//control transfer is currently in progress.  We need to know the type of control
1795:              	//transfer that is currently pending, in order to know how to properly arm the 
1796:              	//EP0 IN and EP0 OUT endpoints.
1797:                  if(inPipes[0].info.bits.busy == 0)
000DB0  808491     MOV 0x1092, W1
000DB2  B20801     AND #0x80, W1
000DB4  3A0025     BRA NZ, 0xE00
1798:                  {
1799:                      if(outPipes[0].info.bits.busy == 1)
000DB6  BFD0A6     MOV.B 0x10A6, WREG
000DB8  3B0009     BRA NN, 0xDCC
1800:                      {
1801:                          controlTransferState = CTRL_TRF_RX;
000DBA  B3C020     MOV #0x2, W0
000DBC  B7F0B9     MOV.B WREG, controlTransferState
1802:                          /*
1803:                           * Control Write:
1804:                           * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1805:                           */
1806:              
1807:                          //1. Prepare OUT EP to receive data, unless a USB class request handler
1808:                          //   function decided to defer the data stage (ex: because the intended
1809:                          //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1810:                          //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1811:                          //   once it is ready to begin receiving the data.
1812:                          if(USBDeferOUTDataStagePackets == FALSE)
000DBE  808450     MOV USBDeferOUTDataStagePackets, W0
000DC0  500FE0     SUB W0, #0x0, [W15]
000DC2  3A0001     BRA NZ, 0xDC6
1813:                          {
1814:                              USBCtrlEPAllowDataStage();
000DC4  07FFB9     RCALL USBCtrlEPAllowDataStage
1815:                          }
1816:                          
1817:                          //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1818:                          //after all of the OUT data has been received and consumed, or if a timeout occurs.
1819:                          USBStatusStageEnabledFlag2 = FALSE;
000DC6  EF30CA     CLR USBStatusStageEnabledFlag2
1820:                          USBStatusStageEnabledFlag1 = FALSE;
000DC8  EF30C8     CLR USBStatusStageEnabledFlag1
000DCA  370041     BRA 0xE4E
1821:                      }
1822:                      else
1823:                      {
1824:                          /*
1825:                           * If no one knows how to service this request then stall.
1826:                           * Must also prepare EP0 to receive the next SETUP transaction.
1827:                           */
1828:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000DCC  8085B0     MOV pBDTEntryEP0OutNext, W0
000DCE  904120     MOV.B [W0+2], W2
000DD0  B3C082     MOV #0x8, W2
000DD2  984022     MOV.B W2, [W0+2]
000DD4  9041B0     MOV.B [W0+3], W3
000DD6  B3CFC2     MOV #0xFC, W2
000DD8  61C102     AND.B W3, W2, W2
000DDA  984032     MOV.B W2, [W0+3]
1829:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000DDC  210CC2     MOV #0x10CC, W2
000DDE  9041C0     MOV.B [W0+4], W3
000DE0  984042     MOV.B W2, [W0+4]
000DE2  DE1148     LSR W2, #8, W2
000DE4  9041D0     MOV.B [W0+5], W3
000DE6  984052     MOV.B W2, [W0+5]
1830:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
000DE8  784110     MOV.B [W0], W2
000DEA  B3C8C2     MOV #0x8C, W2
000DEC  784802     MOV.B W2, [W0]
000DEE  904110     MOV.B [W0+1], W2
000DF0  984011     MOV.B W1, [W0+1]
1831:                          pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
000DF2  808560     MOV pBDTEntryIn, W0
000DF4  784110     MOV.B [W0], W2
000DF6  B3C842     MOV #0x84, W2
000DF8  784802     MOV.B W2, [W0]
000DFA  904110     MOV.B [W0+1], W2
000DFC  984011     MOV.B W1, [W0+1]
000DFE  370027     BRA 0xE4E
1832:                      }
1833:                  }
1834:                  else    // A module has claimed ownership of the control transfer session.
1835:                  {
1836:              		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
000E00  210CC1     MOV #0x10CC, W1
000E02  784091     MOV.B [W1], W1
000E04  B3C800     MOV #0x80, W0
000E06  60C080     AND.B W1, W0, W1
000E08  320007     BRA Z, 0xE18
1837:              		{
1838:              			controlTransferState = CTRL_TRF_TX;
000E0A  B3C010     MOV #0x1, W0
000E0C  B7F0B9     MOV.B WREG, controlTransferState
1839:              			/*
1840:              			 * Control Read:
1841:              			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1842:              			 *
1843:              			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1844:              			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1845:              			 *    some slow/currently unavailable resource, such as an external I2C EEPROM),
1846:              			 *    Then the class request handler reponsible should call the USBDeferDataStage()
1847:              			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1848:              			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1849:              			 *    is ready to begin sending the data, it should then call the 
1850:              			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1851:              			 */
1852:              			if(USBDeferINDataStagePackets == FALSE)
000E0E  808470     MOV USBDeferINDataStagePackets, W0
000E10  500FE0     SUB W0, #0x0, [W15]
000E12  3A0017     BRA NZ, 0xE42
1853:                          {
1854:                              USBCtrlEPAllowDataStage();
000E14  07FF91     RCALL USBCtrlEPAllowDataStage
000E16  370015     BRA 0xE42
1855:              			}
1856:              
1857:                          // 2. (Optionally) allow the status stage now, to prepare for early termination.
1858:                          //    Note: If a class request handler decided to set USBDeferStatusStagePacket == TRUE,
1859:                          //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1860:                          //    is ready.  If the class request handler does this, it needs to be careful to
1861:                          //    be written so that it can handle the early termination scenario.
1862:                          //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1863:                          //    1.  The desired total number of bytes were sent to the host.
1864:                          //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1865:                          //        started the control transfer) has been reached.
1866:                          //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1867:                          //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1868:                          //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1869:                          //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1870:                          //        option can take care of this for you.
1871:                          //    Note: For this type of control transfer, there is normally no harm in simply arming the
1872:                          //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1873:                          //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
1874:                          //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1875:                          //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1876:                          //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1877:                          USBStatusStageEnabledFlag2 = FALSE;
1878:                          USBStatusStageEnabledFlag1 = FALSE;
1879:                          if(USBDeferStatusStagePacket == FALSE)
1880:                          {
1881:                              USBCtrlEPAllowStatusStage();
1882:                          } 
1883:              		}
1884:              		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1885:              		{
1886:              			//This situation occurs for special types of control transfers,
1887:              			//such as that which occurs when the host sends a SET_ADDRESS
1888:              			//control transfer.  Ex:
1889:              			//
1890:              			//<SETUP[0]><IN[1]> | <SETUP[0]>
1891:              				
1892:              			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1893:              			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1894:              			//an IN status stage.
1895:              
1896:              			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
000E18  B3C020     MOV #0x2, W0
000E1A  B7F0B9     MOV.B WREG, controlTransferState
1897:              			
1898:              			//1. Prepare OUT EP to receive the next SETUP packet.
1899:              			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000E1C  8085B0     MOV pBDTEntryEP0OutNext, W0
000E1E  904120     MOV.B [W0+2], W2
000E20  B3C082     MOV #0x8, W2
000E22  984022     MOV.B W2, [W0+2]
000E24  9041B0     MOV.B [W0+3], W3
000E26  B3CFC2     MOV #0xFC, W2
000E28  61C102     AND.B W3, W2, W2
000E2A  984032     MOV.B W2, [W0+3]
1900:              			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000E2C  210CC2     MOV #0x10CC, W2
000E2E  9041C0     MOV.B [W0+4], W3
000E30  984042     MOV.B W2, [W0+4]
000E32  DE1148     LSR W2, #8, W2
000E34  9041D0     MOV.B [W0+5], W3
000E36  984052     MOV.B W2, [W0+5]
1901:              			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
000E38  784110     MOV.B [W0], W2
000E3A  B3C842     MOV #0x84, W2
000E3C  784802     MOV.B W2, [W0]
000E3E  904110     MOV.B [W0+1], W2
000E40  984011     MOV.B W1, [W0+1]
1902:              				
1903:              			//2. Prepare for IN status stage of the control transfer
1904:                          USBStatusStageEnabledFlag2 = FALSE;
000E42  EF30CA     CLR USBStatusStageEnabledFlag2
1905:                          USBStatusStageEnabledFlag1 = FALSE;
000E44  EF30C8     CLR USBStatusStageEnabledFlag1
1906:              			if(USBDeferStatusStagePacket == FALSE)
000E46  808460     MOV USBDeferStatusStagePacket, W0
000E48  500FE0     SUB W0, #0x0, [W15]
000E4A  3A0001     BRA NZ, 0xE4E
1907:                          {
1908:                              USBCtrlEPAllowStatusStage();
000E4C  07FE8C     RCALL USBCtrlEPAllowStatusStage
1909:                          } 
1910:              		}
1911:              
1912:                  }//end if(ctrl_trf_session_owner == MUID_NULL)
1913:              
1914:              }//end USBCtrlEPServiceComplete
000E4E  FA8000     ULNK
000E50  060000     RETURN
1915:              
1916:              
1917:              /******************************************************************************
1918:               * Function:        void USBCtrlTrfTxService(void)
1919:               *
1920:               * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1921:               *
1922:               * Input:           None
1923:               *
1924:               * Output:          None
1925:               *
1926:               * Side Effects:    None
1927:               *
1928:               * Overview:        This routine is used for device to host control transfers 
1929:               *					(IN transactions).  This function takes care of managing a
1930:               *                  transfer over multiple USB transactions.
1931:               *					This routine should be called from only two places.
1932:               *                  One from USBCtrlEPServiceComplete() and one from
1933:               *                  USBCtrlTrfInHandler().
1934:               *
1935:               * Note:            
1936:               *****************************************************************************/
1937:              static void USBCtrlTrfTxService(void)
1938:              {
0003F4  FA0000     LNK #0x0
1939:                  BYTE byteToSend;
1940:              
1941:                  //Figure out how many bytes of data to send in the next IN transaction.
1942:                  //Assume a full size packet, unless otherwise determined below.
1943:                  byteToSend = USB_EP0_BUFF_SIZE;         
0003F8  B3C081     MOV #0x8, W1
1944:                  if(inPipes[0].wCount.Val < (BYTE)USB_EP0_BUFF_SIZE)
0003F6  8084A0     MOV 0x1094, W0
0003FA  500FE7     SUB W0, #0x7, [W15]
0003FC  3E000A     BRA GTU, 0x412
1945:                  {
1946:                      byteToSend = inPipes[0].wCount.Val;
0003FE  8084A1     MOV 0x1094, W1
1947:              
1948:                      //Keep track of whether or not we have sent a "short packet" yet.
1949:                      //This is useful so that later on, we can configure EP0 IN to STALL,
1950:                      //after we have sent all of the intended data.  This makes sure the
1951:                      //hardware STALLs if the host erroneously tries to send more IN token 
1952:                      //packets, requesting more data than intended in the control transfer.
1953:                      if(shortPacketStatus == SHORT_PKT_NOT_USED)
000400  BFD0B8     MOV.B shortPacketStatus, WREG
000402  3A0002     BRA NZ, 0x408
1954:                      {
1955:                          shortPacketStatus = SHORT_PKT_PENDING;
000404  B3C010     MOV #0x1, W0
000406  370004     BRA 0x410
1956:                      }
1957:                      else if(shortPacketStatus == SHORT_PKT_PENDING)
000408  BFD0B8     MOV.B shortPacketStatus, WREG
00040A  504FE1     SUB.B W0, #0x1, [W15]
00040C  3A0002     BRA NZ, 0x412
1958:                      {
1959:                          shortPacketStatus = SHORT_PKT_SENT;
00040E  B3C020     MOV #0x2, W0
000410  B7F0B8     MOV.B WREG, shortPacketStatus
1960:                      }
1961:                  }
1962:              
1963:                  //Keep track of how many bytes remain to be sent in the transfer, by
1964:                  //subtracting the number of bytes about to be sent from the total.
1965:                  inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
000412  FB8001     ZE W1, W0
000414  B53094     SUB 0x1094
1966:                  
1967:                  //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1968:                  //Note: Control endpoints may never have a max packet size of > 64 bytes.
1969:                  //Therefore, the BC8 and BC9 bits should always be maintained clear.
1970:                  pBDTEntryIn[0]->CNT = byteToSend;
000416  808562     MOV pBDTEntryIn, W2
000418  9041A2     MOV.B [W2+2], W3
00041A  984120     MOV.B W0, [W2+2]
00041C  9041B2     MOV.B [W2+3], W3
00041E  B3CFC0     MOV #0xFC, W0
000420  61C000     AND.B W3, W0, W0
000422  984130     MOV.B W0, [W2+3]
1971:              
1972:                  //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1973:                  //which we will send to the host.
1974:                  pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                // Set destination pointer
000424  210D40     MOV #0x10D4, W0
000426  8885D0     MOV W0, pDst
1975:                  if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
000428  AB1092     BTST 0x1092, #0
00042A  320007     BRA Z, 0x43A
00042C  37000F     BRA 0x44C
1976:                  {
1977:                      while(byteToSend)
00043A  50CFE0     SUB.B W1, #0x0, [W15]
00043C  3AFFF8     BRA NZ, 0x42E
00043E  370008     BRA 0x450
1978:                      {
1979:                          *pDst++ = *inPipes[0].pSrc.bRom++;
00042E  808480     MOV inPipes, W0
000430  8085D2     MOV pDst, W2
000432  785930     MOV.B [W0++], [W2++]
000434  8885D2     MOV W2, pDst
000436  888480     MOV W0, inPipes
1980:                          byteToSend--;
000438  E94081     DEC.B W1, W1
1981:                      }//end while(byte_to_send.Val)
1982:                  }
1983:                  else  // RAM
1984:                  {
1985:                      while(byteToSend)
00044C  50CFE0     SUB.B W1, #0x0, [W15]
00044E  3AFFF8     BRA NZ, 0x440
1986:                      {
1987:                          *pDst++ = *inPipes[0].pSrc.bRam++;
000440  808480     MOV inPipes, W0
000442  8085D2     MOV pDst, W2
000444  785930     MOV.B [W0++], [W2++]
000446  8885D2     MOV W2, pDst
000448  888480     MOV W0, inPipes
1988:                          byteToSend--;
00044A  E94081     DEC.B W1, W1
1989:                      }//end while(byte_to_send.Val)
1990:                  }//end if(usb_stat.ctrl_trf_mem == _ROM)
1991:              }//end USBCtrlTrfTxService
000450  FA8000     ULNK
000452  060000     RETURN
1992:              
1993:              /******************************************************************************
1994:               * Function:        void USBCtrlTrfRxService(void)
1995:               *
1996:               * PreCondition:    pDst and wCount are setup properly.
1997:               *                  pSrc is always &CtrlTrfData
1998:               *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1999:               *                  wCount should be set to 0 at the start of each control
2000:               *                  transfer.
2001:               *
2002:               * Input:           None
2003:               *
2004:               * Output:          None
2005:               *
2006:               * Side Effects:    None
2007:               *
2008:               * Overview:        This routine is used for host to device control transfers
2009:               *					(uses OUT transactions).  This function receives the data that arrives
2010:               *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
2011:               *					buffer.  Once the host has sent all the data it was intending
2012:               *					to send, this function will call the appropriate outPipes[0].pFunc()
2013:               *					handler (unless it is NULL), so that it can be used by the
2014:               *					intended target firmware.
2015:               *
2016:               * Note:            None
2017:               *****************************************************************************/
2018:              static void USBCtrlTrfRxService(void)
2019:              {
000BEA  FA0000     LNK #0x0
2020:                  BYTE byteToRead;
2021:                  BYTE i;
2022:              
2023:                  //Load byteToRead with the number of bytes the host just sent us in the 
2024:                  //last OUT transaction.
2025:                  byteToRead = pBDTEntryEP0OutCurrent->CNT;   
000BEC  8085A0     MOV pBDTEntryEP0OutCurrent, W0
000BEE  9040A0     MOV.B [W0+2], W1
000BF0  904030     MOV.B [W0+3], W0
2026:              
2027:                  //Update the "outPipes[0].wCount.Val", which keeps track of the total number
2028:                  //of remaining bytes expected to be received from the host, in the control
2029:                  //transfer.  First check to see if the host sent us more bytes than the
2030:                  //application firmware was expecting to receive.
2031:                  if(byteToRead > outPipes[0].wCount.Val)
000BF2  BFD0A7     MOV.B 0x10A7, WREG
000BF4  FB8000     ZE W0, W0
000BF6  210A82     MOV #0x10A8, W2
000BF8  784112     MOV.B [W2], W2
000BFA  DD1148     SL W2, #8, W2
000BFC  710000     IOR W2, W0, W0
000BFE  FB8101     ZE W1, W2
000C00  510F80     SUB W2, W0, [W15]
000C02  360003     BRA LEU, 0xC0A
2032:                  {
2033:                      byteToRead = outPipes[0].wCount.Val;
000C04  210A71     MOV #0x10A7, W1
000C06  784091     MOV.B [W1], W1
000C08  BFD0A8     MOV.B 0x10A8, WREG
2034:                  }	
2035:                  //Reduce the number of remaining bytes by the number we just received.
2036:              	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   
000C0A  BFD0A7     MOV.B 0x10A7, WREG
000C0C  FB8000     ZE W0, W0
000C0E  210A82     MOV #0x10A8, W2
000C10  784112     MOV.B [W2], W2
000C12  DD1148     SL W2, #8, W2
000C14  710000     IOR W2, W0, W0
000C16  FB8181     ZE W1, W3
000C18  500003     SUB W0, W3, W0
000C1A  210A72     MOV #0x10A7, W2
000C1C  784112     MOV.B [W2], W2
000C1E  B7F0A7     MOV.B WREG, 0x10A7
000C20  DE0048     LSR W0, #8, W0
000C22  210A82     MOV #0x10A8, W2
000C24  784112     MOV.B [W2], W2
000C26  B7F0A8     MOV.B WREG, 0x10A8
2037:              
2038:                  //Copy the OUT DATAx packet bytes that we just received from the host,
2039:                  //into the user application buffer space.
2040:                  for(i=0;i<byteToRead;i++)
000C28  EB4000     CLR.B W0
000C2C  370016     BRA 0xC5A
000C58  E84000     INC.B W0, W0
000C5A  504F81     SUB.B W0, W1, [W15]
000C5C  39FFE8     BRA NC, 0xC2E
2041:                  {
2042:                      *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
000C2A  210D44     MOV #0x10D4, W4
000C2E  210A42     MOV #0x10A4, W2
000C30  784112     MOV.B [W2], W2
000C32  FB8102     ZE W2, W2
000C34  210A53     MOV #0x10A5, W3
000C36  784193     MOV.B [W3], W3
000C38  DD19C8     SL W3, #8, W3
000C3A  FB8280     ZE W0, W5
000C3C  420285     ADD W4, W5, W5
000C3E  718102     IOR W3, W2, W2
000C40  785915     MOV.B [W5], [W2++]
000C42  210A43     MOV #0x10A4, W3
000C44  784193     MOV.B [W3], W3
000C46  FD0100     EXCH W0, W2
000C48  B7F0A4     MOV.B WREG, outPipes
000C4A  FD0100     EXCH W0, W2
000C4C  DE1148     LSR W2, #8, W2
000C4E  210A53     MOV #0x10A5, W3
000C50  784193     MOV.B [W3], W3
000C52  FD0100     EXCH W0, W2
000C54  B7F0A5     MOV.B WREG, 0x10A5
000C56  FD0100     EXCH W0, W2
2043:                  }//end while(byteToRead.Val)
2044:              
2045:                  //If there is more data to receive, prepare EP0 OUT so that it can receive 
2046:              	//the next packet in the sequence.
2047:                  if(outPipes[0].wCount.Val > 0)
000C5E  210A71     MOV #0x10A7, W1
000C60  784091     MOV.B [W1], W1
000C62  FB8081     ZE W1, W1
000C64  BFD0A8     MOV.B 0x10A8, WREG
000C66  DD0048     SL W0, #8, W0
000C68  700081     IOR W0, W1, W1
000C6A  8085B0     MOV pBDTEntryEP0OutNext, W0
000C6C  32001D     BRA Z, 0xCA8
2048:                  {
2049:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000C6E  9040A0     MOV.B [W0+2], W1
000C70  B3C081     MOV #0x8, W1
000C72  984021     MOV.B W1, [W0+2]
000C74  904130     MOV.B [W0+3], W2
000C76  B3CFC1     MOV #0xFC, W1
000C78  614081     AND.B W2, W1, W1
000C7A  984031     MOV.B W1, [W0+3]
2050:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000C7C  210D41     MOV #0x10D4, W1
000C7E  904140     MOV.B [W0+4], W2
000C80  984041     MOV.B W1, [W0+4]
000C82  DE08C8     LSR W1, #8, W1
000C84  904150     MOV.B [W0+5], W2
000C86  984051     MOV.B W1, [W0+5]
2051:                      if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
000C88  8085A1     MOV pBDTEntryEP0OutCurrent, W1
000C8A  B3C402     MOV #0x40, W2
000C8C  614091     AND.B W2, [W1], W1
000C8E  3A0005     BRA NZ, 0xC9A
2052:                      {
2053:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000C90  784110     MOV.B [W0], W2
000C92  B3CC82     MOV #0xC8, W2
000C94  784802     MOV.B W2, [W0]
000C96  904110     MOV.B [W0+1], W2
000C98  370005     BRA 0xCA4
2054:                      }
2055:                      else
2056:                      {
2057:                          pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
000C9A  784090     MOV.B [W0], W1
000C9C  B3C881     MOV #0x88, W1
000C9E  784801     MOV.B W1, [W0]
000CA0  904090     MOV.B [W0+1], W1
000CA2  EB4080     CLR.B W1
000CA4  984011     MOV.B W1, [W0+1]
000CA6  370025     BRA 0xCF2
2058:                      }
2059:                  }
2060:                  else
2061:                  {
2062:              	    //We have received all OUT packets that we were expecting to
2063:              	    //receive for the control transfer.  Prepare EP0 OUT to receive
2064:              		//the next SETUP transaction that may arrive.
2065:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000CA8  904120     MOV.B [W0+2], W2
000CAA  B3C082     MOV #0x8, W2
000CAC  984022     MOV.B W2, [W0+2]
000CAE  9041B0     MOV.B [W0+3], W3
000CB0  B3CFC2     MOV #0xFC, W2
000CB2  61C102     AND.B W3, W2, W2
000CB4  984032     MOV.B W2, [W0+3]
2066:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000CB6  210CC2     MOV #0x10CC, W2
000CB8  9041C0     MOV.B [W0+4], W3
000CBA  984042     MOV.B W2, [W0+4]
000CBC  DE1148     LSR W2, #8, W2
000CBE  9041D0     MOV.B [W0+5], W3
000CC0  984052     MOV.B W2, [W0+5]
2067:                      //Configure EP0 OUT to receive the next SETUP transaction for any future
2068:                      //control transfers.  However, set BSTALL in case the host tries to send
2069:                      //more data than it claims it was going to send.
2070:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
000CC2  784110     MOV.B [W0], W2
000CC4  B3C842     MOV #0x84, W2
000CC6  784802     MOV.B W2, [W0]
000CC8  904110     MOV.B [W0+1], W2
000CCA  984011     MOV.B W1, [W0+1]
2071:              
2072:              		//All data bytes for the host to device control write (OUT) have now been
2073:              		//received successfully.
2074:              		//Go ahead and call the user specified callback function, to use/consume
2075:              		//the control transfer data (ex: if the "void (*function)" parameter 
2076:              		//was non-NULL when USBEP0Receive() was called).
2077:                      if(outPipes[0].pFunc != NULL)
000CCC  BFD0A9     MOV.B 0x10A9, WREG
000CCE  FB8000     ZE W0, W0
000CD0  210AA1     MOV #0x10AA, W1
000CD2  784091     MOV.B [W1], W1
000CD4  DD08C8     SL W1, #8, W1
000CD6  708000     IOR W1, W0, W0
000CD8  320007     BRA Z, 0xCE8
2078:                      {
2079:                          #if defined(__XC8)
2080:                              //Special pragmas to suppress an expected/harmless warning
2081:                              //message when building with the XC8 compiler
2082:                              #pragma warning push
2083:                              #pragma warning disable 1088
2084:                              outPipes[0].pFunc();    //Call the user's callback function
2085:                              #pragma warning pop
2086:                          #else
2087:                              outPipes[0].pFunc();    //Call the user's callback function
000CDA  BFD0A9     MOV.B 0x10A9, WREG
000CDC  FB8000     ZE W0, W0
000CDE  210AA1     MOV #0x10AA, W1
000CE0  784091     MOV.B [W1], W1
000CE2  DD08C8     SL W1, #8, W1
000CE4  708000     IOR W1, W0, W0
000CE6  010000     CALL W0
2088:                          #endif
2089:                      }
2090:                      outPipes[0].info.bits.busy = 0;    
000CE8  A9F0A6     BCLR 0x10A6, #7
2091:              
2092:                      //Ready to arm status stage IN transaction now, if the application
2093:                      //firmware has completed processing the request.  If it is still busy
2094:                      //and needs more time to finish handling the request, then the user
2095:                      //callback (the one called by the outPipes[0].pFunc();) should set the
2096:                      //USBDeferStatusStagePacket to TRUE (by calling USBDeferStatusStage()).  In 
2097:                      //this case, it is the application's firmware responsibility to call 
2098:                      //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
2099:                      //Note: The application firmware must process the request and call
2100:                      //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
2101:                      //means either 50ms, 500ms, or 5 seconds, depending on the type of
2102:                      //control transfer.  See the USB 2.0 specification section 9.2.6 for
2103:                      //more details.
2104:                      if(USBDeferStatusStagePacket == FALSE)
000CEA  808460     MOV USBDeferStatusStagePacket, W0
000CEC  500FE0     SUB W0, #0x0, [W15]
000CEE  3A0001     BRA NZ, 0xCF2
2105:                      {
2106:                          USBCtrlEPAllowStatusStage();
000CF0  07FF3A     RCALL USBCtrlEPAllowStatusStage
2107:                      }            
2108:                  }    
2109:              
2110:              }//end USBCtrlTrfRxService
000CF2  FA8000     ULNK
000CF4  060000     RETURN
2111:              
2112:              
2113:              /********************************************************************
2114:               * Function:        void USBStdSetCfgHandler(void)
2115:               *
2116:               * PreCondition:    None
2117:               *
2118:               * Input:           None
2119:               *
2120:               * Output:          None
2121:               *
2122:               * Side Effects:    None
2123:               *
2124:               * Overview:        This routine first disables all endpoints by
2125:               *                  clearing UEP registers. It then configures
2126:               *                  (initializes) endpoints by calling the callback
2127:               *                  function USBCBInitEP().
2128:               *
2129:               * Note:            None
2130:               *******************************************************************/
2131:              static void USBStdSetCfgHandler(void)
2132:              {
000794  FA0000     LNK #0x0
000796  781F88     MOV W8, [W15++]
2133:                  BYTE i;
2134:              
2135:                  // This will generate a zero length packet
2136:                  inPipes[0].info.bits.busy = 1;            
000798  A8F092     BSET 0x1092, #7
2137:              
2138:                  //Clear all of the endpoint control registers
2139:                  DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
00079A  EF24E2     CLR U1EP1
00079C  EF24E4     CLR U1EP2
2140:              
2141:                  //Clear all of the BDT entries
2142:                  memset((void*)&BDT[0], 0x00, sizeof(BDT));
00079E  212008     MOV #0x1200, W8
0007A0  200602     MOV #0x60, W2
0007A2  EB0080     CLR W1
0007A4  780008     MOV W8, W0
0007A6  07FD92     RCALL _memset
2143:              
2144:                  // Assert reset request to all of the Ping Pong buffer pointers
2145:                  USBPingPongBufferReset = 1;                                   
0007A8  A824CA     BSET U1CON, #1
2146:              
2147:              	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
2148:              	//the EVEN buffer being the next one that will be used), since we are also 
2149:              	//doing a hardware ping pong pointer reset above.
2150:              	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
2151:              	{
2152:              		ep_data_in[i].Val = 0u;
0007AA  EF70C0     CLR.B ep_data_in
0007AE  EF70C1     CLR.B 0x10C1
0007B2  EF70C2     CLR.B 0x10C2
2153:                      ep_data_out[i].Val = 0u;
0007AC  EF70C3     CLR.B ep_data_out
0007B0  EF70C4     CLR.B 0x10C4
0007B4  EF70C5     CLR.B 0x10C5
2154:              	}
2155:              
2156:                  //clear the alternate interface settings
2157:                  memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0007B6  200022     MOV #0x2, W2
0007B8  EB0080     CLR W1
0007BA  210B20     MOV #0x10B2, W0
0007BC  07FD87     RCALL _memset
2158:              
2159:                  //Stop trying to reset ping pong buffer pointers
2160:                  USBPingPongBufferReset = 0;
0007BE  A924CA     BCLR U1CON, #1
2161:              
2162:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0007C0  440070     ADD W8, #0x10, W0
0007C2  888560     MOV W0, pBDTEntryIn
2163:              
2164:              	//Set the next out to the current out packet
2165:                  pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0007C4  8885A8     MOV W8, pBDTEntryEP0OutCurrent
2166:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0007C6  8885B8     MOV W8, pBDTEntryEP0OutNext
2167:              
2168:                  //set the current configuration
2169:                  USBActiveConfiguration = SetupPkt.bConfigurationValue;
0007C8  BFD0CE     MOV.B 0x10CE, WREG
0007CA  B7F09C     MOV.B WREG, USBActiveConfiguration
2170:              
2171:                  //if the configuration value == 0
2172:                  if(USBActiveConfiguration == 0)
0007CC  BFD09C     MOV.B USBActiveConfiguration, WREG
0007CE  3A0002     BRA NZ, 0x7D4
2173:                  {
2174:                      //Go back to the addressed state
2175:                      USBDeviceState = ADDRESS_STATE;
0007D0  200100     MOV #0x10, W0
0007D2  370005     BRA 0x7DE
2176:                  }
2177:                  else
2178:                  {
2179:                      //initialize the required endpoints
2180:                      USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0007D4  200012     MOV #0x1, W2
0007D6  2109C1     MOV #0x109C, W1
0007D8  200010     MOV #0x1, W0
0007DA  070692     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2181:              
2182:                      //Otherwise go to the configured state.  Update the state variable last,
2183:                      //after performing all of the set configuration related initialization
2184:                      //tasks.
2185:                      USBDeviceState = CONFIGURED_STATE;		
0007DC  200200     MOV #0x20, W0
0007DE  8884D0     MOV W0, USBDeviceState
2186:                  }//end if(SetupPkt.bConfigurationValue == 0)
2187:              }//end USBStdSetCfgHandler
0007E0  78044F     MOV [--W15], W8
0007E2  FA8000     ULNK
0007E4  060000     RETURN
2188:              
2189:              
2190:              /********************************************************************
2191:               * Function:        void USBStdGetDscHandler(void)
2192:               *
2193:               * PreCondition:    None
2194:               *
2195:               * Input:           None
2196:               *
2197:               * Output:          None
2198:               *
2199:               * Side Effects:    None
2200:               *
2201:               * Overview:        This routine handles the standard GET_DESCRIPTOR
2202:               *                  request.
2203:               *
2204:               * Note:            None
2205:               *******************************************************************/
2206:              static void USBStdGetDscHandler(void)
2207:              {
000454  FA0000     LNK #0x0
2208:                  if(SetupPkt.bmRequestType == 0x80)
000456  210CC1     MOV #0x10CC, W1
000458  784091     MOV.B [W1], W1
00045A  B3C800     MOV #0x80, W0
00045C  50CF80     SUB.B W1, W0, [W15]
00045E  3A002F     BRA NZ, 0x4BE
2209:                  {
2210:                      inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
000460  B3CC00     MOV #0xC0, W0
000462  B7F092     MOV.B WREG, 0x1092
2211:              
2212:                      switch(SetupPkt.bDescriptorType)
000464  BFD0CF     MOV.B 0x10CF, WREG
000466  504FE2     SUB.B W0, #0x2, [W15]
000468  320008     BRA Z, 0x47A
00046A  504FE3     SUB.B W0, #0x3, [W15]
00046C  320018     BRA Z, 0x49E
00046E  504FE1     SUB.B W0, #0x1, [W15]
000470  3A0025     BRA NZ, 0x4BC
2213:                      {
2214:                          case USB_DESCRIPTOR_DEVICE:
2215:                              #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2216:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc;
2217:                              #else
2218:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
000472  282E00     MOV #0x82E0, W0
000474  888480     MOV W0, inPipes
2219:                              #endif
2220:                              inPipes[0].wCount.Val = sizeof(device_dsc);
000476  200120     MOV #0x12, W0
000478  37001F     BRA 0x4B8
2221:                              break;
2222:                          case USB_DESCRIPTOR_CONFIGURATION:
2223:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2224:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2225:                              #else
2226:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
00047A  BFD0CE     MOV.B 0x10CE, WREG
00047C  FB8000     ZE W0, W0
00047E  400000     ADD W0, W0, W0
000480  283AC1     MOV #0x83AC, W1
000482  408000     ADD W1, W0, W0
000484  780010     MOV [W0], W0
000486  888480     MOV W0, inPipes
2227:                              #endif
2228:              
2229:                              //This must be loaded using byte addressing.  The source pointer
2230:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2231:                              //  in an address error on the dereference.
2232:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
000488  808480     MOV inPipes, W0
00048A  781F80     MOV W0, [W15++]
00048C  904020     MOV.B [W0+2], W0
00048E  B7F094     MOV.B WREG, 0x1094
000490  78004F     MOV [--W15], W0
2233:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
000492  808480     MOV inPipes, W0
000494  781F80     MOV W0, [W15++]
000496  904030     MOV.B [W0+3], W0
000498  B7F095     MOV.B WREG, 0x1095
00049A  78004F     MOV [--W15], W0
2234:                              break;
00049C  370010     BRA 0x4BE
2235:                          case USB_DESCRIPTOR_STRING:
2236:                              //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2237:                              //  later it is now manditory.  This should be defined in usb_config.h and should
2238:                              //  indicate the number of string descriptors.
2239:                              if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
00049E  BFD0CE     MOV.B 0x10CE, WREG
0004A0  504FE2     SUB.B W0, #0x2, [W15]
0004A2  3E000C     BRA GTU, 0x4BC
2240:                              {
2241:                                  //Get a pointer to the String descriptor requested
2242:                                  inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0004A4  BFD0CE     MOV.B 0x10CE, WREG
0004A6  FB8000     ZE W0, W0
0004A8  400000     ADD W0, W0, W0
0004AA  283AE1     MOV #0x83AE, W1
0004AC  408000     ADD W1, W0, W0
0004AE  780010     MOV [W0], W0
0004B0  888480     MOV W0, inPipes
2243:                                  // Set data count
2244:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
0004B2  808480     MOV inPipes, W0
0004B4  784010     MOV.B [W0], W0
0004B6  FB8000     ZE W0, W0
0004B8  8884A0     MOV W0, 0x1094
0004BA  370001     BRA 0x4BE
2245:                              }
2246:                              #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2247:                              else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2248:                              {
2249:                                  //Get a pointer to the special MS OS string descriptor requested
2250:                                  inPipes[0].pSrc.bRom = (ROM BYTE*)&MSOSDescriptor;
2251:                                  // Set data count
2252:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2253:                              }    
2254:                              #endif
2255:                              else
2256:                              {
2257:                                  inPipes[0].info.Val = 0;
2258:                              }
2259:                              break;
2260:                          default:
2261:                              inPipes[0].info.Val = 0;
0004BC  EF7092     CLR.B 0x1092
2262:                              break;
2263:                      }//end switch
2264:                  }//end if
2265:              }//end USBStdGetDscHandler
0004BE  FA8000     ULNK
0004C0  060000     RETURN
2266:              
2267:              /********************************************************************
2268:               * Function:        void USBStdGetStatusHandler(void)
2269:               *
2270:               * PreCondition:    None
2271:               *
2272:               * Input:           None
2273:               *
2274:               * Output:          None
2275:               *
2276:               * Side Effects:    None
2277:               *
2278:               * Overview:        This routine handles the standard GET_STATUS request
2279:               *
2280:               * Note:            None
2281:               *******************************************************************/
2282:              static void USBStdGetStatusHandler(void)
2283:              {
0004C2  FA0000     LNK #0x0
2284:                  CtrlTrfData[0] = 0;                 // Initialize content
0004C4  EF70D4     CLR.B CtrlTrfData
2285:                  CtrlTrfData[1] = 0;
0004C6  EF70D5     CLR.B 0x10D5
2286:              
2287:                  switch(SetupPkt.Recipient)
0004C8  BFD0CC     MOV.B SetupPkt, WREG
0004CA  60007F     AND W0, #0x1F, W0
0004CC  500FE1     SUB W0, #0x1, [W15]
0004CE  32000B     BRA Z, 0x4E6
0004D0  500FE2     SUB W0, #0x2, [W15]
0004D2  32000B     BRA Z, 0x4EA
0004D4  500FE0     SUB W0, #0x0, [W15]
0004D6  3A001D     BRA NZ, 0x512
2288:                  {
2289:                      case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2290:                          inPipes[0].info.bits.busy = 1;
0004D8  A8F092     BSET 0x1092, #7
2291:                          /*
2292:                           * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2293:                           *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2294:                           */
2295:                          if(self_power == 1) // self_power is defined in HardwareProfile.h
2296:                          {
2297:                              CtrlTrfData[0]|=0x01;
0004DA  A810D4     BSET CtrlTrfData, #0
2298:                          }
2299:              
2300:                          if(RemoteWakeup == TRUE)
0004DC  8084B0     MOV RemoteWakeup, W0
0004DE  500FE1     SUB W0, #0x1, [W15]
0004E0  3A0018     BRA NZ, 0x512
2301:                          {
2302:                              CtrlTrfData[0]|=0x02;
0004E2  A830D4     BSET CtrlTrfData, #1
0004E4  370016     BRA 0x512
2303:                          }
2304:                          break;
2305:                      case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2306:                          inPipes[0].info.bits.busy = 1;     // No data to update
0004E6  A8F092     BSET 0x1092, #7
2307:                          break;
0004E8  370014     BRA 0x512
2308:                      case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2309:                          inPipes[0].info.bits.busy = 1;
0004EA  A8F092     BSET 0x1092, #7
2310:                          /*
2311:                           * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2312:                           */
2313:                          {
2314:                              BDT_ENTRY *p;
2315:              
2316:                              if(SetupPkt.EPDir == 0)
0004EC  BFD0D0     MOV.B 0x10D0, WREG
0004EE  330005     BRA N, 0x4FA
2317:                              {
2318:                                  p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0004F0  BFD0D0     MOV.B 0x10D0, WREG
0004F2  60006F     AND W0, #0xF, W0
0004F4  400000     ADD W0, W0, W0
0004F6  2109E1     MOV #0x109E, W1
0004F8  370004     BRA 0x502
2319:                              }
2320:                              else
2321:                              {
2322:                                  p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0004FA  BFD0D0     MOV.B 0x10D0, WREG
0004FC  60006F     AND W0, #0xF, W0
0004FE  400000     ADD W0, W0, W0
000500  210AC1     MOV #0x10AC, W1
000502  408000     ADD W1, W0, W0
000504  780090     MOV [W0], W1
2323:                              }
2324:              
2325:                              if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
000506  B3C840     MOV #0x84, W0
000508  604091     AND.B W0, [W1], W1
00050A  50CF80     SUB.B W1, W0, [W15]
00050C  3A0002     BRA NZ, 0x512
2326:                                  CtrlTrfData[0]=0x01;    // Set bit0
00050E  B3C010     MOV #0x1, W0
000510  B7F0D4     MOV.B WREG, CtrlTrfData
2327:                              break;
2328:                          }
2329:                  }//end switch
2330:              
2331:                  if(inPipes[0].info.bits.busy == 1)
000512  ABF092     BTST 0x1092, #7
000514  320005     BRA Z, 0x520
2332:                  {
2333:                      inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
000516  210D40     MOV #0x10D4, W0
000518  888480     MOV W0, inPipes
2334:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
00051A  A81092     BSET 0x1092, #0
2335:                      inPipes[0].wCount.v[0] = 2;                         // Set data count
00051C  B3C020     MOV #0x2, W0
00051E  B7F094     MOV.B WREG, 0x1094
2336:                  }//end if(...)
2337:              }//end USBStdGetStatusHandler
000520  FA8000     ULNK
000522  060000     RETURN
2338:              
2339:              /********************************************************************
2340:               * Function:        void USBStallHandler(void)
2341:               *
2342:               * PreCondition:    None
2343:               *
2344:               * Input:           None
2345:               *
2346:               * Output:          None
2347:               *
2348:               * Side Effects:    
2349:               *
2350:               * Overview:        This function handles the event of a STALL 
2351:               *                  occuring on the bus
2352:               *
2353:               * Note:            None
2354:               *******************************************************************/
2355:              static void USBStallHandler(void)
2356:              {
000524  FA0000     LNK #0x0
2357:                  /*
2358:                   * Does not really have to do anything here,
2359:                   * even for the control endpoint.
2360:                   * All BDs of Endpoint 0 are owned by SIE right now,
2361:                   * but once a Setup Transaction is received, the ownership
2362:                   * for EP0_OUT will be returned to CPU.
2363:                   * When the Setup Transaction is serviced, the ownership
2364:                   * for EP0_IN will then be forced back to CPU by firmware.
2365:                   */
2366:              
2367:                  /* v2b fix */
2368:                  if(U1EP0bits.EPSTALL == 1)
000526  AB24E0     BTST U1EP0, #1
000528  320019     BRA Z, 0x55C
2369:                  {
2370:                      // UOWN - if 0, owned by CPU, if 1, owned by SIE
2371:                      if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
00052A  8085A0     MOV pBDTEntryEP0OutCurrent, W0
00052C  784090     MOV.B [W0], W1
00052E  FB8101     ZE W1, W2
000530  904090     MOV.B [W0+1], W1
000532  DD08C8     SL W1, #8, W1
000534  708082     IOR W1, W2, W1
000536  200802     MOV #0x80, W2
000538  508F82     SUB W1, W2, [W15]
00053A  3A000F     BRA NZ, 0x55A
00053C  808561     MOV pBDTEntryIn, W1
00053E  784191     MOV.B [W1], W3
000540  FB8103     ZE W3, W2
000542  904091     MOV.B [W1+1], W1
000544  DD08C8     SL W1, #8, W1
000546  708082     IOR W1, W2, W1
000548  200842     MOV #0x84, W2
00054A  508F82     SUB W1, W2, [W15]
00054C  3A0006     BRA NZ, 0x55A
2372:                      {
2373:                          // Set ep0Bo to stall also
2374:                          pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
00054E  784090     MOV.B [W0], W1
000550  B3C8C1     MOV #0x8C, W1
000552  784801     MOV.B W1, [W0]
000554  904090     MOV.B [W0+1], W1
000556  EB4080     CLR.B W1
000558  984011     MOV.B W1, [W0+1]
2375:                      }//end if
2376:                      U1EP0bits.EPSTALL = 0;               // Clear stall status
00055A  A924E0     BCLR U1EP0, #1
2377:                  }//end if
2378:              
2379:                  USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
00055C  200800     MOV #0x80, W0
00055E  882600     MOV W0, U1IR
2380:              }
000560  FA8000     ULNK
000562  060000     RETURN
2381:              
2382:              /********************************************************************
2383:               * Function:        void USBSuspend(void)
2384:               *
2385:               * PreCondition:    None
2386:               *
2387:               * Input:           None
2388:               *
2389:               * Output:          None
2390:               *
2391:               * Side Effects:    
2392:               *
2393:               * Overview:        This function handles if the host tries to 
2394:               *                  suspend the device
2395:               *
2396:               * Note:            None
2397:               *******************************************************************/
2398:              static void USBSuspend(void)
2399:              {
000612  FA0000     LNK #0x0
2400:                  /*
2401:                   * NOTE: Do not clear UIRbits.ACTVIF here!
2402:                   * Reason:
2403:                   * ACTVIF is only generated once an IDLEIF has been generated.
2404:                   * This is a 1:1 ratio interrupt generation.
2405:                   * For every IDLEIF, there will be only one ACTVIF regardless of
2406:                   * the number of subsequent bus transitions.
2407:                   *
2408:                   * If the ACTIF is cleared here, a problem could occur when:
2409:                   * [       IDLE       ][bus activity ->
2410:                   * <--- 3 ms ----->     ^
2411:                   *                ^     ACTVIF=1
2412:                   *                IDLEIF=1
2413:                   *  #           #           #           #   (#=Program polling flags)
2414:                   *                          ^
2415:                   *                          This polling loop will see both
2416:                   *                          IDLEIF=1 and ACTVIF=1.
2417:                   *                          However, the program services IDLEIF first
2418:                   *                          because ACTIVIE=0.
2419:                   *                          If this routine clears the only ACTIVIF,
2420:                   *                          then it can never get out of the suspend
2421:                   *                          mode.
2422:                   */
2423:                  USBActivityIE = 1;                     // Enable bus activity interrupt
000614  A8848A     BSET U1OTGIE, #4
2424:                  USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
000616  200100     MOV #0x10, W0
000618  882600     MOV W0, U1IR
2425:              
2426:                  #if defined(__18CXX) || defined(_PIC14E)
2427:                      U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
2428:                                                              // mode, SIE clock inactive
2429:                  #endif
2430:                  USBBusIsSuspended = TRUE;
00061A  200010     MOV #0x1, W0
00061C  8884C0     MOV W0, USBBusIsSuspended
2431:               
2432:                  /*
2433:                   * At this point the PIC can go into sleep,idle, or
2434:                   * switch to a slower clock, etc.  This should be done in the
2435:                   * USBCBSuspend() if necessary.
2436:                   */
2437:                  USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
00061E  EB0100     CLR W2
000620  EB0080     CLR W1
000622  200750     MOV #0x75, W0
000624  07076D     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2438:              }
000626  FA8000     ULNK
000628  060000     RETURN
2439:              
2440:              /********************************************************************
2441:               * Function:        void USBWakeFromSuspend(void)
2442:               *
2443:               * PreCondition:    None
2444:               *
2445:               * Input:           None
2446:               *
2447:               * Output:          None
2448:               *
2449:               * Side Effects:    None
2450:               *
2451:               * Overview:
2452:               *
2453:               * Note:            None
2454:               *******************************************************************/
2455:              static void USBWakeFromSuspend(void)
2456:              {
0005FC  FA0000     LNK #0x0
2457:                  USBBusIsSuspended = FALSE;
0005FE  EB0100     CLR W2
000600  8884C2     MOV W2, USBBusIsSuspended
2458:              
2459:                  /*
2460:                   * If using clock switching, the place to restore the original
2461:                   * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2462:                   */
2463:                  USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
000602  780082     MOV W2, W1
000604  200740     MOV #0x74, W0
000606  07077C     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2464:              
2465:                  #if defined(__18CXX) || defined(_PIC14E)
2466:                      //To avoid improperly clocking the USB module, make sure the oscillator
2467:                      //settings are consistant with USB operation before clearing the SUSPND bit.
2468:                      //Make sure the correct oscillator settings are selected in the 
2469:                      //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2470:                      U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
2471:                                              // mode.
2472:                  #endif
2473:              
2474:              
2475:                  USBActivityIE = 0;
000608  A9848A     BCLR U1OTGIE, #4
2476:              
2477:                  /********************************************************************
2478:                  Bug Fix: Feb 26, 2007 v2.1
2479:                  *********************************************************************
2480:                  The ACTVIF bit cannot be cleared immediately after the USB module wakes
2481:                  up from Suspend or while the USB module is suspended. A few clock cycles
2482:                  are required to synchronize the internal hardware state machine before
2483:                  the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2484:                  before the internal hardware is synchronized may not have an effect on
2485:                  the value of ACTVIF. Additonally, if the USB module uses the clock from
2486:                  the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2487:                  module may not be immediately operational while waiting for the 96 MHz
2488:                  PLL to lock.
2489:                  ********************************************************************/
2490:              
2491:                  // UIRbits.ACTVIF = 0;                      // Removed
2492:                  #if defined(__18CXX)
2493:                  while(USBActivityIF)
2494:                  #endif
2495:                  {
2496:                      USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
00060A  200100     MOV #0x10, W0
00060C  882440     MOV W0, U1OTGIR
2497:                  }  // Added
2498:              
2499:              }//end USBWakeFromSuspend
00060E  FA8000     ULNK
000610  060000     RETURN
2500:              
2501:              /********************************************************************
2502:               * Function:        void USBCtrlEPService(void)
2503:               *
2504:               * PreCondition:    USTAT is loaded with a valid endpoint address.
2505:               *
2506:               * Input:           None
2507:               *
2508:               * Output:          None
2509:               *
2510:               * Side Effects:    None
2511:               *
2512:               * Overview:        USBCtrlEPService checks for three transaction
2513:               *                  types that it knows how to service and services
2514:               *                  them:
2515:               *                  1. EP0 SETUP
2516:               *                  2. EP0 OUT
2517:               *                  3. EP0 IN
2518:               *                  It ignores all other types (i.e. EP1, EP2, etc.)
2519:               *
2520:               * Note:            None
2521:               *******************************************************************/
2522:              static void USBCtrlEPService(void)
2523:              {
000EE2  FA0000     LNK #0x0
2524:                  //If we get to here, that means a successful transaction has just occurred 
2525:                  //on EP0.  This means "progress" has occurred in the currently pending 
2526:                  //control transfer, so we should re-initialize our timeout counter.
2527:                  #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2528:                      USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
000EE4  B3C2D0     MOV #0x2D, W0
000EE6  B7F0C6     MOV.B WREG, USBStatusStageTimeoutCounter
2529:                  #endif
2530:              	
2531:              	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2532:                  if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
000EE8  210BC1     MOV #0x10BC, W1
000EEA  784091     MOV.B [W1], W1
000EEC  B20FB1     AND #0xFB, W1
000EEE  3A002E     BRA NZ, 0xF4C
2533:                  {
2534:              		//Point to the EP0 OUT buffer of the buffer that arrived
2535:                      #if defined (_PIC14E) || defined(__18CXX)
2536:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
2537:                      #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2538:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
000EF0  BFD0BC     MOV.B USTATcopy, WREG
000EF2  FB8200     ZE W0, W4
000EF4  DE2242     LSR W4, #2, W4
000EF6  DD2143     SL W4, #3, W2
000EF8  212000     MOV #0x1200, W0
000EFA  410000     ADD W2, W0, W0
000EFC  8885A0     MOV W0, pBDTEntryEP0OutCurrent
2539:                      #else
2540:                          #error "unimplemented"
2541:                      #endif
2542:              
2543:              		//Set the next out to the current out packet
2544:                      pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
000EFE  8885B0     MOV W0, pBDTEntryEP0OutNext
2545:              		//Toggle it to the next ping pong buffer (if applicable)
2546:                      ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
000F00  AA70B6     BTG pBDTEntryEP0OutNext, #3
2547:              
2548:              		//If the current EP0 OUT buffer has a SETUP packet
2549:                      if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
000F02  B3C3C2     MOV #0x3C, W2
000F04  614190     AND.B W2, [W0], W3
000F06  514168     SUB.B W2, #0x8, W2
000F08  51CF82     SUB.B W3, W2, [W15]
000F0A  3A001E     BRA NZ, 0xF48
2550:                      {
2551:                          unsigned char setup_cnt;
2552:              
2553:              	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2554:              	        //buffer, or elsewhere, depending upon how the BDT was prepared
2555:              	        //before the transaction.  Therefore, we should copy the data to the 
2556:              	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2557:                          for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
000F34  E84081     INC.B W1, W1
000F36  50CFE7     SUB.B W1, #0x7, [W15]
000F38  36FFEA     BRA LEU, 0xF0E
2558:                          {
2559:                              *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
000F0C  210CC5     MOV #0x10CC, W5
000F0E  904140     MOV.B [W0+4], W2
000F10  FB8102     ZE W2, W2
000F12  9041D0     MOV.B [W0+5], W3
000F14  DD19C8     SL W3, #8, W3
000F16  718102     IOR W3, W2, W2
000F18  FB8301     ZE W1, W6
000F1A  428306     ADD W5, W6, W6
000F1C  784B12     MOV.B [W2], [W6]
2560:                              pBDTEntryEP0OutCurrent->ADR++;
000F1E  904140     MOV.B [W0+4], W2
000F20  FB8102     ZE W2, W2
000F22  9041D0     MOV.B [W0+5], W3
000F24  DD19C8     SL W3, #8, W3
000F26  718102     IOR W3, W2, W2
000F28  E80102     INC W2, W2
000F2A  9041C0     MOV.B [W0+4], W3
000F2C  984042     MOV.B W2, [W0+4]
000F2E  DE1148     LSR W2, #8, W2
000F30  9041D0     MOV.B [W0+5], W3
000F32  984052     MOV.B W2, [W0+5]
2561:                          }    
2562:                          pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
000F3A  DD2243     SL W4, #3, W4
000F3C  212040     MOV #0x1204, W0
000F3E  400204     ADD W0, W4, W4
000F40  210CC0     MOV #0x10CC, W0
000F42  780A00     MOV W0, [W4]
2563:              
2564:              			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2565:                          USBCtrlTrfSetupHandler();
000F44  07FF86     RCALL _USBCtrlTrfSetupHandler
000F46  370007     BRA 0xF56
2566:                      }
2567:                      else
2568:                      {
2569:              			//Handle the DATA transfer
2570:                          USBCtrlTrfOutHandler();
000F48  07FED6     RCALL _USBCtrlTrfOutHandler
000F4A  370005     BRA 0xF56
2571:                      }
2572:                  }
2573:                  else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
000F4C  BFD0BC     MOV.B USTATcopy, WREG
000F4E  B20FB0     AND #0xFB, W0
000F50  500FE8     SUB W0, #0x8, [W15]
000F52  3A0001     BRA NZ, 0xF56
2574:                  {
2575:              		//Otherwise the transmission was and EP0 IN
2576:              		//  so take care of the IN transfer
2577:                      USBCtrlTrfInHandler();
000F54  07FB07     RCALL _USBCtrlTrfInHandler
2578:                  }
2579:              
2580:              }//end USBCtrlEPService
000F56  FA8000     ULNK
000F58  060000     RETURN
2581:              
2582:              /********************************************************************
2583:               * Function:        void USBCtrlTrfSetupHandler(void)
2584:               *
2585:               * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2586:               *
2587:               * Input:           None
2588:               *
2589:               * Output:          None
2590:               *
2591:               * Side Effects:    None
2592:               *
2593:               * Overview:        This routine is a task dispatcher and has 3 stages.
2594:               *                  1. It initializes the control transfer state machine.
2595:               *                  2. It calls on each of the module that may know how to
2596:               *                     service the Setup Request from the host.
2597:               *                     Module Example: USBD, HID, CDC, MSD, ...
2598:               *                     A callback function, USBCBCheckOtherReq(),
2599:               *                     is required to call other module handlers.
2600:               *                  3. Once each of the modules has had a chance to check if
2601:               *                     it is responsible for servicing the request, stage 3
2602:               *                     then checks direction of the transfer to determine how
2603:               *                     to prepare EP0 for the control transfer.
2604:               *                     Refer to USBCtrlEPServiceComplete() for more details.
2605:               *
2606:               * Note:            Microchip USB Firmware has three different states for
2607:               *                  the control transfer state machine:
2608:               *                  1. WAIT_SETUP
2609:               *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2610:               *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2611:               *                  Refer to firmware manual to find out how one state
2612:               *                  is transitioned to another.
2613:               *
2614:               *                  A Control Transfer is composed of many USB transactions.
2615:               *                  When transferring data over multiple transactions,
2616:               *                  it is important to keep track of data source, data
2617:               *                  destination, and data count. These three parameters are
2618:               *                  stored in pSrc,pDst, and wCount. A flag is used to
2619:               *                  note if the data source is from ROM or RAM.
2620:               *
2621:               *******************************************************************/
2622:              static void USBCtrlTrfSetupHandler(void)
2623:              {
000E52  FA0000     LNK #0x0
000E54  781F88     MOV W8, [W15++]
2624:                  //--------------------------------------------------------------------------
2625:                  //1. Re-initialize state tracking variables related to control transfers.
2626:                  //--------------------------------------------------------------------------
2627:                  shortPacketStatus = SHORT_PKT_NOT_USED;  
000E56  EF70B8     CLR.B shortPacketStatus
2628:                  USBDeferStatusStagePacket = FALSE;
000E58  EB0400     CLR W8
000E5A  888468     MOV W8, USBDeferStatusStagePacket
2629:                  USBDeferINDataStagePackets = FALSE;
000E5C  888478     MOV W8, USBDeferINDataStagePackets
2630:                  USBDeferOUTDataStagePackets = FALSE;
000E5E  888458     MOV W8, USBDeferOUTDataStagePackets
2631:                  BothEP0OutUOWNsSet = FALSE;    
000E60  8885F8     MOV W8, BothEP0OutUOWNsSet
2632:                  controlTransferState = WAIT_SETUP;
000E62  780008     MOV W8, W0
000E64  B7F0B9     MOV.B WREG, controlTransferState
2633:              
2634:                  //Abandon any previous control transfers that might have been using EP0.
2635:                  //Ordinarily, nothing actually needs abandoning, since the previous control
2636:                  //transfer would have completed successfully prior to the host sending the next
2637:                  //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2638:                  //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2639:                  //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2640:                  //by the class request handler that will be called next.
2641:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
000E66  808560     MOV pBDTEntryIn, W0
000E68  784090     MOV.B [W0], W1
000E6A  FB8181     ZE W1, W3
000E6C  904090     MOV.B [W0+1], W1
000E6E  DD0948     SL W1, #8, W2
000E70  710103     IOR W2, W3, W2
000E72  2FF7F3     MOV #0xFF7F, W3
000E74  610103     AND W2, W3, W2
000E76  200FF1     MOV #0xFF, W1
000E78  784210     MOV.B [W0], W4
000E7A  614801     AND.B W2, W1, [W0]
000E7C  DE1148     LSR W2, #8, W2
000E7E  904210     MOV.B [W0+1], W4
000E80  984012     MOV.B W2, [W0+1]
2642:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
000E82  210AC2     MOV #0x10AC, W2
000E84  A23412     BTG.B [W2], #3
2643:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
000E86  808560     MOV pBDTEntryIn, W0
000E88  784210     MOV.B [W0], W4
000E8A  FB8304     ZE W4, W6
000E8C  904290     MOV.B [W0+1], W5
000E8E  DD2A48     SL W5, #8, W4
000E90  720206     IOR W4, W6, W4
000E92  620203     AND W4, W3, W4
000E94  784290     MOV.B [W0], W5
000E96  624801     AND.B W4, W1, [W0]
000E98  DE2248     LSR W4, #8, W4
000E9A  904290     MOV.B [W0+1], W5
000E9C  984014     MOV.B W4, [W0+1]
2644:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
000E9E  A23412     BTG.B [W2], #3
2645:                  pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
000EA0  8085B0     MOV pBDTEntryEP0OutNext, W0
000EA2  784110     MOV.B [W0], W2
000EA4  FB8202     ZE W2, W4
000EA6  904110     MOV.B [W0+1], W2
000EA8  DD1148     SL W2, #8, W2
000EAA  710104     IOR W2, W4, W2
000EAC  610183     AND W2, W3, W3
000EAE  784110     MOV.B [W0], W2
000EB0  61C801     AND.B W3, W1, [W0]
000EB2  DE19C8     LSR W3, #8, W3
000EB4  904090     MOV.B [W0+1], W1
000EB6  984013     MOV.B W3, [W0+1]
2646:              
2647:                  inPipes[0].info.Val = 0;
000EB8  780008     MOV W8, W0
000EBA  B7F092     MOV.B WREG, 0x1092
2648:                  inPipes[0].wCount.Val = 0;
000EBC  8884A8     MOV W8, 0x1094
2649:                  outPipes[0].info.Val = 0;
000EBE  780008     MOV W8, W0
000EC0  B7F0A6     MOV.B WREG, 0x10A6
2650:                  outPipes[0].wCount.Val = 0;
000EC2  BFD0A7     MOV.B 0x10A7, WREG
000EC4  780008     MOV W8, W0
000EC6  B7F0A7     MOV.B WREG, 0x10A7
000EC8  BFD0A8     MOV.B 0x10A8, WREG
000ECA  FD0400     EXCH W0, W8
000ECC  B7F0A8     MOV.B WREG, 0x10A8
000ECE  FD0400     EXCH W0, W8
2651:                  
2652:              
2653:                  //--------------------------------------------------------------------------
2654:                  //2. Now find out what was in the SETUP packet, and begin handling the request.
2655:                  //--------------------------------------------------------------------------
2656:                  USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
000ED0  07FC8A     RCALL _USBCheckStdRequest
2657:                  USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
000ED2  780108     MOV W8, W2
000ED4  780082     MOV W2, W1
000ED6  200030     MOV #0x3, W0
000ED8  070313     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2658:              
2659:              
2660:                  //--------------------------------------------------------------------------
2661:                  //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2662:                  //   progress.  If one of the above handlers (in step 2) knew how to process
2663:                  //   the request, it will have set one of the inPipes[0].info.bits.busy or
2664:                  //   outPipes[0].info.bits.busy flags = 1.  This lets the
2665:                  //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2666:                  //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2667:                  //   process the request.  In this case, the default behavior will be to
2668:                  //   perform protocol STALL on EP0.
2669:                  //-------------------------------------------------------------------------- 
2670:                  USBCtrlEPServiceComplete();
000EDA  07FF68     RCALL _USBCtrlEPServiceComplete
2671:              }//end USBCtrlTrfSetupHandler
000EDC  78044F     MOV [--W15], W8
000EDE  FA8000     ULNK
000EE0  060000     RETURN
2672:              
2673:              
2674:              /******************************************************************************
2675:               * Function:        void USBCtrlTrfOutHandler(void)
2676:               *
2677:               * PreCondition:    None
2678:               *
2679:               * Input:           None
2680:               *
2681:               * Output:          None
2682:               *
2683:               * Side Effects:    None
2684:               *
2685:               * Overview:        This routine handles an OUT transaction according to
2686:               *                  which control transfer state is currently active.
2687:               *
2688:               * Note:            Note that if the the control transfer was from
2689:               *                  host to device, the session owner should be notified
2690:               *                  at the end of each OUT transaction to service the
2691:               *                  received data.
2692:               *
2693:               *****************************************************************************/
2694:              static void USBCtrlTrfOutHandler(void)
2695:              {
000CF6  FA0000     LNK #0x0
2696:                  if(controlTransferState == CTRL_TRF_RX)
000CF8  BFD0B9     MOV.B controlTransferState, WREG
000CFA  504FE2     SUB.B W0, #0x2, [W15]
000CFC  3A0002     BRA NZ, 0xD02
2697:                  {
2698:                      USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
000CFE  07FF75     RCALL _USBCtrlTrfRxService
000D00  370019     BRA 0xD34
2699:                  }
2700:                  else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2701:                  {
2702:                      //If the status stage is complete, this means we are done with the 
2703:                      //control transfer.  Go back to the idle "WAIT_SETUP" state.
2704:                      controlTransferState = WAIT_SETUP;
000D02  EF70B9     CLR.B controlTransferState
2705:              
2706:              	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2707:              	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2708:              	    //and the last control transfer was of direction: device to host, see
2709:              	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2710:              	    //to do anything to the BDT.
2711:              		if(BothEP0OutUOWNsSet == FALSE)
000D04  8085F1     MOV BothEP0OutUOWNsSet, W1
000D06  508FE0     SUB W1, #0x0, [W15]
000D08  3A0014     BRA NZ, 0xD32
2712:              		{
2713:              	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000D0A  8085B0     MOV pBDTEntryEP0OutNext, W0
000D0C  904120     MOV.B [W0+2], W2
000D0E  B3C082     MOV #0x8, W2
000D10  984022     MOV.B W2, [W0+2]
000D12  9041B0     MOV.B [W0+3], W3
000D14  B3CFC2     MOV #0xFC, W2
000D16  61C102     AND.B W3, W2, W2
000D18  984032     MOV.B W2, [W0+3]
2714:              	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000D1A  210CC2     MOV #0x10CC, W2
000D1C  9041C0     MOV.B [W0+4], W3
000D1E  984042     MOV.B W2, [W0+4]
000D20  DE1148     LSR W2, #8, W2
000D22  9041D0     MOV.B [W0+5], W3
000D24  984052     MOV.B W2, [W0+5]
2715:              	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;			
000D26  784110     MOV.B [W0], W2
000D28  B3C8C2     MOV #0x8C, W2
000D2A  784802     MOV.B W2, [W0]
000D2C  904110     MOV.B [W0+1], W2
000D2E  984011     MOV.B W1, [W0+1]
000D30  370001     BRA 0xD34
2716:              		}
2717:              		else
2718:              		{
2719:              			BothEP0OutUOWNsSet = FALSE;
000D32  EF30BE     CLR BothEP0OutUOWNsSet
2720:              		}
2721:                  }
2722:              }
000D34  FA8000     ULNK
000D36  060000     RETURN
2723:              
2724:              /******************************************************************************
2725:               * Function:        void USBCtrlTrfInHandler(void)
2726:               *
2727:               * PreCondition:    None
2728:               *
2729:               * Input:           None
2730:               *
2731:               * Output:          None
2732:               *
2733:               * Side Effects:    None
2734:               *
2735:               * Overview:        This routine handles an IN transaction according to
2736:               *                  which control transfer state is currently active.
2737:               *
2738:               * Note:            A Set Address Request must not change the acutal address
2739:               *                  of the device until the completion of the control
2740:               *                  transfer. The end of the control transfer for Set Address
2741:               *                  Request is an IN transaction. Therefore it is necessary
2742:               *                  to service this unique situation when the condition is
2743:               *                  right. Macro mUSBCheckAdrPendingState is defined in
2744:               *                  usb9.h and its function is to specifically service this
2745:               *                  event.
2746:               *****************************************************************************/
2747:              static void USBCtrlTrfInHandler(void)
2748:              {
000564  FA0000     LNK #0x0
000566  BE9F88     MOV.D W8, [W15++]
2749:                  BYTE lastDTS;
2750:              
2751:                  lastDTS = pBDTEntryIn[0]->STAT.DTS;
000568  808560     MOV pBDTEntryIn, W0
00056A  784010     MOV.B [W0], W0
00056C  FB8480     ZE W0, W9
00056E  DE4CC6     LSR W9, #6, W9
000570  64C4E1     AND.B W9, #0x1, W9
2752:              
2753:                  //switch to the next ping pong buffer
2754:                  ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
000572  AA70AC     BTG pBDTEntryIn, #3
2755:              
2756:                  //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2757:                  //now, since the IN status stage of the (set address) control transfer has 
2758:                  //evidently completed successfully.
2759:                  if(USBDeviceState == ADR_PENDING_STATE)
000574  8084D0     MOV USBDeviceState, W0
000576  500FE8     SUB W0, #0x8, [W15]
000578  3A000A     BRA NZ, 0x58E
2760:                  {
2761:                      U1ADDR = SetupPkt.bDevADR.Val;
00057A  BFD0CE     MOV.B 0x10CE, WREG
00057C  FB8000     ZE W0, W0
00057E  882660     MOV W0, U1ADDR
2762:                      if(U1ADDR != 0u)
000580  802660     MOV U1ADDR, W0
000582  500FE0     SUB W0, #0x0, [W15]
000584  320002     BRA Z, 0x58A
2763:                      {
2764:                          USBDeviceState=ADDRESS_STATE;
000586  200100     MOV #0x10, W0
000588  370001     BRA 0x58C
2765:                      }
2766:                      else
2767:                      {
2768:                          USBDeviceState=DEFAULT_STATE;
00058A  200040     MOV #0x4, W0
00058C  8884D0     MOV W0, USBDeviceState
2769:                      }
2770:                  }//end if
2771:              
2772:              
2773:                  if(controlTransferState == CTRL_TRF_TX)
00058E  BFD0B9     MOV.B controlTransferState, WREG
000590  504FE1     SUB.B W0, #0x1, [W15]
000592  3A001F     BRA NZ, 0x5D2
2774:                  {
2775:                      pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
000594  808560     MOV pBDTEntryIn, W0
000596  210D41     MOV #0x10D4, W1
000598  904140     MOV.B [W0+4], W2
00059A  EB4400     CLR.B W8
00059C  984041     MOV.B W1, [W0+4]
00059E  DE08C8     LSR W1, #8, W1
0005A0  904150     MOV.B [W0+5], W2
0005A2  984051     MOV.B W1, [W0+5]
2776:                      USBCtrlTrfTxService();
0005A4  07FF27     RCALL _USBCtrlTrfTxService
2777:              
2778:                      //Check if we have already sent a short packet.  If so, configure
2779:                      //the endpoint to STALL in response to any further IN tokens (in the
2780:                      //case that the host erroneously tries to receive more data than it
2781:                      //should).
2782:                      if(shortPacketStatus == SHORT_PKT_SENT)
0005A6  210B81     MOV #0x10B8, W1
0005A8  784091     MOV.B [W1], W1
0005AA  808560     MOV pBDTEntryIn, W0
0005AC  50CFE2     SUB.B W1, #0x2, [W15]
0005AE  3A0003     BRA NZ, 0x5B6
2783:                      {
2784:                          // If a short packet has been sent, don't want to send any more,
2785:                          // stall next time if host is still trying to read.
2786:                          pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
0005B0  784090     MOV.B [W0], W1
0005B2  B3C841     MOV #0x84, W1
0005B4  37000A     BRA 0x5CA
2787:                      }
2788:                      else
2789:                      {
2790:                          if(lastDTS == 0)
0005B6  54CFE0     SUB.B W9, #0x0, [W15]
0005B8  3A0006     BRA NZ, 0x5C6
2791:                          {
2792:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0005BA  784090     MOV.B [W0], W1
0005BC  B3CC81     MOV #0xC8, W1
0005BE  784801     MOV.B W1, [W0]
0005C0  904090     MOV.B [W0+1], W1
0005C2  984019     MOV.B W9, [W0+1]
0005C4  370018     BRA 0x5F6
2793:                          }
2794:                          else
2795:                          {
2796:                              pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0005C6  784090     MOV.B [W0], W1
0005C8  B3C881     MOV #0x88, W1
0005CA  784801     MOV.B W1, [W0]
0005CC  904090     MOV.B [W0+1], W1
0005CE  984018     MOV.B W8, [W0+1]
0005D0  370012     BRA 0x5F6
2797:                          }
2798:                      }//end if(...)else
2799:                  }
2800:              	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2801:              	{
2802:                      //if someone is still expecting data from the control transfer
2803:                      //  then make sure to terminate that request and let them know that
2804:                      //  they are done
2805:                      if(outPipes[0].info.bits.busy == 1)
0005D2  BFD0A6     MOV.B 0x10A6, WREG
0005D4  3B000F     BRA NN, 0x5F4
2806:                      {
2807:                          if(outPipes[0].pFunc != NULL)
0005D6  BFD0A9     MOV.B 0x10A9, WREG
0005D8  FB8000     ZE W0, W0
0005DA  210AA1     MOV #0x10AA, W1
0005DC  784091     MOV.B [W1], W1
0005DE  DD08C8     SL W1, #8, W1
0005E0  708000     IOR W1, W0, W0
0005E2  320007     BRA Z, 0x5F2
2808:                          {
2809:                              outPipes[0].pFunc();
0005E4  BFD0A9     MOV.B 0x10A9, WREG
0005E6  FB8000     ZE W0, W0
0005E8  210AA1     MOV #0x10AA, W1
0005EA  784091     MOV.B [W1], W1
0005EC  DD08C8     SL W1, #8, W1
0005EE  708000     IOR W1, W0, W0
0005F0  010000     CALL W0
2810:                          }
2811:                          outPipes[0].info.bits.busy = 0;
0005F2  A9F0A6     BCLR 0x10A6, #7
2812:                      }
2813:                  	
2814:                      controlTransferState = WAIT_SETUP;
0005F4  EF70B9     CLR.B controlTransferState
2815:                      //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2816:                      //got processed by the USBCtrlTrfRxService() handler.
2817:              	}	
2818:              
2819:              }
0005F6  BE044F     MOV.D [--W15], W8
0005F8  FA8000     ULNK
0005FA  060000     RETURN
2820:              
2821:              
2822:              /********************************************************************
2823:               * Function:        void USBCheckStdRequest(void)
2824:               *
2825:               * PreCondition:    None
2826:               *
2827:               * Input:           None
2828:               *
2829:               * Output:          None
2830:               *
2831:               * Side Effects:    None
2832:               *
2833:               * Overview:        This routine checks the setup data packet to see
2834:               *                  if it knows how to handle it
2835:               *
2836:               * Note:            None
2837:               *******************************************************************/
2838:              static void USBCheckStdRequest(void)
2839:              {
0007E6  FA0000     LNK #0x0
2840:                  if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0007E8  BFD0CC     MOV.B SetupPkt, WREG
0007EA  B24600     AND.B #0x60, W0
0007EC  3A0039     BRA NZ, 0x860
2841:              
2842:                  switch(SetupPkt.bRequest)
0007EE  BFD0CD     MOV.B 0x10CD, WREG
0007F0  FB8000     ZE W0, W0
0007F2  200001     MOV #0x0, W1
0007F4  500FEB     SUB W0, #0xB, [W15]
0007F6  588FE0     SUBB W1, #0x0, [W15]
0007F8  3E0033     BRA GTU, 0x860
0007FA  010600     BRA W0
0007FC  370015     BRA 0x828
0007FE  370016     BRA 0x82C
000800  37002F     BRA 0x860
000802  370014     BRA 0x82C
000804  37002D     BRA 0x860
000806  370006     BRA 0x814
000808  370009     BRA 0x81C
00080A  370026     BRA 0x858
00080C  37000B     BRA 0x824
00080E  370008     BRA 0x820
000810  37000F     BRA 0x830
000812  370018     BRA 0x844
2843:                  {
2844:                      case USB_REQUEST_SET_ADDRESS:
2845:                          inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
000814  A8F092     BSET 0x1092, #7
2846:                          USBDeviceState = ADR_PENDING_STATE;       // Update state only
000816  200080     MOV #0x8, W0
000818  8884D0     MOV W0, USBDeviceState
2847:                          /* See USBCtrlTrfInHandler() for the next step */
2848:                          break;
00081A  370022     BRA 0x860
2849:                      case USB_REQUEST_GET_DESCRIPTOR:
2850:                          USBStdGetDscHandler();
00081C  07FE1B     RCALL _USBStdGetDscHandler
2851:                          break;
00081E  370020     BRA 0x860
2852:                      case USB_REQUEST_SET_CONFIGURATION:
2853:                          USBStdSetCfgHandler();
000820  07FFB9     RCALL _USBStdSetCfgHandler
2854:                          break;
000822  37001E     BRA 0x860
2855:                      case USB_REQUEST_GET_CONFIGURATION:
2856:                          inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
000824  2109C0     MOV #0x109C, W0
000826  370008     BRA 0x838
2857:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2858:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
2859:                          inPipes[0].info.bits.busy = 1;
2860:                          break;
2861:                      case USB_REQUEST_GET_STATUS:
2862:                          USBStdGetStatusHandler();
000828  07FE4C     RCALL _USBStdGetStatusHandler
2863:                          break;
00082A  37001A     BRA 0x860
2864:                      case USB_REQUEST_CLEAR_FEATURE:
2865:                      case USB_REQUEST_SET_FEATURE:
2866:                          USBStdFeatureReqHandler();
00082C  07FEFE     RCALL _USBStdFeatureReqHandler
2867:                          break;
00082E  370018     BRA 0x860
2868:                      case USB_REQUEST_GET_INTERFACE:
2869:                          inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
000830  BFD0D0     MOV.B 0x10D0, WREG
000832  FB8000     ZE W0, W0
000834  210B21     MOV #0x10B2, W1
000836  400001     ADD W0, W1, W0
000838  888480     MOV W0, inPipes
2870:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
00083A  A81092     BSET 0x1092, #0
2871:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
00083C  B3C010     MOV #0x1, W0
00083E  B7F094     MOV.B WREG, 0x1094
2872:                          inPipes[0].info.bits.busy = 1;
000840  A8F092     BSET 0x1092, #7
2873:                          break;
000842  37000E     BRA 0x860
2874:                      case USB_REQUEST_SET_INTERFACE:
2875:                          inPipes[0].info.bits.busy = 1;
000844  A8F092     BSET 0x1092, #7
2876:                          USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
000846  BFD0D0     MOV.B 0x10D0, WREG
000848  FB8000     ZE W0, W0
00084A  210B21     MOV #0x10B2, W1
00084C  408000     ADD W1, W0, W0
00084E  781F81     MOV W1, [W15++]
000850  210CE1     MOV #0x10CE, W1
000852  784811     MOV.B [W1], [W0]
000854  7800CF     MOV [--W15], W1
2877:                          break;
000856  370004     BRA 0x860
2878:                      case USB_REQUEST_SET_DESCRIPTOR:
2879:                          USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
000858  EB0100     CLR W2
00085A  EB0080     CLR W1
00085C  200020     MOV #0x2, W0
00085E  070650     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2880:                          break;
2881:                      case USB_REQUEST_SYNCH_FRAME:
2882:                      default:
2883:                          break;
2884:                  }//end switch
2885:              }//end USBCheckStdRequest
000860  FA8000     ULNK
000862  060000     RETURN
2886:              
2887:              /********************************************************************
2888:               * Function:        void USBStdFeatureReqHandler(void)
2889:               *
2890:               * PreCondition:    None
2891:               *
2892:               * Input:           None
2893:               *
2894:               * Output:          Can alter BDT entries.  Can also modify USB stack
2895:               *                  Maintained variables.
2896:               *
2897:               * Side Effects:    None
2898:               *
2899:               * Overview:        This routine handles the standard SET & CLEAR
2900:               *                  FEATURES requests
2901:               *
2902:               * Note:            This is a private function, intended for internal 
2903:               *                  use by the USB stack, when processing SET/CLEAR
2904:               *                  feature requests.  
2905:               *******************************************************************/
2906:              static void USBStdFeatureReqHandler(void)
2907:              {
00062A  FA0002     LNK #0x2
00062C  BE9F88     MOV.D W8, [W15++]
2908:                  BDT_ENTRY *p;
2909:                  EP_STATUS current_ep_data;
2910:                  #if defined(__C32__)
2911:                      DWORD* pUEP;
2912:                  #else
2913:                      unsigned char* pUEP;             
2914:                  #endif
2915:                  
2916:              
2917:                  #ifdef	USB_SUPPORT_OTG
2918:                  //Check for USB On-The-Go (OTG) specific requests
2919:                  if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2920:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2921:                  {  
2922:                      inPipes[0].info.bits.busy = 1;
2923:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2924:                          USBOTGEnableHnp();
2925:                      else
2926:                          USBOTGDisableHnp();
2927:                  }
2928:              
2929:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2930:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2931:                  {
2932:                      inPipes[0].info.bits.busy = 1;
2933:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2934:                          USBOTGEnableSupportHnp();
2935:                      else
2936:                          USBOTGDisableSupportHnp();
2937:                  }
2938:              
2939:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2940:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2941:                  {
2942:                      inPipes[0].info.bits.busy = 1;
2943:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2944:                          USBOTGEnableAltHnp();
2945:                      else
2946:                          USBOTGDisableAltHnp();
2947:                  }
2948:                  #endif   //#ifdef USB_SUPPORT_OTG 
2949:              
2950:                  //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2951:                  if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
00062E  BFD0CE     MOV.B 0x10CE, WREG
000630  504FE1     SUB.B W0, #0x1, [W15]
000632  3A000B     BRA NZ, 0x64A
000638  3A0008     BRA NZ, 0x64A
2952:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
000634  BFD0CC     MOV.B SetupPkt, WREG
000636  60407F     AND.B W0, #0x1F, W0
2953:                  {
2954:                      inPipes[0].info.bits.busy = 1;
00063A  A8F092     BSET 0x1092, #7
2955:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00063C  BFD0CD     MOV.B 0x10CD, WREG
00063E  504FE3     SUB.B W0, #0x3, [W15]
000640  3A0003     BRA NZ, 0x648
2956:                          RemoteWakeup = TRUE;
000642  200010     MOV #0x1, W0
000644  8884B0     MOV W0, RemoteWakeup
000646  370001     BRA 0x64A
2957:                      else
2958:                          RemoteWakeup = FALSE;
000648  EF3096     CLR RemoteWakeup
2959:                  }//end if
2960:              
2961:                  //Check if the host sent a valid SET or CLEAR endpoint halt request.
2962:                  if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
00064A  BFD0CE     MOV.B 0x10CE, WREG
00064C  3A00A0     BRA NZ, 0x78E
000652  504FE2     SUB.B W0, #0x2, [W15]
000654  3A009C     BRA NZ, 0x78E
2963:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
00064E  BFD0CC     MOV.B SetupPkt, WREG
000650  60407F     AND.B W0, #0x1F, W0
00065A  320099     BRA Z, 0x78E
2964:                     (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
000656  BFD0D0     MOV.B 0x10D0, WREG
000658  60406F     AND.B W0, #0xF, W0
00065C  BFD0D0     MOV.B 0x10D0, WREG
00065E  60006F     AND W0, #0xF, W0
000660  500FE2     SUB W0, #0x2, [W15]
000662  3C0095     BRA GT, 0x78E
000666  200200     MOV #0x20, W0
000668  508F80     SUB W1, W0, [W15]
00066A  3A0091     BRA NZ, 0x78E
2965:                     (USBDeviceState == CONFIGURED_STATE))
000664  8084D1     MOV USBDeviceState, W1
2966:                  {
2967:              		//The request was valid.  Take control of the control transfer and
2968:              		//perform the host requested action.
2969:              		inPipes[0].info.bits.busy = 1;
00066C  A8F092     BSET 0x1092, #7
2970:              
2971:                      //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2972:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
00066E  BFD0D0     MOV.B 0x10D0, WREG
000670  33000A     BRA N, 0x686
2973:                      {
2974:                          p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
000672  BFD0D0     MOV.B 0x10D0, WREG
000674  60006F     AND W0, #0xF, W0
000676  400000     ADD W0, W0, W0
000678  2109E1     MOV #0x109E, W1
00067A  408000     ADD W1, W0, W0
00067C  780F10     MOV [W0], [W14]
2975:                          current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
00067E  BFD0D0     MOV.B 0x10D0, WREG
000680  60006F     AND W0, #0xF, W0
000682  210C31     MOV #0x10C3, W1
000684  370009     BRA 0x698
2976:                      }
2977:                      else
2978:                      {
2979:                          p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
000686  BFD0D0     MOV.B 0x10D0, WREG
000688  60006F     AND W0, #0xF, W0
00068A  400000     ADD W0, W0, W0
00068C  210AC1     MOV #0x10AC, W1
00068E  408000     ADD W1, W0, W0
000690  780F10     MOV [W0], [W14]
2980:                          current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
000692  BFD0D0     MOV.B 0x10D0, WREG
000694  60006F     AND W0, #0xF, W0
000696  210C01     MOV #0x10C0, W1
000698  408000     ADD W1, W0, W0
00069A  784410     MOV.B [W0], W8
2981:                      }
2982:              
2983:                      //If ping pong buffering is enabled on the requested endpoint, need 
2984:                      //to point to the one that is the active BDT entry which the SIE will 
2985:                      //use for the next attempted transaction on that EP number.
2986:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2987:                          if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00069C  644061     AND.B W8, #0x1, W0
00069E  3A0002     BRA NZ, 0x6A4
2988:                          {
2989:                              USBHALPingPongSetToEven(&p);
0006A0  A1341E     BCLR.B [W14], #3
0006A2  370001     BRA 0x6A6
2990:                          }
2991:                          else //else must have been odd
2992:                          {
2993:                              USBHALPingPongSetToOdd(&p);
0006A4  A0341E     BSET.B [W14], #3
2994:                          }
2995:                      #endif
2996:                      
2997:                      //Update the BDT pointers with the new, next entry based on the feature
2998:                      //  request
2999:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
0006A6  BFD0D0     MOV.B 0x10D0, WREG
0006A8  330005     BRA N, 0x6B4
3000:                      {
3001:                          pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
0006AA  BFD0D0     MOV.B 0x10D0, WREG
0006AC  60006F     AND W0, #0xF, W0
0006AE  400000     ADD W0, W0, W0
0006B0  2109E1     MOV #0x109E, W1
0006B2  370004     BRA 0x6BC
3002:                      }
3003:                      else
3004:                      {
3005:                          pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
0006B4  BFD0D0     MOV.B 0x10D0, WREG
0006B6  60006F     AND W0, #0xF, W0
0006B8  400000     ADD W0, W0, W0
0006BA  210AC1     MOV #0x10AC, W1
0006BC  408000     ADD W1, W0, W0
0006BE  78081E     MOV [W14], [W0]
3006:                      }
3007:              
3008:              		//Check if it was a SET_FEATURE endpoint halt request
3009:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0006C0  BFD0CD     MOV.B 0x10CD, WREG
0006C2  504FE3     SUB.B W0, #0x3, [W15]
0006C4  3A001B     BRA NZ, 0x6FC
3010:                      {
3011:                          if(p->STAT.UOWN == 1)
0006C6  78001E     MOV [W14], W0
0006C8  EB4080     CLR.B W1
0006CA  10CF90     SUBR.B W1, [W0], [W15]
0006CC  3D000C     BRA GE, 0x6E6
3012:                          {
3013:                              //Mark that we are terminating this transfer and that the user
3014:                              //  needs to be notified later
3015:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0006CE  BFD0D0     MOV.B 0x10D0, WREG
0006D0  504F81     SUB.B W0, W1, [W15]
0006D2  350004     BRA LT, 0x6DC
3016:                              {
3017:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0006D4  BFD0D0     MOV.B 0x10D0, WREG
0006D6  60006F     AND W0, #0xF, W0
0006D8  210C31     MOV #0x10C3, W1
0006DA  370003     BRA 0x6E2
3018:                              }
3019:                              else
3020:                              {
3021:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
0006DC  BFD0D0     MOV.B 0x10D0, WREG
0006DE  60006F     AND W0, #0xF, W0
0006E0  210C01     MOV #0x10C0, W1
0006E2  408000     ADD W1, W0, W0
0006E4  A01410     BSET.B [W0], #1
3022:                              }
3023:                          }
3024:              
3025:              			//Then STALL the endpoint
3026:                          p->STAT.Val |= _USIE|_BSTALL;
0006E6  78001E     MOV [W14], W0
0006E8  784090     MOV.B [W0], W1
0006EA  FB8101     ZE W1, W2
0006EC  904090     MOV.B [W0+1], W1
0006EE  DD08C8     SL W1, #8, W1
0006F0  708082     IOR W1, W2, W1
0006F2  B30841     IOR #0x84, W1
0006F4  784801     MOV.B W1, [W0]
0006F6  DE08C8     LSR W1, #8, W1
0006F8  984011     MOV.B W1, [W0+1]
0006FA  370049     BRA 0x78E
3027:                      }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
3028:                      else
3029:                      {
3030:              			//Else the request must have been a CLEAR_FEATURE endpoint halt.
3031:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3032:                              //toggle over the to the non-active BDT
3033:                              USBAdvancePingPongBuffer(&p);  
0006FC  78048E     MOV W14, W9
0006FE  A2341E     BTG.B [W14], #3
3034:              
3035:                              if(p->STAT.UOWN == 1)
000700  78009E     MOV [W14], W1
000702  784111     MOV.B [W1], W2
000704  FB8182     ZE W2, W3
000706  904111     MOV.B [W1+1], W2
000708  EB4000     CLR.B W0
00070A  104F91     SUBR.B W0, [W1], [W15]
00070C  3D000B     BRA GE, 0x724
3036:                              {
3037:                                  //Clear UOWN and set DTS state so it will be correct the next time
3038:                                  //the application firmware uses USBTransferOnePacket() on the EP.
3039:                                  p->STAT.Val &= (~_USIE);    //Clear UOWN bit
00070E  DD1048     SL W2, #8, W0
000710  700003     IOR W0, W3, W0
000712  A17000     BCLR W0, #7
3040:                                  p->STAT.Val |= _DAT1;       //Set DTS to DATA1
000714  A06000     BSET W0, #6
000716  784880     MOV.B W0, [W1]
000718  DE0048     LSR W0, #8, W0
00071A  984090     MOV.B W0, [W1+1]
3041:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
00071C  200022     MOV #0x2, W2
00071E  200050     MOV #0x5, W0
000720  0706EF     RCALL USER_USB_CALLBACK_EVENT_HANDLER
000722  370006     BRA 0x730
3042:                              }
3043:                              else
3044:                              {
3045:                                  //UOWN already clear, but still need to set DTS to DATA1     
3046:              					p->STAT.Val |= _DAT1;
000724  DD1048     SL W2, #8, W0
000726  700003     IOR W0, W3, W0
000728  A06000     BSET W0, #6
00072A  784880     MOV.B W0, [W1]
00072C  DE0048     LSR W0, #8, W0
00072E  984090     MOV.B W0, [W1+1]
3047:                              }
3048:              
3049:                              //toggle back to the active BDT (the one the SIE is currently looking at
3050:                              //and will use for the next successful transaction to take place on the EP
3051:                              USBAdvancePingPongBuffer(&p);    
000730  A23419     BTG.B [W9], #3
3052:                              
3053:                              //Check if we are currently terminating, or have previously terminated
3054:                              //a transaction on the given endpoint.  If so, need to clear UOWN,
3055:                              //set DTS to the proper state, and call the application callback
3056:                              //function.
3057:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
000732  644462     AND.B W8, #0x2, W8
000734  3A0004     BRA NZ, 0x73E
000736  78001E     MOV [W14], W0
000738  EB4080     CLR.B W1
00073A  10CF90     SUBR.B W1, [W0], [W15]
00073C  3D0019     BRA GE, 0x770
3058:                              {
3059:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00073E  BFD0D0     MOV.B 0x10D0, WREG
000740  330004     BRA N, 0x74A
3060:                                  {
3061:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
000742  BFD0D0     MOV.B 0x10D0, WREG
000744  60006F     AND W0, #0xF, W0
000746  210C31     MOV #0x10C3, W1
000748  370003     BRA 0x750
3062:                                  }
3063:                                  else
3064:                                  {
3065:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
00074A  BFD0D0     MOV.B 0x10D0, WREG
00074C  60006F     AND W0, #0xF, W0
00074E  210C01     MOV #0x10C0, W1
000750  408000     ADD W1, W0, W0
000752  A11410     BCLR.B [W0], #1
3066:                                  }
3067:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3068:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
000754  78009E     MOV [W14], W1
000756  784011     MOV.B [W1], W0
000758  FB8100     ZE W0, W2
00075A  904011     MOV.B [W1+1], W0
00075C  DD0048     SL W0, #8, W0
00075E  700002     IOR W0, W2, W0
000760  B3C3B2     MOV #0x3B, W2
000762  604882     AND.B W0, W2, [W1]
000764  DE0048     LSR W0, #8, W0
000766  984090     MOV.B W0, [W1+1]
3069:                                  //Call the application event handler callback function, so it can 
3070:              					//decide if the endpoint should get re-armed again or not.
3071:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
000768  200022     MOV #0x2, W2
00076A  200050     MOV #0x5, W0
00076C  0706C9     RCALL USER_USB_CALLBACK_EVENT_HANDLER
00076E  370009     BRA 0x782
3072:                              }
3073:                              else
3074:                              {
3075:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3076:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
000770  784090     MOV.B [W0], W1
000772  FB8101     ZE W1, W2
000774  904090     MOV.B [W0+1], W1
000776  DD08C8     SL W1, #8, W1
000778  708082     IOR W1, W2, W1
00077A  B3C3B2     MOV #0x3B, W2
00077C  60C802     AND.B W1, W2, [W0]
00077E  DE08C8     LSR W1, #8, W1
000780  984011     MOV.B W1, [W0+1]
3077:                              } 
3078:                          #else //else we must not be using ping-pong buffering on the requested endpoint
3079:                              //Check if we need to call the user transfer terminated event callback function.
3080:                              //We should call the callback, if the endpoint was previously terminated,
3081:                              //or the endpoint is currently armed, and the host is performing clear
3082:                              //endpoint halt, even though the endpoint wasn't stalled.
3083:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
3084:                              {
3085:                                  //We are going to call the user transfer terminated callback.
3086:                                  //Clear the flag so we know we took care of it and don't need
3087:                                  //to call it again later.
3088:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
3089:                                  {
3090:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
3091:                                  }
3092:                                  else
3093:                                  {
3094:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
3095:                                  }
3096:               
3097:                                  //Clear UOWN and remove the STALL condition.   
3098:                                  //  In this case we also need to set the DTS bit to 1 so that
3099:                                  //  it toggles to DATA0 the next time the application firmware
3100:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
3101:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
3102:                                  p->STAT.Val |= _DAT1;
3103:                                  //Let the application firmware know a transaction just
3104:                                  //got terminated by the host, and that it is now free to
3105:                                  //re-arm the endpoint or do other tasks if desired.                                        
3106:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
3107:                              }
3108:                              else
3109:                              {
3110:                                  //Clear UOWN and remove the STALL condition.   
3111:                                  //  In this case we also need to set the DTS bit to 1 so that
3112:                                  //  it toggles to DATA0 the next time the application firmware
3113:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
3114:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
3115:                                  p->STAT.Val |= _DAT1;
3116:                              } 
3117:                          #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3118:                          
3119:              			//Get a pointer to the appropriate UEPn register
3120:                          #if defined(__C32__)
3121:                              pUEP = (DWORD*)(&U1EP0);
3122:                              pUEP += (SetupPkt.EPNum*4);
3123:                          #else
3124:                              pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
000782  BFD0D0     MOV.B 0x10D0, WREG
000784  60006F     AND W0, #0xF, W0
000786  400000     ADD W0, W0, W0
000788  204E01     MOV #0x4E0, W1
00078A  400001     ADD W0, W1, W0
3125:                          #endif
3126:              
3127:              			//Clear the STALL bit in the UEP register
3128:                          *pUEP &= ~UEP_STALL;            
00078C  A11410     BCLR.B [W0], #1
3129:                      }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
3130:                  }//end if (lots of checks for set/clear endpoint halt)
3131:              }//end USBStdFeatureReqHandler
00078E  BE044F     MOV.D [--W15], W8
000790  FA8000     ULNK
000792  060000     RETURN
3132:              
3133:              
3134:              /** EOF USBDevice.c *****************************************************/
